<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>浅谈Java中的尾递归——尾递归与垃圾回收的比较 | Mr8god&#39;s website</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="浅谈Java中的尾递归——尾递归与垃圾回收的比较一、首先说一下什么是递归 递归的本质是，某个方法调用了本身，本质还是调用一个方法，只是这个方法它恰好就是本身而已  递归因为是在自身中调用自身，所以会有下面三个较为显著的特点：  调用的是同一个方法  因为1，所以只需要写一个方法，就可以让你轻松调用无数次，所以调用的方法可大可小，具体取决于你的实际案例  在自身中调用自身，是嵌套调用（栈帧无法回收，">
<meta property="og:type" content="article">
<meta property="og:title" content="浅谈Java中的尾递归——尾递归与垃圾回收的比较">
<meta property="og:url" content="https://justtchachv.cn/2020/03/20/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84%E5%B0%BE%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E5%B0%BE%E9%80%92%E5%BD%92%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E6%AF%94%E8%BE%83/index.html">
<meta property="og:site_name" content="Mr8god&#39;s website">
<meta property="og:description" content="浅谈Java中的尾递归——尾递归与垃圾回收的比较一、首先说一下什么是递归 递归的本质是，某个方法调用了本身，本质还是调用一个方法，只是这个方法它恰好就是本身而已  递归因为是在自身中调用自身，所以会有下面三个较为显著的特点：  调用的是同一个方法  因为1，所以只需要写一个方法，就可以让你轻松调用无数次，所以调用的方法可大可小，具体取决于你的实际案例  在自身中调用自身，是嵌套调用（栈帧无法回收，">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-03-20T15:18:19.871Z">
<meta property="article:modified_time" content="2020-03-20T15:18:05.891Z">
<meta property="article:author" content="Mr8god">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Mr8god&#39;s website" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Mr8god&#39;s website</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">coding,coding,always coding!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://justtchachv.cn"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-浅谈Java中的尾递归——尾递归与垃圾回收的比较" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/20/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84%E5%B0%BE%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E5%B0%BE%E9%80%92%E5%BD%92%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E6%AF%94%E8%BE%83/" class="article-date">
  <time datetime="2020-03-20T15:18:19.871Z" itemprop="datePublished">2020-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      浅谈Java中的尾递归——尾递归与垃圾回收的比较
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="浅谈Java中的尾递归——尾递归与垃圾回收的比较"><a href="#浅谈Java中的尾递归——尾递归与垃圾回收的比较" class="headerlink" title="浅谈Java中的尾递归——尾递归与垃圾回收的比较"></a>浅谈Java中的尾递归——尾递归与垃圾回收的比较</h1><h2 id="一、首先说一下什么是递归"><a href="#一、首先说一下什么是递归" class="headerlink" title="一、首先说一下什么是递归"></a>一、首先说一下什么是递归</h2><ol>
<li><p>递归的本质是，某个方法调用了本身，本质还是调用一个方法，只是这个方法它恰好就是本身而已</p>
</li>
<li><p>递归因为是在自身中调用自身，所以会有下面三个较为显著的特点：</p>
<ol>
<li><p>调用的是同一个方法</p>
</li>
<li><p>因为1，所以只需要写一个方法，就可以让你轻松调用无数次，所以调用的方法可大可小，具体取决于你的实际案例</p>
</li>
<li><p>在自身中调用自身，是嵌套调用（栈帧无法回收，开销巨大）</p>
</li>
</ol>
</li>
<li><p>结合以上2和3的两个特点，所以递归调用最大的诟病就是开销巨大，栈帧和堆有时候会一起爆掉，俗称内存溢出</p>
</li>
<li><p>既然会导致内存溢出的话，我们就提出了尾递归这样一种解决思路</p>
</li>
</ol>
<h2 id="二、尾递归优化"><a href="#二、尾递归优化" class="headerlink" title="二、尾递归优化"></a>二、尾递归优化</h2><ol>
<li><p>尾递归优化是利用上面的第一个特点“调用同一个方法”来进行优化的</p>
</li>
<li><p>尾递归优化其实包括两个东西：1）尾递归的形式；2）编译器对尾递归的优化</p>
<ol>
<li>尾递归的形式：<ol>
<li>尾递归其实只是一种对递归的特殊写法，这种写法原本并不会带来跟递归不一样的影响，它只是写法不一样而已，写成这样不会有任何优化效果，该爆的栈和帧都还会爆</li>
<li>那么具体的不一样体现在哪里呢<ol>
<li>前面说了，递归的本质是某个方法调用了自身，尾递归这种形式就要求：某个方法调用自身这件事，一定是该方法做的最后一件事（所以当有需要返回值的时候会是return f(n)，没有返回的话就直接是f(n)了）</li>
</ol>
</li>
<li>要求很简单，就是只有一条，但是有一些常见的误区<ol>
<li>这个f(n)外不能加其他东西，因为这就不是最后一件事了，值返回来后还要再干点其他的活，变量空间还需要保留<ol>
<li>比如如果有返回值的，你不能：乘个常数 return 3f(n)；乘个n return n*f(n)；甚至是 f(n)+f(n-1)</li>
</ol>
</li>
</ol>
</li>
<li>另外，使用return的尾递归还跟函数式编程有一点关系</li>
</ol>
</li>
</ol>
</li>
<li><p>为什么写成尾递归的形式，编译器就能优化了？或者说【编译器对尾递归的优化】的一些深层思想</p>
<ol>
<li>说是深层思想，其实也是因为正好编译器其实在这里没做什么复杂的事，所以很简单</li>
<li>由于这两方面的原因，尾递归优化得以实现，而且效果很好<ol>
<li>因为在递归调用自身的时候，这一层函数已经没有要做的事情了，虽然被递归调用的函数是在当前的函数里，但是他们之间的关系已经在传参的时候了断了，也就是这一层函数的所有变量什么的都不会再被用到了，所以当前函数虽然没有执行完，不能弹出栈，但它确实已经可以出栈了，这是一方面</li>
<li>另一方面，正因为调用的是自身，所以需要的存储空间是一毛一样的，那干脆重新刷新这些空间给下一层利用就好了，不用销毁再另开空间</li>
</ol>
</li>
<li>有人对写成尾递归形式的说法是【为了告诉编译器这块要尾递归】，这种说法可能会导致误解，因为不是只告诉编译器就行，而是你需要做优化的前半部分，之后编译器做后半部分</li>
</ol>
</li>
<li><p>所以总结：为了解决递归的开销大问题，使用尾递归优化，具体分两步：1）你把递归调用的形式写成尾递归的形式；2）编译器碰到尾递归，自动按照某种特定的方式进行优化编译</p>
</li>
<li><p>举例：</p>
<p>（no尾递归）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">recsum</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="function">  <span class="keyword">if</span> x </span>== <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> x + recsum(x - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>（使用尾递归）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">tailrecsum</span><span class="params">(x, running_total=<span class="number">0</span>)</span>:</span></span><br><span class="line"><span class="function">  <span class="keyword">if</span> x </span>== <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> running_total</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> tailrecsum(x - <span class="number">1</span>, running_total + x)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>但不是所有语言的编译器都做了尾递归优化。比如C实现了，JAVA没有去实现</p>
<p>说到这里你很容易联想到JAVA中的自动垃圾回收机制，同是处理内存问题的机制，尾递归优化跟垃圾回收是不是有什么关系，这是不是就是JAVA不实现尾递归优化的原因？</p>
<h2 id="三、所以下面要讲一下垃圾回收（GC）"><a href="#三、所以下面要讲一下垃圾回收（GC）" class="headerlink" title="三、所以下面要讲一下垃圾回收（GC）"></a>三、所以下面要讲一下垃圾回收（GC）</h2><ol>
<li>首先我们需要谈一下内存机制，这里我们需要了解内存机制的两个部分：栈和堆。下面虽然是在说JAVA，但是C也是差不多的<ol>
<li>在Java中， JVM中的栈记录了线程的方法调用。每个线程拥有一个栈。在某个线程的运行过程中， 如果有新的方法调用，那么该线程对应的栈就会增加一个存储单元，即栈帧 (frame)。在frame 中，保存有该方法调用的参数、局部变量和返回地址</li>
<li>Java的参数和局部变量只能是 基本类型 的变量(比如 int)，或者对象的引用(reference) 。因此，在栈中，只保存有基本类型的变量和对象引用。而引用所指向的对象保存在堆中。</li>
</ol>
</li>
<li>然后由栈和堆的空间管理方式的不同，引出垃圾回收的概念<ol>
<li>当被调用方法运行结束时，该方法对应的帧将被删除，参数和局部变量所占据的空间也随之释放。线程回到原方法，继续执行。当所有的栈都清空时，程序也随之运行结束。</li>
<li>如上所述，栈 (stack)可以自己照顾自己。但堆必须要小心对待。堆是 JVM中一块可自由分配给对象的区域。当我们谈论垃圾回收 (garbage collection) 时，我们主要<strong>回收堆(heap)的空间</strong>。</li>
<li>Java的普通对象存活在堆中。与栈不同，堆的空间不会随着方法调用结束而清空（即使它在栈上的引用已经被清空了）（也不知道为什么不直接同步清空）。因此，在某个方法中创建的对象，可以在方法调用结束之后，继续存在于堆中。这带来的一个问题是，如果我们不断的创建新的对象，内存空间将最终消耗殆尽。</li>
<li>如果没有垃圾回收机制的话，你就需要手动地显式分配及释放内存，如果你忘了去释放内存，那么这块内存就无法重用了（不管是什么局部变量还是其他的什么）。这块内存被占有了却没被使用，这种场景被称之为内存泄露</li>
</ol>
</li>
<li>所以不管是C还是JAVA，最原始的情况，都是需要手动释放堆中的对象，C到现在也是这样，所以你经常需要考虑对象的生存周期，但是JAVA则引入了一个自动垃圾回收的机制，它能智能地释放那些被判定已经没有用的对象</li>
</ol>
<h2 id="四、现在我们就可以比较一下尾递归优化和垃圾回收了"><a href="#四、现在我们就可以比较一下尾递归优化和垃圾回收了" class="headerlink" title="四、现在我们就可以比较一下尾递归优化和垃圾回收了"></a>四、<strong>现在我们就可以比较一下尾递归优化和垃圾回收了</strong></h2><ol>
<li><p>富士达他们最本质的区别是，尾递归优化解决的是内存溢出的问题，而垃圾回收解决的是内存泄露的问题</p>
<ol>
<li>内存泄露：指程序中动态分配内存给一些临时对象，但是对象不会被GC所回收，它始终占用内存。即被分配的对象可达但已无用。</li>
<li>内存溢出：指程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。</li>
<li>从定义上可以看出内存泄露是内存溢出的一种诱因，不是唯一因素。</li>
</ol>
</li>
<li><p>自动垃圾回收机制的特点是：</p>
<ol>
<li>解决了所有情况下的内存泄露的问题，但还可以由于其他原因内存溢出</li>
<li>针对内存中的堆空间</li>
<li>正在运行的方法中的堆中的对象是不会被管理的，因为还有引用（栈帧没有被清空）<ol>
<li>一般简单的自动垃圾回收机制是采用 引用计数 (reference counting)的机制。每个对象包含一个计数器。当有新的指向该对象的引用时，计数器加 1。当引用移除时，计数器减 1，当计数器为0时，认为该对象可以进行垃圾回收</li>
</ol>
</li>
</ol>
</li>
<li><p>与之相对，尾递归优化的特点是：</p>
<ol>
<li><p>优化了递归调用时的内存溢出问题</p>
</li>
<li><p>针对内存中的堆空间和栈空间</p>
</li>
<li><p>只在递归调用的时候使用，而且只能对于写成尾递归形式的递归进行优化</p>
</li>
<li><p>正在运行的方法的堆和栈空间正是优化的目标</p>
<p>​    </p>
</li>
</ol>
</li>
</ol>
<p>最后可以解答一下前头提出的问题</p>
<ol>
<li>通过比较可以发现尾递归和GC是完全不一样的，JAVA不会是因为有GC所以不需要尾递归优化。那为什么呢，我看到有的说法是：JAVA编写组不实现尾递归优化是觉得麻烦又没有太大的必要，就懒得实现了（原话是：在日程表上，但是非常靠后），官方的建议是不使用递归，而是使用while循环，迭代，递推</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://justtchachv.cn/2020/03/20/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84%E5%B0%BE%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E5%B0%BE%E9%80%92%E5%BD%92%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E6%AF%94%E8%BE%83/" data-id="ck88gjjr2000grgto9rtmfg5m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/03/21/%E4%BB%8A%E5%A4%A9%E4%B8%BB%E8%A6%81%E5%BC%80%E5%A7%8B%E6%88%91%E7%9A%84%E4%BB%A5Django%E6%A1%86%E6%9E%B6%E4%B8%BA%E5%9F%BA%E7%A1%80%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E5%95%A6/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          今天主要开始我的以Django框架为基础的博客开发啦
        
      </div>
    </a>
  
  
    <a href="/2020/03/20/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">概率论与数理统计</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AA%E4%BA%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%84%9F%E6%85%A8%E5%95%A6%EF%BC%81%EF%BC%81%EF%BC%81/" rel="tag">个人的一些小感慨啦！！！</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E4%B8%AA%E4%BA%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%84%9F%E6%85%A8%E5%95%A6%EF%BC%81%EF%BC%81%EF%BC%81/" style="font-size: 10px;">个人的一些小感慨啦！！！</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/25/%E7%AC%AC7%E7%AB%A0%20%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94C++%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97/">第7章 函数——C++的编程模块</a>
          </li>
        
          <li>
            <a href="/2020/03/25/%E6%AF%8F%E5%A4%A9%E5%92%8CDell%E5%AE%A2%E6%9C%8D%E5%AD%A6%E4%B8%80%E6%8B%9BDay7/">每天和Dell客服学一招Day7</a>
          </li>
        
          <li>
            <a href="/2020/03/25/%E6%AF%8F%E5%A4%A9%E5%92%8CDell%E5%AE%A2%E6%9C%8D%E5%AD%A6%E4%B8%80%E6%8B%9BDay6/">每天和Dell客服学一招Day6</a>
          </li>
        
          <li>
            <a href="/2020/03/25/%E6%AF%8F%E5%A4%A9%E5%92%8CDell%E5%AE%A2%E6%9C%8D%E5%AD%A6%E4%B8%80%E6%8B%9BDay3/">每天和Dell客服学一招Day3</a>
          </li>
        
          <li>
            <a href="/2020/03/25/%E6%AF%8F%E5%A4%A9%E5%92%8CDell%E5%AE%A2%E6%9C%8D%E5%AD%A6%E4%B8%80%E6%8B%9BDay4/">每天和Dell客服学一招Day4</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Mr8god<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>