<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr8god&#39;s blog</title>
  
  <subtitle>coding,coding,always coding!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mr8god.cn/"/>
  <updated>2020-04-07T08:33:49.172Z</updated>
  <id>https://mr8god.cn/</id>
  
  <author>
    <name>Mr8god</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面向对象快速回顾(以便于考试快速回顾哈！)</title>
    <link href="https://mr8god.cn/2020/04/07/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE/"/>
    <id>https://mr8god.cn/2020/04/07/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE/</id>
    <published>2020-04-07T08:32:43.436Z</published>
    <updated>2020-04-07T08:33:49.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象快速回顾"><a href="#面向对象快速回顾" class="headerlink" title="面向对象快速回顾"></a>面向对象快速回顾</h1><p>345</p><p>3种类型：类、接口、枚举</p><p>4个修饰符：private|protected|public、final、static、abstract</p><p>5个成员</p><h2 id="定义类的语法"><a href="#定义类的语法" class="headerlink" title="定义类的语法"></a>定义类的语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 类名 extends 父类</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; 5大成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义成员变量"><a href="#定义成员变量" class="headerlink" title="定义成员变量"></a>定义成员变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 类型 变量名[ &#x3D; 初始值];</span><br></pre></td></tr></table></figure><h2 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 返回值类型 方法名（形参列表）</span><br><span class="line">&#123;</span><br><span class="line">语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义构造器"><a href="#定义构造器" class="headerlink" title="定义构造器"></a>定义构造器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 构造器名（形参列表）</span><br><span class="line">&#123;</span><br><span class="line">语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义初始化块"><a href="#定义初始化块" class="headerlink" title="定义初始化块"></a>定义初始化块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[static] &#123;</span><br><span class="line">语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类用于干甚？"><a href="#类用于干甚？" class="headerlink" title="类用于干甚？"></a>类用于干甚？</h2><ul><li>定义变量</li><li>创建对象</li><li>调用类、方法或者是访问类变量</li><li>派生子类</li></ul><h2 id="对象用于干甚？"><a href="#对象用于干甚？" class="headerlink" title="对象用于干甚？"></a>对象用于干甚？</h2><ul><li>调用实例方法或访问实例变量</li></ul><h2 id="方法（传参机制、递归方法、形参个数可变的方法、方法重载）"><a href="#方法（传参机制、递归方法、形参个数可变的方法、方法重载）" class="headerlink" title="方法（传参机制、递归方法、形参个数可变的方法、方法重载）"></a>方法（传参机制、递归方法、形参个数可变的方法、方法重载）</h2><h2 id="变量（判断变量：先看位置，再看static；成员变量和局部变量）"><a href="#变量（判断变量：先看位置，再看static；成员变量和局部变量）" class="headerlink" title="变量（判断变量：先看位置，再看static；成员变量和局部变量）"></a>变量（判断变量：先看位置，再看static；成员变量和局部变量）</h2><h2 id="构造器（构造器重载、this调用）"><a href="#构造器（构造器重载、this调用）" class="headerlink" title="构造器（构造器重载、this调用）"></a>构造器（构造器重载、this调用）</h2><p>this调用——出现在构造器的第一行，表明调用同一个类中重载的构造器</p><h2 id="初始化块（实例初始化块、类初始化块）"><a href="#初始化块（实例初始化块、类初始化块）" class="headerlink" title="初始化块（实例初始化块、类初始化块）"></a>初始化块（实例初始化块、类初始化块）</h2><p>实力初始化块：本质是构造器所有代码之前的代码；</p><p>类初始化块：本质是该类第一次被主动执行时，只运行一次。</p><h2 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h2><p>private —&gt; 不写 —&gt; protected —&gt; public</p><h2 id="继承、多态"><a href="#继承、多态" class="headerlink" title="继承、多态"></a>继承、多态</h2><p>Java是单继承的。</p><p>方法重写：两同两小一大。</p><p>子类构造器一定会调用父类构造器一次：创建任何对象，都是从Object的构造器开始执行的。</p><p>多态中：</p><p>​    方法执行：总是动态绑定实际类型的方法。<br>​                        强制转换、instanceof - 必须在有继承关系的两个类型之间进行处理，否则会编译报错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面向对象快速回顾&quot;&gt;&lt;a href=&quot;#面向对象快速回顾&quot; class=&quot;headerlink&quot; title=&quot;面向对象快速回顾&quot;&gt;&lt;/a&gt;面向对象快速回顾&lt;/h1&gt;&lt;p&gt;345&lt;/p&gt;
&lt;p&gt;3种类型：类、接口、枚举&lt;/p&gt;
&lt;p&gt;4个修饰符：private|p
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java面向对象基础回顾</title>
    <link href="https://mr8god.cn/2020/04/06/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/"/>
    <id>https://mr8god.cn/2020/04/06/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/</id>
    <published>2020-04-06T15:52:38.083Z</published>
    <updated>2020-04-07T07:00:45.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java面向对象基础回顾"><a href="#Java面向对象基础回顾" class="headerlink" title="Java面向对象基础回顾"></a>Java面向对象基础回顾</h1><p>定义类、创建对象、调用方法</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><pre><code>[修饰符] class 类名{    //成员变量    //方法    //构造器    //初始化块    //内部类}</code></pre><h2 id="定义成员变量"><a href="#定义成员变量" class="headerlink" title="定义成员变量"></a>定义成员变量</h2><p>[修饰符]    类型    变量名[ = 初始值]；</p><h2 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h2><pre><code>[修饰符]    返回值类型    方法名（形参列表）{    // 各种代码。定义变量、赋值语句、流程控制、输出语句}</code></pre><h2 id="定义构造器"><a href="#定义构造器" class="headerlink" title="定义构造器"></a>定义构造器</h2><pre><code>[修饰符]    构造器名（形参列表）{    // 各种代码。定义变量、赋值语句、流程控制、输出语句}</code></pre><p>构造器，很像一个特殊的方法</p><p>跟方法的两点区别：</p><ol><li>没有返回值类型声明，</li><li>构造器名必须类名相同。</li></ol><p>构造器作用：用于初始化对象——构造器永远属于实例。它不可能用static修饰。</p><h2 id="类可以用来干什么？"><a href="#类可以用来干什么？" class="headerlink" title="类可以用来干什么？"></a>类可以用来干什么？</h2><ol><li>定义变量。所有类都是引用类型。</li><li>调用类变量或类方法。</li><li>创建对象。</li><li>派生子类。</li></ol><h2 id="对象可以用来干什么？"><a href="#对象可以用来干什么？" class="headerlink" title="对象可以用来干什么？"></a>对象可以用来干什么？</h2><ol><li>调用实例变量</li><li>调用实例方法</li></ol><p>调用方法或变量：</p><pre><code>    调用者.方法([参数]);    调用者.实例变量;</code></pre><h2 id="方法详解"><a href="#方法详解" class="headerlink" title="方法详解"></a>方法详解</h2><ul><li>方法所属性。<ul><li>从定义的角度来看，方法不能独立定义，方法必须定义在类里面。</li><li>从调入的角度来看，方法不能独立执行，方法必须有调入者才能执行。<ul><li>类方法：也称静态方法，在方法前加static关键字，就代表这个方法属于这个类本身，不属于它的任何实例。换句话说，这个方法不通过实例进行调用，并且所有实例都共享这一个方法，对方法的调用各个实例相互可见。</li><li>实例方法：一个方法如果不加上static关键字，那么这个方法就是实例方法。意思是它属于类的某个实例，通过这个实例调用它，对类的其他实例不产生影响。</li><li>无论如何，方法都需要调用者，区别在于你在写的时候，要根据方法的类型，是类方法就用类名，是实例方法就用对象去调用它。有些情况下，</li><li>在同一个类里面的一个方法里面调用另一个方法，这个时候会省略前面的调用者。省略也分两种情况，<ul><li>如果被调用的是实例方法，那么省略的就是；</li><li>如果被调用的是类方法，那么省略的就是类名（不是对象哦！）</li></ul></li></ul></li></ul></li></ul><p>我再补充几句哈，免得有人看不懂，上面其实说得就是这么个意思，如果你用的是静态方法（前头加static的那个），那么这边建议你用类名调用，不建议了，强制比较好一点。然后呢，这边又提出了个省略型，静态方法的调用呢，我们甚至可以省略掉类名，直接上咱们的方法。</p><p>如果你使用的是非静态方法（不加static，亦或者叫做实例方法），那么你就必须得创建一个对象，然后用对象来调用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fn1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fn2"</span>);</span><br><span class="line">        Test.fn1();<span class="comment">// 这边也可以直接省略掉Test.，比如说向下边这么写</span></span><br><span class="line">        <span class="comment">//fn1();  // 这就是上面说的，直接省略掉类名，上咱们的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">        t.fn2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>形参个数可变的方法</li><li>递归方法：</li><li>方法重载：2同1不同</li><li>方法的传参机制：值传递，传递的是参数的副本，并不是参数本身</li></ul><h2 id="变量的详解"><a href="#变量的详解" class="headerlink" title="变量的详解"></a>变量的详解</h2><p>成员变量（类里面定义）</p><ul><li>类变量。有static。静态变量</li><li>实例变量。无static。非静态变量</li></ul><p>成员变量，无需由程序员显式指定初始值，系统会为之分配默认初始值；</p><p>初始值规则：与数组元素的初始值规则完全相同</p><ul><li><p>类变量：是在第一次用该类的时候，系统会为该类变量分配空间，并初始化。</p><p>每个类的类变量都只有一个</p></li><li><p>实例变量：每次创建对象，系统都会为该对象的实例变量分配空间，并初始化。</p><pre><code>  程序中有几个对象，系统就会为这些对象的实例变量分配对应的空间。</code></pre></li></ul><p>局部变量（方法里定义）</p><ul><li>形参</li><li>方法里局部变量</li><li>代码块的局部变量</li></ul><p>局部变量</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装、继承、多态——面向对象的3大特征。</p><p>封装包含了两方面的内容</p><ul><li>隐藏：隐藏的内部实现细节。</li><li>暴露：将一些操作界面暴露出来。<br>如果通过暴露的界面来操作对象，该对象的内部状态不会被破坏。</li></ul><p>简而言之：封装要求合理隐藏、合理暴露、</p><ul><li>通过访问控制器实现：</li></ul><p>private -&gt;         不写        -&gt;        protected        -&gt;        public</p><p>private（类访问权限）：该修饰符修饰的成员，只能在该类中被访问。</p><p>不写（包访问权限）：该修饰符修饰的成员，只能在该类及其该类所在包中被访问。</p><p>protected（子类访问权限）：该修饰符修饰的成员，只能在该类、及其该类所在包、该类的子类中被访问。</p><p>public（公共）：该修饰符修饰的成员可以在任意地方被访问。</p><div class="table-container"><table><thead><tr><th></th><th>private</th><th>不写</th><th>protected</th><th>public</th></tr></thead><tbody><tr><td>当前类</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>同一个包</td><td>×</td><td>√</td><td>√</td><td>√</td></tr><tr><td>子类</td><td>×</td><td>×</td><td>√</td><td>√</td></tr><tr><td>任意</td><td>×</td><td>×</td><td>×</td><td>√</td></tr><tr><td></td><td>彻底隐藏</td><td>部分隐藏</td><td>部分暴露</td><td>彻底暴露</td></tr></tbody></table></div><p>指导原则：</p><ol><li>成员变量（实例变量），通常用private修饰，为了隐藏实现细节</li><li>为每个成员变量提供getter、setter方法，用于控制该成员变量</li><li>需要暴露的方法，通常用public修饰</li><li>如果希望一个方法主要用于被子类重写，用protected修饰。</li></ol><ul><li><p>包<br>不同公司完全可以定义同名的类，为解决类名冲突的问题，不同公司不同项目的类名重复的问题。<br>Java就引入了“包”的机制。</p><p>举例理解：同一个班的两个同名的同学，为了区别他们，我们通常 会加一些修饰语，比如说“大江”“小江”<br>这边就是在类名前面添加一个前缀。<br>Java如何为类定义包？</p><ul><li>在源代码中用package包名；</li><li>将生成class文件要放在对应的文件结构下。</li></ul><p>包名的命名规范：语法要求，只要标识符即可</p><pre><code>          专业要求，推荐用公司域名倒写：比如org.fkjava.项目名;就挺好。</code></pre><p>【备注】一旦你为类指定了包名之后，使用该类时应该用完整类名：包名+类名</p></li><li><p>导入包<br>impo的作用：为了省略写包名。</p><pre><code>                    如果不用import，每次用类时都需要使用包名+类名的形式。</code></pre><ul><li>import 包名.类名；——每次导入一个类</li><li>import 包名.* ——导入指定的所有类</li><li>Java程序默认已导入java.lang包下所有包</li></ul></li><li>静态导入 import static<ul><li>import的作用：为了省略写包名。</li><li>import static的作用：可以省略写类名。<pre><code>                                  用于导入指定类的所有静态成员，导入之后，即可省略写类名。</code></pre></li><li>import static 包名.类名.静态成员名; ——每次只导入一个静态成员。</li><li>import static 包名.类名.*;  ——导入指定类的所有静态成员。</li></ul></li><li>Java源程序的结构：<br>一条package语句<br>N条import语句<br>N个class定义</li></ul><h2 id="构造器详解"><a href="#构造器详解" class="headerlink" title="构造器详解"></a>构造器详解</h2><h3 id="构造器规则"><a href="#构造器规则" class="headerlink" title="构造器规则"></a>构造器规则</h3><ol><li>构造器用于初始化对象。</li><li>构造器如何调用？必须用new来调用啦。这样就可以返回一个初始化完成的对象。</li><li>如果你不为一个类提供构造器，那么系统会自动为该类提供一个无参数的构造器</li></ol><h2 id="构造器重载"><a href="#构造器重载" class="headerlink" title="构造器重载"></a>构造器重载</h2><p>一个类中可以定义多个构造器（因此构造器名必然相同），必须要求形参列表不同——这就是构造器的重载</p><p>this调用与this引用</p><p>this引用：this紧跟一个。<br>                    this.name;<br>                    this.walk();</p><p>this调用：this紧跟圆括号。<br>                 this（参数）<br>                    this调用代表调用同一个类中重载的构造器——this调用只能出现在【构造器】的【第一行】</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>封装、继承、多态——面向对象三大特征</p><h3 id="理解继承"><a href="#理解继承" class="headerlink" title="理解继承"></a>理解继承</h3><p>苹果类继承了水果类</p><p>老虎继承了动物类</p><p>东北虎继承了老虎类</p><p>Java的继承：是一种类与类之间关系<br>                        是一种由一般到特殊的关系，子类是一种特殊的父类<br>                        子类实例，完全可以当做父类实例来使用！</p><p>父类（超类、基类、大类，一些别称）；</p><p>子类（派生类、小类：一些别称）。</p><h3 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 类名 extends 父类</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明</p><ul><li>Java是单继承，只能有一个直接父类。</li><li>如果你不显式继承父类，Java默认是继承Object类（JDK系统提供的类）</li></ul><p>子类继承父类，可以得到父类的：</p><ul><li>成员变量</li><li>方法</li></ul><p>继承的好处：【代码复用】     </p><h2 id="方法重写（override）"><a href="#方法重写（override）" class="headerlink" title="方法重写（override）"></a>方法重写（override）</h2><p>当子类发现父类不适合自己时，就要重写父类的方法。</p><p>方法重写口诀</p><ol><li><p>方法名相同、形参列表相同。</p></li><li><p>返回值类型相同或更小， 声明跑出的异常相同或更小</p></li><li><p>访问权限相同或更大（如果父类访问权限是public的话，那么我们重写只能是public，因为public的权限是最大的了）</p><p>@Override：作用是报错。</p><pre><code>                    要求被修饰的方法必须重写父类方法，否则就报错。                比如说如果我们重写的类名写错了，用这个方法可以帮我们发现这个错误，比如我们                    需要重写的类名是fly()，而我们写成了f1y()。</code></pre></li></ol><p>Java找变量先就近，</p><h2 id="super限定"><a href="#super限定" class="headerlink" title="super限定"></a>super限定</h2><p>与前面this引用非常相似，super用于限定访问父类定义的实例变量或实例方法</p><p>super.父类定义的实例变量</p><p>super.父类定义的实例方法(参数)</p><h2 id="子类构造器调用父类的构造器"><a href="#子类构造器调用父类的构造器" class="headerlink" title="子类构造器调用父类的构造器"></a>子类构造器调用父类的构造器</h2><p><strong>子类构造器【一定调用】父类构造器【一次】——有且仅有一次。</strong></p><ol><li><p>如果子类构造器没有显式调用父类构造器，那么系统会自动在子类构造器的第一行先调用父类无参数的构造器</p></li><li><p>子类构造器的第一行显式使用super来调用父类构造器<br>super调用一定是调用的父类的构造器。只能出现在构造器的第一行。<br>this调用是调用当前类的构造器。只能出现在构造器的第一行<br>【很明显，super调用和this调用不可能同时出现。】</p><p>super限定：super紧跟一个   <strong>.</strong></p><pre><code>                  super.name;                  super.walk();</code></pre><p>super调用：super后边紧跟括号。</p><pre><code>                  super(参数);</code></pre></li></ol><p>【备注】：如果父类没有无参数的构造器，子类的构造器必须显式调用父类指定的构造器。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>我再回顾一下345</p><p>3种类型：类、接口、枚举。<br>4个修饰符：private|protected|public、final、static、abstract<br>5大成员：成员变量、方法、构造器、初始化块、内部类</p><p>多态的意义：<br>我们先吹一吹<strong>变态</strong>的概念：from 百度百科</p><ul><li>心理、行为上异于常人而且呈现病态。</li><li>经常做出正常人无法理解事情或违背常理行为的人。</li><li>能做出令人厌恶、反常的举动。</li><li>精神病或者神经不正常。</li></ul><p>很明显，这个的意思是，在寻常的正常的一群人或者正常的成长路线中，个别人（对象）呈现出变异的行为特征——这个就是变态的定义</p><p>再说一说<strong>拟态</strong>：动物为了生存下来，变成令人害怕的样子，吓唬别人</p><p><strong>多态</strong>：同一个类型的多个实例、在执行同一个方法，呈现出多种的行为特征——这就叫做“多态”</p><p>举个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 多态 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bird b1 = <span class="keyword">new</span> Sparrow();<span class="comment">// 这边需要注意的是，我的Sparrow类里边是没有fly方法的</span></span><br><span class="line"></span><br><span class="line">        Bird b2 = <span class="keyword">new</span> Ostrich();<span class="comment">// 这边需要注意的是，我的Ostrich类里边是有fly方法的</span></span><br><span class="line"></span><br><span class="line">        b1.fly();<span class="comment">// 当我的b1动态绑定类的fly方法的时候，发现我的Sparrow类里边没有fly方法，于是我的b1就开始寻找父类了，父类Bird里边果然有，所以我输出了“鸟在天上飞”</span></span><br><span class="line"></span><br><span class="line">        b2.fly();<span class="comment">// 当我的b2动态绑定类的fly方法的时候，发现我的Ostrich类里边是有fly方法的，于是我就输出了“鸵鸟当然只能跑啦！”这句话</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我相信上面的例子肯定能够助大家理解什么是多态</span></span><br><span class="line">        <span class="comment">// 相同类型的实例，在执行同一个方法的时候，呈现出多个行为特征。这就叫多态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bird类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name = <span class="string">"鸟"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鸟在天上飞"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sparrow类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ostrich类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ostrich</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鸵鸟当然只能跑啦！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向上转型：子类对象可以直接赋值给父类变量。"><a href="#向上转型：子类对象可以直接赋值给父类变量。" class="headerlink" title="向上转型：子类对象可以直接赋值给父类变量。"></a>向上转型：子类对象可以直接赋值给父类变量。</h3><h3 id="向下转型：父类变量赋值给子类变量。"><a href="#向下转型：父类变量赋值给子类变量。" class="headerlink" title="向下转型：父类变量赋值给子类变量。"></a>向下转型：父类变量赋值给子类变量。</h3><p>强制转换。<br>（类型）变量名。</p><h3 id="为什么会有多态呢？"><a href="#为什么会有多态呢？" class="headerlink" title="为什么会有多态呢？"></a>为什么会有多态呢？</h3><p>当我们的Java执行方法时，方法的执行是 动态绑定的。方法总是执行该变量实际所指向对象的方法。</p><h3 id="变量的类型（这边再讲一个概念）"><a href="#变量的类型（这边再讲一个概念）" class="headerlink" title="变量的类型（这边再讲一个概念）"></a>变量的类型（这边再讲一个概念）</h3><p>编译时的类型：声明该变量时指定的类型。<br>                           在Java程序的编译阶段，Java编译器只认编译时的类型。</p><p>运行时的类型（实际类型）：该变量实际所引用的对象的类型。</p><h3 id="强制转换运算符的注意点："><a href="#强制转换运算符的注意点：" class="headerlink" title="强制转换运算符的注意点："></a>强制转换运算符的注意点：</h3><ol><li><p>强制转换运算符只能在具有编译类型具有父子关系的变量之间进行转换。否则编译错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"在平面上绘制图形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> <span class="keyword">extends</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是一个矩形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">round</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"绕着圆形走一圈"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 多态2 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// s1编译类型是Shape，实际类型是Rect</span></span><br><span class="line">        Shape s1 = <span class="keyword">new</span> Rect();</span><br><span class="line">        s1.draw();</span><br><span class="line"><span class="comment">//        s1.info();// 无法调用，找不到info方法，因为，Java在编译的时候，只认编译类型。对于Java编译器来说，s1是Shape类型</span></span><br><span class="line">        <span class="comment">// 实际上是可以允许的，s1是有这个方法的，是可以运行的，只是编译不能通过</span></span><br><span class="line">        Shape s2 = <span class="keyword">new</span> Circle();</span><br><span class="line">        <span class="comment">// 对于编译器而言，s2是Shape类型，Shape没有round方法</span></span><br><span class="line"><span class="comment">//        s2.round();// 无法运行，同上理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// s2编译类型是Shape，c要求是Circle，Shape无法转换为Circle。，这个时候要用强制转换</span></span><br><span class="line"><span class="comment">//        Circle c = s2;</span></span><br><span class="line">        <span class="comment">// 解决上面的方法是强制转换。</span></span><br><span class="line">        Circle c = (Circle)s2;</span><br><span class="line">        c.round();</span><br><span class="line"></span><br><span class="line">        Circle c2 = (Circle)s1;<span class="comment">// 类型转换异常，s1指向的是Rect，强制转换只能是本来指向要转换的类才能进行转换</span></span><br><span class="line">        <span class="comment">// 比如这边的s2本来就是指向Circle的，于是可以转换</span></span><br><span class="line">        <span class="comment">// 这边的s1本来是指向Rect，所以不能转换</span></span><br><span class="line">        c2.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子加以说明</p></li><li><p>如果在编译类型具有继承关系的变量之间转换，如果被转变量的实际类型，不是要转的目标类型，那么程序就会引发ClassCastException（类型转换异常）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 强转2 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object str1 = <span class="string">"Mr8god"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 强转</span></span><br><span class="line"></span><br><span class="line">        String str = <span class="string">"Mr8god"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Integer it = (Integer) str;// 会报不兼容的错误，因为String跟Integer没有继承关系，所以编译就会报错，报不兼容的类型</span></span><br><span class="line">        Integer it = (Integer) str1;<span class="comment">// 这边Object与Integer之间有继承关系，所以编译能通过，但是运行会出现异常。</span></span><br><span class="line">        <span class="comment">// 编译器要求：必须在编译类型具有继承关系才能强转</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上头还是我写的一个小栗子；</p></li></ol><h3 id="instanceof运算符（为了避免ClassCastException异常）："><a href="#instanceof运算符（为了避免ClassCastException异常）：" class="headerlink" title="instanceof运算符（为了避免ClassCastException异常）："></a>instanceof运算符（为了避免ClassCastException异常）：</h3><p>为了避免ClassCastException异常，Java就增加了这个运算符。</p><p>变量名 instanceof 类型 —— 当前面的变量所引用对象是后面类或者子类的实例时，该运算符返回true。</p><p>instanceof 只能在编译类型具有继承关系之间进行判断，否则编译报错：不兼容的类型。</p><p>所以我们以后在强制转换之前，都要做到先判断再转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 强转2 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object str1 = <span class="string">"Mr8god"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 强转</span></span><br><span class="line"></span><br><span class="line">        String str = <span class="string">"Mr8god"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Integer it = (Integer) str;// 会报不兼容的错误，因为String跟Integer没有继承关系，所以编译就会报错，报不兼容的类型</span></span><br><span class="line"><span class="comment">//        Integer it = (Integer) str1;// 这边Object与Integer之间有继承关系，所以编译能通过，但是运行会出现异常。</span></span><br><span class="line">        <span class="comment">// 编译器要求：必须在编译类型具有继承关系才能强转</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (str1 <span class="keyword">instanceof</span> Integer)</span><br><span class="line">        &#123;</span><br><span class="line">            Integer it = (Integer)str1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有在编译类型具有继承关系才能进行判断，否则编译报错，下面的例子又是一个不兼容的问题，String无法转换为Integer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 强转2 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String s = <span class="string">"Mr8god"</span>;</span><br><span class="line"><span class="comment">//        System.out.println(s instanceof Integer);//是不能运行的，因为String无法转换为Integer。。。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h2><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[修饰符]&#123;</span><br><span class="line"></span><br><span class="line">​各种语句</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化块是没有名字的，<br>修饰符只能出现一个：static。</p><ul><li>有static的叫做类初始化块（静态初始化块）；</li><li>无static的叫做实例初始化块（非静态初始化块）；</li></ul><p>初始化块代码小栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">happy1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">2</span>;<span class="comment">// 成员变量-&gt; 实例变量</span></span><br><span class="line"><span class="comment">//    String name;</span></span><br><span class="line"><span class="comment">//    name = "Mr8god";</span></span><br><span class="line">    <span class="comment">//赋值语句不能放在类里边，赋值语句放在方法中</span></span><br><span class="line">    </span><br><span class="line">    String name ;</span><br><span class="line">    &#123;name = <span class="string">"Mr8god"</span>;&#125;<span class="comment">// 这样就变成初始化块了，就可以写了。这个东西叫做代码块中的初始化块（一种特例）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化块分成两种："><a href="#初始化块分成两种：" class="headerlink" title="初始化块分成两种："></a>初始化块分成两种：</h3><h4 id="实例初始化块（无static）"><a href="#实例初始化块（无static）" class="headerlink" title="实例初始化块（无static）"></a>实例初始化块（无static）</h4><p>实例初始化块其实是一种“假象”，一个类在编译之后，实例初始化块就会消失。</p><p>实力初始化块的所有代码会被还原到每个构造器的开始部分。<br>举个代码小栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitTest</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Mr8god"</span>);<span class="comment">// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面有两个构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InitTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一个无参构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InitTest</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"带String参数的构造器， 参数为："</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译之后，上面所以代码会变成下面的样子，下面的代码就是上面的本质。</span></span><br><span class="line"><span class="comment">//    public InitTest()</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("Mr8god");// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println("这是一个无参构造器");</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    public InitTest(String name)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("Mr8god");// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println("带String参数的构造器， 参数为：" + name);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边介绍一个命令javap -c 用于分析Java 的class文件<br><img src="https://i.loli.net/2020/04/07/mH9yhbtZ7dSeiwJ.jpg" alt="javap之后的真相.jpg"></p><p>经过反编译，得到具体代码运行过程后，我们发现事实确实是这样的哈。</p><p>这边再附上一个代码调用上面的类，以方便以后复现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Init in = <span class="keyword">new</span> Init();</span><br><span class="line"></span><br><span class="line">        Init in2 = <span class="keyword">new</span> Init(<span class="string">"江某人来了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实例初始化块的作用："><a href="#实例初始化块的作用：" class="headerlink" title="实例初始化块的作用："></a>实例初始化块的作用：</h5><ol><li>类似于C++中的全局变量，只需要维护一个地方就够了，不需要到每个构造器里操作。</li><li>将多个构造器前面部分相同的代码可以提取到实例初始化块中！</li></ol><h5 id="实例初始化块何时执行呢？"><a href="#实例初始化块何时执行呢？" class="headerlink" title="实例初始化块何时执行呢？"></a>实例初始化块何时执行呢？</h5><p>只要程序调用构造器创建对象，程序总会先执行实例初始化块——因为实例初始化块被还原到每个构造器的所有代码之前。</p><h5 id="定义实例变量"><a href="#定义实例变量" class="headerlink" title="定义实例变量"></a>定义实例变量</h5><p>当我的init类是这个时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Init</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Mr8god"</span>);<span class="comment">// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 下面有两个构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一个无参构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Init</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"带String参数的构造器， 参数为："</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initTest是这个时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Init in = <span class="keyword">new</span> Init();</span><br><span class="line"></span><br><span class="line">        Init in2 = <span class="keyword">new</span> Init(<span class="string">"江某人来了"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(in2.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果并不是如我刚开始想象的那样是20，因为我以为初始化的20 ，是分散到两个方法里去了，那么引用的话，应该是20呀。结果却是2。</p><p><strong>定义实例变量时指定的初始值，也是“假象” 。</strong></p><p><strong>——指定初始值，编译之后就变成构造器所有代码之前一条赋值语句！</strong></p><p>这里边的int age = 2，本质上是int age ;我们可以通过反编译工具看到</p><p><img src="https://i.loli.net/2020/04/07/5jsBlRHOqDAVC2Z.jpg" alt="age没有赋值.jpg"></p><p>所以我上面的Init类现在实际上已经变成了这个样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Init</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 下面有两个构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mr8god"</span>);<span class="comment">// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">        age = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">"这是一个无参构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Init</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mr8god"</span>);<span class="comment">// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">        age = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">"带String参数的构造器， 参数为："</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么很明显，最近一次的赋值age是2。所以会出现问题，不是我想象中的20，也是理所应当了</p><p>这里边大费周章又是比较代码又是反编译的，其实主要是为了说明一点</p><p>即使我们的赋值语句不在代码块中，编译之后，也是会一起到构造语句中的。over</p><p>也就是说，如果我把int age = 2;放在类中的首行，也就是public Init()的上一行，我们得出的结果就会是20了，只是一个age赋值先后顺序的关系。</p><h5 id="总结总结总结"><a href="#总结总结总结" class="headerlink" title="总结总结总结"></a>总结总结总结</h5><p>实例初始化块的语句要还原到构造器的所有代码之前；定义变量指定的初始值，也要还原到构造器的所有代码之前；那么这两者的先后顺序呢？按照它们在源代码中的顺序。</p><h4 id="类初始化块（有static）"><a href="#类初始化块（有static）" class="headerlink" title="类初始化块（有static）"></a>类初始化块（有static）</h4><p>类初始化块——负责对类执行初始化。<br>                            当程序<strong>第一次主动</strong>使用该类时，系统会为该类分配内存空间、并执行初始化（调用类初始化块）</p><h5 id="对-第一次主动-概念做解释："><a href="#对-第一次主动-概念做解释：" class="headerlink" title="对 第一次主动 概念做解释："></a>对 <strong>第一次主动</strong> 概念做解释：</h5><p>除了用类去声明变量，其他只要你使用该类，都算是第一次主动使用该类。可以从Java编译器的角度去理解</p><h5 id="类初始化块何时执行"><a href="#类初始化块何时执行" class="headerlink" title="类初始化块何时执行"></a>类初始化块何时执行</h5><p>程序第一次【主动】使用该类时，会执行该类的类初始化块。<br>程序运行时，该类初始化块只会执行一次！</p><div class="table-container"><table><thead><tr><th></th><th>执行次数</th><th>执行先后</th><th>何时执行</th></tr></thead><tbody><tr><td>类初始化块</td><td>1次·</td><td>先</td><td>第一次主动用该类</td></tr><tr><td>实例初始化块</td><td>N次</td><td>后</td><td>每次调用构造器</td></tr></tbody></table></div><p><strong>定义实例变量时指定的初始值，也是“假象” 。</strong></p><p><strong>——指定初始值，编译之后就变成类初始化中的一条赋值语句！但到底是在类初始化块的代码之前，还是代码之后呢，取决于它在源代码中的顺序。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInit</span> </span>&#123;</span><br><span class="line"><span class="comment">//    static int age = 30;</span></span><br><span class="line"><span class="comment">//    // 类初始化块</span></span><br><span class="line"><span class="comment">//    static &#123;</span></span><br><span class="line"><span class="comment">//        age = 300;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上面代码的本质，如下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 类初始化块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        age = <span class="number">30</span>;</span><br><span class="line">        age = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="大一统"><a href="#大一统" class="headerlink" title="大一统"></a>大一统</h4><p>先上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base11</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Base11 的类初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Base11 的实例始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base11</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Base11 无参数构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base11</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Base11 的（String）参数构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mid</span> <span class="keyword">extends</span> <span class="title">Base11</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Mid 的类初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Mid 的实例初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">(<span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        System.out.println(<span class="string">"Mid 的(int)构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"Mr8god"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Mid 的无参数构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub1</span> <span class="keyword">extends</span> <span class="title">Mid</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Sub 的类初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Sub 的实例初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sub1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sub 的无参数构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sub1</span><span class="params">(<span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        System.out.println(<span class="string">"Sub 的（double）构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Sub1(<span class="number">3.4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【结论】：初始化任何类之前，一定先从Object开始初始化，依次初始化它所有祖先类，最后才到它自己；创建任何对象的时候，一定是从Object构造器开始执行，执行它所有祖先类的构造器，最后才执行它自己的构造器！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java面向对象基础回顾&quot;&gt;&lt;a href=&quot;#Java面向对象基础回顾&quot; class=&quot;headerlink&quot; title=&quot;Java面向对象基础回顾&quot;&gt;&lt;/a&gt;Java面向对象基础回顾&lt;/h1&gt;&lt;p&gt;定义类、创建对象、调用方法&lt;/p&gt;
&lt;h2 id=&quot;定义类&quot;
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java内存</title>
    <link href="https://mr8god.cn/2020/04/04/Java/%E6%B5%85%E8%B0%88Java%E5%86%85%E5%AD%98/"/>
    <id>https://mr8god.cn/2020/04/04/Java/%E6%B5%85%E8%B0%88Java%E5%86%85%E5%AD%98/</id>
    <published>2020-04-04T15:31:53.815Z</published>
    <updated>2020-04-04T15:39:20.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅谈Java内存"><a href="#浅谈Java内存" class="headerlink" title="浅谈Java内存"></a>浅谈Java内存</h1><h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><p><img src="https://i.loli.net/2020/04/04/RMaGdC8hxOqc9SY.jpg" alt="Java虚拟机运行时数据区.jpg"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a><strong>程序计数器</strong></h3><ol><li>作用：当前线程所执行的字节码的行号指示器。</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li>存在的意义：Java虚拟机的多线程是通过线程轮流切换实现的，类似于操作系统的时间片算法来分配核心（处理器）的执行时间。所以，为了线程每一次切换后能够恢复到之前正确的执行位置，每个线程就需要各自独立的程序计数器。</li><li>如果线程此时正在执行的是一个Java方法，计数器记录的即是正在执行的虚拟机字节码指令的地址；如果正在执行的是Nativie方法，这个计数器即是空（Undefined）。</li></ol><h3 id="Java虚拟机栈（就是大家常说的栈内存）"><a href="#Java虚拟机栈（就是大家常说的栈内存）" class="headerlink" title="Java虚拟机栈（就是大家常说的栈内存）"></a><strong>Java虚拟机栈</strong>（就是大家常说的栈内存）</h3><p>虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个<strong>栈帧</strong>，用于存储局部变量表、操作栈、动态链接、方法出口等信息。</p><p>每一个方法被调用直至执行完成的过程，就对应着一个<strong>栈帧</strong>在虚拟机栈中从入栈到出栈的过程。</p><p>大部分程序员把Java的内存区域划分为堆内存（Heap）和栈内存（Stack），事实上Java内存区域的划分远比这复杂。其中所指的“堆”在后边会聊到，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变量表部分。</p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>局部变量表存放了编译期可知的8种基本数据类型（int、char、byte、short、long、double、boolean、float）、对象引用和returnAddress类型</p><p>这边插一句关于对象引用类型的分析解释：字如其意，是一种引用，就是C中的指针嘛，我们来看一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>=左边的arr是变量部分，=右边的是一个对象。</p><p>右边只是一个指向对象起始地址的引用指针。</p><p>左边的arr是变量，所以被存放在栈内存中。右边的是对象， 所以被存放在堆内存中，两者靠指针来维系关系。上面这句话应该这么来理解。</p><p>continue！继续聊局部变量表，8种基本数据类型里64位长度的long和double类型的数据会占用2个局部变量空间，其余的数据类型只占用1个。</p><p>局部变量表所需的内存空间在编译期间就完成了分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是早就确定好的，而且我们在方法运行期间不会改变 局部变量表的大小。</p><p>continue！继续聊虚拟机栈，我们聊报错</p><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p>有两种：</p><ol><li>StackOverflowError异常：如果线程请求的栈深度大于虚拟机所允许的深度</li><li>OutOfMemoryError异常：当我们使用的虚拟机栈的内存不够时就会出现这个报错</li></ol><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>与虚拟机栈作用相似 ，区别在于虚拟机栈是为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用的Native方法服务。</p><p>甚至于有的虚拟机（比如Sun HotSpot虚拟机）直接将本地方法栈和虚拟机栈合二为一。</p><p>与虚拟机栈一样，本地方法栈区域也会抛出两种报错StackOverflowError和OutOfMemoryError。</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>是Java虚拟机所管理的内存中最大的一块。在虚拟机启动时就被创建了。</p><p>唯一目的就是存放对象实例，只要我们new的对象实例都在这边分配了内存。</p><p>Java对可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。</p><p>当前主流的虚拟机都是按照可扩展来实现的（通过 -Xmx：最大多少内存空间，-Xms：最小多少内存空间   来控制）</p><p>如果堆中内存不够的话，将会抛出OutOfMemoryError异常，我称之为爆内存，并且在下面给出爆内存的具体例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 爆内存 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> it = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">long</span>[] arr = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">100</span>];</span><br><span class="line">        arr[<span class="number">99</span>] = <span class="number">33</span>;</span><br><span class="line">        System.out.println(arr[<span class="number">99</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//教你如何爆内存哈，在终端输入Java -Xmx256 爆内存</span></span><br></pre></td></tr></table></figure><p>当然爆内存知识OutOfMemoryError异常三种情况中的一种，之后我也会仔细围绕这个好好讲讲，<a href="https://blog.csdn.net/z453588/article/details/83743837，可以先看看这个博客解解馋" target="_blank" rel="noopener">https://blog.csdn.net/z453588/article/details/83743837，可以先看看这个博客解解馋</a></p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>与Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>可以和Java堆一样不需要连续的内存 和可以选择固定大小或者可扩展外</p><p>还可以选择不识闲垃圾回收。相对而言，垃圾收集行为在这个区域很少见。但是并非是说数据进入方法区就永久存在了。</p><p>这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>是方法区的一部分。</p><p>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池相对于Class文件常量池的另外一个重要特征就是<strong>具备动态性</strong>。</p><p>动态性：Java语言并不要求常量一定只能在编译期产生，运行期间也可能将新的常量放入池中。这种特性被开发人员用的较多的就是String类的intern()方法。</p><p>既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当无法再申请到内存时会抛出OutOfMemoryError异常。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</p><p>JDK1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用来进行操作。这样在一些场景中能显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><p>既然是直接内存，那么这一部分内存是不会受到Java堆大小的限制的咯，</p><p>但是既然是内存，则肯定还是会受到本机总共内存的大小和处理器寻址空间的限制。</p><p>服务器管理员配置虚拟机参数时，一般会根据实际内存设置 -Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制（包括物理上的限制和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。</p><h3 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h3><p>上面都是从Java虚拟机的运行时数据区来讨论的，这边在讨论一个话题：对象访问是如何进行的呢？</p><p>对象访问是Java中的常客，即使是最简答的访问，也会涉及到Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系。举个例子说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>等号左边的一部分会被保存在Java栈的本地变量表里，我之前也有所涉及，作为一个reference类型数据出现，一个引用类型嘛。</p><p>而右边的部分会被存储到Java堆中去。形成一块连在一起的结构化内存（类似于数组一样的结构）</p><p>另外在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。</p><h4 id="对象访问的两种方法：使用句柄和直接指针"><a href="#对象访问的两种方法：使用句柄和直接指针" class="headerlink" title="对象访问的两种方法：使用句柄和直接指针"></a>对象访问的两种方法：使用句柄和直接指针</h4><p>如果<strong>使用句柄访问方式</strong>，Java堆中将会划分出一块内存来作为句柄池，栈内存中存储的就是<strong>对象的句柄地址</strong>，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。</p><p><img src="https://i.loli.net/2020/04/04/a8p6zHbD1cl9NEF.jpg" alt="通过句柄访问对象.jpg"></p><p>如果使用<strong>直接指针访问方式</strong>，Java堆对象的布局就必须要考虑如何放置访问类型数据的相关信息，栈内存中直接存储的就是<strong>对象地址</strong></p><p><img src="https://i.loli.net/2020/04/04/9FjKNb6Xy3zU2tx.jpg" alt="通过直接指针访问对象.jpg"></p><p>各有优势：</p><p>使用句柄访问方式的最大好处就是堆内存中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针就行了。</p><p>使用直接指针访问方式的最大好处是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此此类开销积少成多后会非常可观。</p><h2 id="各种异常实战"><a href="#各种异常实战" class="headerlink" title="各种异常实战"></a>各种异常实战</h2><p>明儿个再补充</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浅谈Java内存&quot;&gt;&lt;a href=&quot;#浅谈Java内存&quot; class=&quot;headerlink&quot; title=&quot;浅谈Java内存&quot;&gt;&lt;/a&gt;浅谈Java内存&lt;/h1&gt;&lt;h2 id=&quot;Java内存区域&quot;&gt;&lt;a href=&quot;#Java内存区域&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>你所不知道的函数小知识——结构体与函数</title>
    <link href="https://mr8god.cn/2020/04/03/C++/%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%87%BD%E6%95%B0%E5%B0%8F%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E5%87%BD%E6%95%B0/"/>
    <id>https://mr8god.cn/2020/04/03/C++/%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%87%BD%E6%95%B0%E5%B0%8F%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E5%87%BD%E6%95%B0/</id>
    <published>2020-04-03T15:33:37.914Z</published>
    <updated>2020-04-03T15:32:58.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构体与函数之间的那点儿事"><a href="#结构体与函数之间的那点儿事" class="headerlink" title="结构体与函数之间的那点儿事"></a>结构体与函数之间的那点儿事</h1><p>正如标题哈，本篇博文讲的就是结构体和函数。不是新手向的教程哈，更多的这是一篇记录经验的文章。话不多说，开始咯！</p><p>我们将注意力从之前的数组转到结构上面。为结构写函数可比为数组写函数要简单得多了。虽然结构变量和数组一样，都可以存储多个数据项。但是在涉及到函数的时候，结构变量的行为更接近与基本的单值变量。这个名词可能太专业了哈。我做一下解释，还是拿数组来做比较，数组中都是一个元素为单位存储的，在结构中，相应的便是将数据组合成一个实体，实体就是数据，数据就是实体。<strong>实体（结构）==元素（数组）</strong>。</p><p>这边实现传值的思想主要是利用了<strong>一个结构可以赋给另外一个结构</strong>这样子的常识知识。就像普通变量一样。我需要额外补充的是，函数将使用原始结构的副本。</p><p>函数也可以返回结构 。这边与<strong>使用数组名就是代表了数组第一个元素的地址</strong>这样的观点不同的是，结构名只是结构的名称，<strong>要获得结构的地址，必须使用地址运算符&amp;</strong>。</p><p>咱们传递结构体的基本方法就是<strong>按值传递</strong>（圈起来，要考！）但是C++作为一门精细的语言，细节到每一个内存都要深挖，不能忍受这种方法的一个缺点：<strong>如果结构非常大的话，复制结构将增加内存要求，降低系统运行的速度。</strong>出于这种原因，我们更愿意的是采取<strong>按地址传递</strong>（没错，又是“该死”的指针，所以说C++指针一定要学好！）。然后使用指针来访问结构的内容。</p><h2 id="首先介绍“按值传递”"><a href="#首先介绍“按值传递”" class="headerlink" title="首先介绍“按值传递”"></a>首先介绍“按值传递”</h2><p>当结构比较小时，按值传递最舒服了用起来。接下来举的例子来源于《C++ Primer Plus（第六版）》</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从a到b城需要3小时50分钟，而从b到g城需要1小时25分钟，对于这种时间，可以使用结构来表示——一个成员表示小时值，另一个成员表示分钟值，将两个时间加起来需要一些技巧，因为可能需要将分钟值转换为小时。例如前面列出的两个时间的总和为4小时75分钟，应将它转化为5小时15分钟，下面开发用于表示时间值的结构，然后再开发一个函数，它接受两个这样的结构为参数并返回表示参数的和的结构。</span><br></pre></td></tr></table></figure><p>突出介绍一下结构函数的写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">travel_time</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> hours;</span><br><span class="line">    <span class="keyword">int</span> mins;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在已经定义好时间的结构的前提下，开始声明结构函数</span></span><br><span class="line"></span><br><span class="line"><span class="function">travel_time <span class="title">sum</span><span class="params">(travel_time t1, travel_time t2)</span></span>;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">travel_time</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> hours;</span><br><span class="line">    <span class="keyword">int</span> mins;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mins_per_hr = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">travel_time <span class="title">sum</span><span class="params">(travel_time t1, travel_time t2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_time</span><span class="params">(travel_time t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    travel_time day1 = &#123;<span class="number">5</span>, <span class="number">45</span>&#125;;</span><br><span class="line">    travel_time day2 = &#123;<span class="number">4</span>, <span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line">    travel_time trip = sum(day1, day2);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Two-day total: "</span>;</span><br><span class="line">    show_time(trip);</span><br><span class="line"></span><br><span class="line">    travel_time day3 = &#123;<span class="number">4</span>, <span class="number">32</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Three-day total: "</span>;</span><br><span class="line">    show_time(sum(trip, day3));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">travel_time <span class="title">sum</span><span class="params">(travel_time t1, travel_time t2)</span></span>&#123;</span><br><span class="line">    travel_time total;</span><br><span class="line"></span><br><span class="line">    total.mins = (t1.mins + t2.mins) % Mins_per_hr;</span><br><span class="line">    total.hours = t1.hours + t2.hours + (t1.mins + t2.mins) / Mins_per_hr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_time</span><span class="params">(travel_time t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t.hours &lt;&lt; <span class="string">" hours, "</span> &lt;&lt; t.mins &lt;&lt; <span class="string">" minutes\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><p>travel_time 就像是一个标准的类型名，可以用来声明变量、函数的返回类型和函数的参数类型。</p><p>然后试travel_time结构的变量total 和t1，使用成员运算符进行数据的操作。代码很简单，可以看得懂。</p><h2 id="然后介绍“按地址传递”"><a href="#然后介绍“按地址传递”" class="headerlink" title="然后介绍“按地址传递”"></a>然后介绍“按地址传递”</h2><p>这一次我换了个题目，题目的内容我简要地说一下哈：通常我们表示一件物品的位置的时候，都是采取选择参照系利用直角坐标系或者极坐标系进行精确表示的，这边写了一个程序用于两种坐标系之间的转换。就是这样。</p><p>由于和上面的代码极其类似，所以我认为看看例子就能理解欧，就不做解析了。over</p><p>这个代码有一个小东西讲讲熬，就是while里边的cin&gt;&gt; 的用法，cin的特性是可以输入int整型数，但是一旦发现你输入的不是数字的时候，他就会不满足条件，变为0，然后while就会跳出循环，蛮好用的小技巧，推荐学习！</p><p>代码奉上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">polar</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> distance;</span><br><span class="line">    <span class="keyword">double</span> angle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rect</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rect_to_polar</span><span class="params">(<span class="keyword">const</span> <span class="built_in">rect</span> * pxy, polar * pda)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_polar</span><span class="params">(<span class="keyword">const</span> polar * pda)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">rect</span> rplace;</span><br><span class="line">    polar pplace;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter the x and y values: "</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; rplace.x &gt;&gt; rplace.y)&#123;</span><br><span class="line">        rect_to_polar(&amp;rplace, &amp;pplace);</span><br><span class="line">        show_polar(&amp;pplace);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Next two numbers (q to quit): "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Done.\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rect_to_polar</span><span class="params">(<span class="keyword">const</span> <span class="built_in">rect</span> * pxy, polar * pda)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    pda-&gt;distance = <span class="built_in">sqrt</span>(pxy-&gt;x * pxy-&gt;x + pxy-&gt;y * pxy-&gt;y);</span><br><span class="line">    pda-&gt;angle = <span class="built_in">atan2</span>(pxy-&gt;y, pxy-&gt;x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_polar</span><span class="params">(<span class="keyword">const</span> polar * pda)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> Rad_to_deg = <span class="number">57.29577951</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"distance = "</span> &lt;&lt; pda-&gt;distance;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">", angle = "</span> &lt;&lt; pda-&gt;angle * Rad_to_deg;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" degrees\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;结构体与函数之间的那点儿事&quot;&gt;&lt;a href=&quot;#结构体与函数之间的那点儿事&quot; class=&quot;headerlink&quot; title=&quot;结构体与函数之间的那点儿事&quot;&gt;&lt;/a&gt;结构体与函数之间的那点儿事&lt;/h1&gt;&lt;p&gt;正如标题哈，本篇博文讲的就是结构体和函数。不是新手向
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="C++" scheme="https://mr8god.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++函数中的指针应用</title>
    <link href="https://mr8god.cn/2020/04/02/C++/C++%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E5%BA%94%E7%94%A8/"/>
    <id>https://mr8god.cn/2020/04/02/C++/C++%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E5%BA%94%E7%94%A8/</id>
    <published>2020-04-02T08:00:25.063Z</published>
    <updated>2020-04-02T07:59:50.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数与数组"><a href="#函数与数组" class="headerlink" title="函数与数组"></a>函数与数组</h1><p>虽然我上面开了两篇博客准备一锅把函数端掉，但是当我想到数组哈，我觉得还是有必要对它好好搞一番。为什么呢？因为当我们在形参中放一个数组时，要开始注意了昂，这个数组是按照数组基本的操作传递值的，它是以指针的方式运转的！！！一提到指针哈，就得好好琢磨琢磨了，毕竟我江某人如今的观点是C++最重要的有两个：指针和STL库。</p><p>要我说，之前讲的两章，着实是对函数基础知识的总结。而我们日常使用中，是不会这么简单的。比如说我们企业中要计算某个项目中每个用户所购买的东西之和。我们很容易想到每个数组可以索引指向一个顾客，要计算总共有多少个东西被买掉了，我们可以使用循环来计算出总和。这不是不可以哈。但是呢，我们其实可以用一个函数来实现它。我们可以在声明函数时，放入一个数组形状的形参，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">( <span class="keyword">int</span> arr[], <span class="keyword">int</span> a)</span></span></span><br></pre></td></tr></table></figure><p>很明显，这里边arr就是咱们即将要传递的数组，[]里边是空的，说明我们待会要传递的数组的长度是需要额外设置的。但是我再强调一点哈，这个arr实际上并不是数组，而是一个指针！但是呢，我们在编写函数的时候，是可以将arr看做是数组的。</p><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p>下面是我写的一个小example</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ArSize = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">int</span> counts[ArSize] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>,<span class="number">128</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = sums(counts, ArSize);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Total counts: "</span> &lt;&lt; sum &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        total = total + arr[i];</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我来详细讲一讲哈，其实我们当初在学习数组的时候就知道，数组名是可以当做指针来用的，数组名指向该数组的第一个元素的地址。但是呢，这边在函数中讨论数组和指针的话。我得把需要注意的几个点额外说一哈</p><ol><li>数组声明使用数组名来表示存储位置</li><li>对数组使用sizeof得到的是整个数组的长度，举个例子哈，int aaa[8]，int是4个字节，对这个数组使用sizeof的话，我们得到的长度为32位字节</li><li>如果我们使用取地址符&amp;的话，我们得到的也会是一个长度为32字节的内存块的地址。</li></ol><p>arr是咱们的数组名，根据C++规则，arr指代的是第一个元素的地址。 所以咱们的函数传递的也是地址哈。元素的类型是int，那么咱们的指针也应该是int类型的。因此，我们可以使用int *来表示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = sums(<span class="keyword">int</span> * arr, <span class="keyword">int</span> n)</span><br></pre></td></tr></table></figure><p>易知，int * arr 替换了int arr[]，这两个的含义是相同的。</p><p>但是呢，其实这两种表达方法也是有区别的，</p><p>数组表达式（int arr[])提醒咱们的程序员，arr不仅指向int，还指向了int数组的第一个int。当指针指向数组的第一个元素时，本书使用了数组表达法；</p><p>指针表达式可以用在当我们指针指向一个独立的值，而不是第一个值的时候。</p><p>！！！要记住只有在这边是可以的等价的，在其他地方都是不等价的哦。例如我们不能再函数体中将两者相替换。</p><p>经过我们的挖掘后，知道了arr数组名实际上是一个指针的事实后，我们也可以 用方括号数组表示法来访问数组元素。无论arr是指针还是数组名，表达式arr[3]都指的是数组的第4 个元素。</p><p>这边总结出两个式子，希望能记住：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr[i] == *(ar + i)</span><br><span class="line">&amp;arr[i] == ar + i</span><br></pre></td></tr></table></figure><p>在强调一点，指针加一的意义，指的是加上一个与指针指向的类型的长度。例如上文中的32字节内存块。对于遍历数组而言，使用指针加法和数组下标是等效的。</p><h2 id="数组作为参数有啥意义呢？"><a href="#数组作为参数有啥意义呢？" class="headerlink" title="数组作为参数有啥意义呢？"></a>数组作为参数有啥意义呢？</h2><p>讲得更加清楚一点，实际上数组内容并没有传递给函数，而是将数组的地址、包含的元素类型以及元素数目提交给了函数。有了这些信息后，函数便可以使用原来的数组。传递<strong>常规变量时</strong>，函数将<strong>使用该变量的拷贝</strong>；但传递<strong>数组</strong>时，函数将<strong>使用原来的数组</strong>。</p><p>一种是拷贝了原始数据，并进行操作，一种是使用指针，直接操作原始数据。都实现了函数的值传递。但是我想两种方法肯定是有利有弊的呀。继续往下分析。</p><h3 id="数组名与指针对应是否是好事呢？"><a href="#数组名与指针对应是否是好事呢？" class="headerlink" title="数组名与指针对应是否是好事呢？"></a>数组名与指针对应是否是好事呢？</h3><p>先说回答哈，确实是一件好事。将数组地址作为参数可以节省复制整个数组所需要的时间和内存。如果数组很大的话。则使用拷贝的系统开销将非常大；程序不仅需要更多的计算机内存，还需要花费时间来复制大块的数据。</p><p>但是呢，有利有弊哈，我们使用指针其本质上时使用了原始数据，增加了破坏数据的风险。不过不怕，C++可以解决它，ANSI C也可以解决它，那就是const限定符了。稍后我在写例子哈。</p><p>这边再写一个例子，用于演示咱们的指针是如何运转的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ArSize = <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> things[ArSize] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>,<span class="number">64</span>,<span class="number">128</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; things &lt;&lt; <span class="string">" = arr address, "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(things) &lt;&lt; <span class="string">" = sizeof things\n"</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = sums(things, ArSize);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Total things: "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    sum = sums(things, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"First tree people buy "</span> &lt;&lt; sum &lt;&lt; <span class="string">" things.\n"</span>;</span><br><span class="line">    sum = sums(things + <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Last four people buy "</span> &lt;&lt; sum &lt;&lt; <span class="string">" things.\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; arr &lt;&lt; <span class="string">" = arr, "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(* arr) &lt;&lt; <span class="string">" = sizeof  arr\n "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        total += arr[i];</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边的地址值和数组的长度会随着系统的变化而变化哈，如果你和你的小伙伴们运行出不一样的结果，不要诧异哦！此外，有些C++实现 的是以十进制而不是十六进制格式显示地址哈，所以不要太大惊小怪，显得见识浅薄了些。还有一些编译器以十六进制显示地址时，会加上前缀0x呢。</p><p><strong>代码说明：</strong></p><p>首先我这边things和arr指向了同一个地址。但是sizeof(things)的值为32，而sizeof(arr)为4（是我电脑上运行的结果哈）。这是由于sizeof(things)是整个数组的长度，而sizeof(arr)只是指针变量的长度。顺道加一个知识点，这也是必须显式传递数组长度，而不能在sums()中使用sizeof(arr)的原因；指针本身并没有之处数组的长度。</p><p>因为咱们的sums()只能通过第二个参数获知数组中的元素数量，我们可以对函数做修改。例如，程序第二次使用该函数时，这样调用它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = sums(things， <span class="number">3</span>)；</span><br></pre></td></tr></table></figure><p>通过告诉函数things有3个元素，可以让它计算前3个元素的总和。</p><p>也可以提供假的数组起始位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = sums(things + <span class="number">4</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>由于things是第一个元素的地址，因此things+4是第五个元素的地址。这条语句将计算数组第5、6、7、8个元素的总和。请注意输出中第三次函数调用选择将不同于前两个调用的地址赋给arr的。</p><p><strong>Attention！</strong></p><p>我们可以数组类型和元素数量告诉数组处理函数，通过两个不同的参数来传递他们：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> n)</span></span></span><br></pre></td></tr></table></figure><p>而不要试图使用方括号表示法来传递数组长度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">int</span> arr[<span class="built_in">size</span>])</span></span></span><br></pre></td></tr></table></figure><h2 id="各种例子，来更深入了解数组函数"><a href="#各种例子，来更深入了解数组函数" class="headerlink" title="各种例子，来更深入了解数组函数"></a>各种例子，来更深入了解数组函数</h2><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>假设要使用一个数组来记录房地产的价值。</p><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>首先要明确使用哪种类型。当然double的取值范围比int和long大，并且提供了足够多的有效位数来精确地表示这些值。</p><p>接下来必须决定数组元素的数目。（这边不考虑动态数组）如果房地产数目不超过5个，则可以使用一个包含5个元素的double数组。</p><p>考虑操作：两个基本的操作，一、将值读入到数组中和显示数组内容。二、重新评估每种房地产的值。</p><p>简单起见，我们规定房地产以相同比率增加或者减少。</p><h3 id="1-填充数组"><a href="#1-填充数组" class="headerlink" title="1.填充数组"></a>1.填充数组</h3><p>顾客不止一个，所以我们可以做多个数组，房产得有上限，毕竟我这边不搞花里胡哨的动态数组。所以函数定义为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill_array</span><span class="params">(<span class="keyword">double</span> arr[], <span class="keyword">int</span> limit)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数接受两个参数，一个是数组名，另一个指定了要读取的最大元素数；该函数返回实际读取的元素数。例如，如果使用该函数处理一个包含了5个元素的数组，则将5作为第二个参数。如果只输入3个值，则该函数将返回3.</p><p>可有循环连续地将值读入到数组中，但是我们该如何提早结束循环呢？有两种思路，一、使用一个特殊值来指定输出结束。由于所有的属性不为负，我们可以使用负值来指出输入结束。二、该函数应对错误输入做出反应，如停止输入等。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill_array</span><span class="params">(<span class="keyword">double</span> arr[], <span class="keyword">int</span> limit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">double</span> temp;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter value # "</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">cin</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">cin</span>.<span class="built_in">get</span>() != <span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Bad input; input process terminated.\n"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        arr[i] = temp;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数可以判断输入是否出错，比如说负值啦等等。如果输入正确的话，则循环将会在读取最大数目的值后结束。循环完成的最后一项工作后，将i加1，因此循环结束后，i将比最后一个数组索引大1，即等于填充的元素数目。然后，函数返回这个值。</p><h3 id="2-显示数组及用const保护数组"><a href="#2-显示数组及用const保护数组" class="headerlink" title="2.显示数组及用const保护数组"></a>2.显示数组及用const保护数组</h3><p>不是啥高大的东西，就是显示元素的数组，但是最重要的东西应该是const保护数组。</p><p>当我们用数组名表示指针传递值时，会导致原始数据受到威胁。这个时候我呼应了上文中所要讲的方法const保护数组不被修改。</p><p>为了防止函数无意中修改数组的内容，我们可以在声明形参时使用关键字const：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> arr[], <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>该声明表明，指针arr指向的是常量数据。这意味着不能使用arr修改该数据，也就是说，可以使用值，但是不会修改。咳咳，这并不是意味着原始数组必须是常量，而只是意味着不能在show_array()函数中使用arr来修改数据。因此该函数将数组视为只读数据。 如果你要在函数中给原数组赋值的话，是会报错的。</p><p>show_array函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Property #"</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">": $"</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-修改数组"><a href="#3-修改数组" class="headerlink" title="3.修改数组"></a>3.修改数组</h3><p>实现的功能是对数组中每个元素与同一个重新评估因子相乘。需要给函数传递3个参数：因子、数组和元素数目。该函数不需要返回值，因此代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Property #"</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">": $"</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就和上一个函数不一样了，这边是必须要修改值的，所以不能加const</p><h2 id="4-组合代码解出题目"><a href="#4-组合代码解出题目" class="headerlink" title="4.组合代码解出题目"></a>4.组合代码解出题目</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill_array</span><span class="params">(<span class="keyword">double</span> arr[], <span class="keyword">int</span> limit)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> arr[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">revalue</span><span class="params">(<span class="keyword">double</span> r, <span class="keyword">double</span> arr[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">double</span> properties[Max];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = fill_array(properties, Max);</span><br><span class="line">    show_array(properties, <span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter revaluation factor: "</span>;</span><br><span class="line">        <span class="keyword">double</span> factor;</span><br><span class="line">        <span class="keyword">while</span> (!(<span class="built_in">cin</span> &gt;&gt; factor))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">cin</span>.<span class="built_in">get</span>() != <span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Bad input; Please enter a number: "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        revalue(factor, properties, <span class="built_in">size</span>);</span><br><span class="line">        show_array(properties, <span class="built_in">size</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Done.\n"</span>;</span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill_array</span><span class="params">(<span class="keyword">double</span> arr[], <span class="keyword">int</span> limit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">double</span> temp;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter value #"</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">cin</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">cin</span>.<span class="built_in">get</span>() != <span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Bad input; input process terminated.\n"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Property #"</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">": $"</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">revalue</span><span class="params">(<span class="keyword">double</span> r, <span class="keyword">double</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        arr[i] *= r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-程序说明"><a href="#5-程序说明" class="headerlink" title="5.程序说明"></a>5.程序说明</h3><p>回顾一下整个过程。我们首先考虑的是通过数据类型和设计适当的函数来处理数据，然后讲这些函数组合成一个程序。有时这个也称为自下而上的程序设计（bottom-up programming)，因为设计过程是从组建到整体进行。这种方法非常适合于OOP——它首先强调的是数据表示和操纵。</p><p>以前的过程性编程倾向于从上而下的程序设计，首先指定模块化设计方案，然后在研究细节，</p><p>最终产品都是模块化程序，也就是我们最后得到的东西都是模块化的东西，据我目前的经验来看，当代程序的思路都是模块化！</p><h3 id="6-数组处理函数的常用编写方式"><a href="#6-数组处理函数的常用编写方式" class="headerlink" title="6.数组处理函数的常用编写方式"></a>6.数组处理函数的常用编写方式</h3><p>总结一下数组处理函数无非就两种情况</p><p>情况一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_modify</span><span class="params">(<span class="keyword">double</span> ar[], <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>情况二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _f_no_change(<span class="keyword">const</span> <span class="keyword">double</span> ar[], <span class="keyword">int</span> n);</span><br></pre></td></tr></table></figure><p>再扯几句哈，函数原型是可以省略变量名的，也可以将返回类型作指定，比如这边就指定了void。</p><h3 id="7-使用数组区间的函数"><a href="#7-使用数组区间的函数" class="headerlink" title="7.使用数组区间的函数"></a>7.使用数组区间的函数</h3><p>上面我们讲数组和函数的时候，用的是传统的C++方法，将指向数组起始处的指针作为一个参数，将数组长度作为第二个参数（指针指出数组的位置和数组类型），这样便给函数提供了找到所有数据所需要的信息。</p><p>我们处理数组的C++函数，必须将数组中的数据种类、数组的起始位置和数组中元素数量给函数。</p><p>还有一种给函数提供所需信息的方法是，即指定元素区间，这可以通过传递两个指针来完成：一个指针表示数组的开头，另一个指针标识数组的尾部。（C++标准模板库STL中将区间方法广义化了，STL方法使用“ 超尾”概念来指定区间，也就是说，对于数组而言，标识数组结尾的参数将是指向最后一个元素后面的指针。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> elboud[<span class="number">20</span>];</span><br></pre></td></tr></table></figure><p>指针elboud和elboud+20定义了区间。唉，其实就是数组名+多少个（数字）从而做出区间，写个小例子便于理解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ArSize = <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> * <span class="built_in">begin</span>, <span class="keyword">const</span> <span class="keyword">int</span> * <span class="built_in">end</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">int</span> things[ArSize] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = sums(things, things + ArSize);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Total things eaten: "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    sum = sums(things, things + <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"First three people buy "</span> &lt;&lt; sum &lt;&lt; <span class="string">" things.\n"</span>;</span><br><span class="line">    sum = sums(things + <span class="number">4</span>, things + <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Last four people buy "</span> &lt;&lt; sum &lt;&lt; <span class="string">" things.\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> * <span class="built_in">begin</span>, <span class="keyword">const</span> <span class="keyword">int</span> * <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> * pt;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(pt = <span class="built_in">begin</span>; pt != <span class="built_in">end</span>; pt++)</span><br><span class="line">        total += *pt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>太简单了，不解释了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;函数与数组&quot;&gt;&lt;a href=&quot;#函数与数组&quot; class=&quot;headerlink&quot; title=&quot;函数与数组&quot;&gt;&lt;/a&gt;函数与数组&lt;/h1&gt;&lt;p&gt;虽然我上面开了两篇博客准备一锅把函数端掉，但是当我想到数组哈，我觉得还是有必要对它好好搞一番。为什么呢？因为当我们在
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="C++" scheme="https://mr8god.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>是个值得纪念的日子呢</title>
    <link href="https://mr8god.cn/2020/04/01/%E7%94%9F%E6%B4%BB%E9%9C%80%E8%A6%81%E4%B8%80%E4%BA%9B%E8%B6%A3%E5%91%B3%E5%93%A6%EF%BC%81/%E6%98%AF%E4%B8%AA%E5%80%BC%E5%BE%97%E7%BA%AA%E5%BF%B5%E7%9A%84%E6%97%A5%E5%AD%90%E5%91%A2/"/>
    <id>https://mr8god.cn/2020/04/01/%E7%94%9F%E6%B4%BB%E9%9C%80%E8%A6%81%E4%B8%80%E4%BA%9B%E8%B6%A3%E5%91%B3%E5%93%A6%EF%BC%81/%E6%98%AF%E4%B8%AA%E5%80%BC%E5%BE%97%E7%BA%AA%E5%BF%B5%E7%9A%84%E6%97%A5%E5%AD%90%E5%91%A2/</id>
    <published>2020-04-01T05:28:32.919Z</published>
    <updated>2020-04-01T05:30:59.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="韶光易逝，劝君惜取少年时！"><a href="#韶光易逝，劝君惜取少年时！" class="headerlink" title="韶光易逝，劝君惜取少年时！"></a>韶光易逝，劝君惜取少年时！</h1><p><img src="https://i.loli.net/2020/04/01/V1cH7yJTen8SgZz.jpg" alt="Screenshot_2020-03-31-18-16-24-491_com.maimemo.an.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;韶光易逝，劝君惜取少年时！&quot;&gt;&lt;a href=&quot;#韶光易逝，劝君惜取少年时！&quot; class=&quot;headerlink&quot; title=&quot;韶光易逝，劝君惜取少年时！&quot;&gt;&lt;/a&gt;韶光易逝，劝君惜取少年时！&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.n
      
    
    </summary>
    
    
      <category term="生活需要一些趣味" scheme="https://mr8god.cn/categories/%E7%94%9F%E6%B4%BB%E9%9C%80%E8%A6%81%E4%B8%80%E4%BA%9B%E8%B6%A3%E5%91%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>论数理统计中统计量，常用统计量</title>
    <link href="https://mr8god.cn/2020/04/01/%E6%95%B0%E7%90%86%E7%9F%A5%E8%AF%86/%E8%AE%BA%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E4%B8%AD%E7%BB%9F%E8%AE%A1%E9%87%8F%EF%BC%8C%E5%B8%B8%E7%94%A8%E7%BB%9F%E8%AE%A1%E9%87%8F/"/>
    <id>https://mr8god.cn/2020/04/01/%E6%95%B0%E7%90%86%E7%9F%A5%E8%AF%86/%E8%AE%BA%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E4%B8%AD%E7%BB%9F%E8%AE%A1%E9%87%8F%EF%BC%8C%E5%B8%B8%E7%94%A8%E7%BB%9F%E8%AE%A1%E9%87%8F/</id>
    <published>2020-04-01T05:23:07.889Z</published>
    <updated>2020-04-01T05:23:49.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="论数理统计中统计量，常用统计量"><a href="#论数理统计中统计量，常用统计量" class="headerlink" title="论数理统计中统计量，常用统计量"></a>论数理统计中统计量，常用统计量</h1><p><img src="https://i.loli.net/2020/04/01/iLPZ5e413UNdvW6.jpg" alt="391.jpg"></p><h2 id="从样本中提取有用的信息来研究总体的分布及各种特征数的过程叫做构造统计量"><a href="#从样本中提取有用的信息来研究总体的分布及各种特征数的过程叫做构造统计量" class="headerlink" title="从样本中提取有用的信息来研究总体的分布及各种特征数的过程叫做构造统计量"></a>从样本中提取有用的信息来研究总体的分布及各种特征数的过程叫做构造统计量</h2><p>统计量：样本的不含任何位置参数的函数</p><p><img src="https://i.loli.net/2020/04/01/KDc79iWh8Tvz6xy.jpg" alt="392.jpg"></p><h2 id="常用统计量"><a href="#常用统计量" class="headerlink" title="常用统计量"></a>常用统计量</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>样本均值<br>样本方差<br>样本标准差<br>样本矩</p><h4 id="样本均值和总体均值的区别"><a href="#样本均值和总体均值的区别" class="headerlink" title="样本均值和总体均值的区别"></a>样本均值和总体均值的区别</h4><p><img src="https://i.loli.net/2020/04/01/oOYC6BNKpJxyRDu.jpg" alt="393.jpg"></p><p><img src="https://i.loli.net/2020/04/01/cWUvxPpwblEDnhQ.jpg" alt="394.jpg"></p><p><img src="https://i.loli.net/2020/04/01/KbjzXNJBZxSL8ht.jpg" alt="395.jpg"></p><p>从上面的例子我们可以总结出这样的结论</p><p>样本均值的平均值等于总体均值<br>样本方差的平均值等于总体均值</p><h3 id="当总体数字特征未知时，我们可以总结出以下的方法来求数字特征"><a href="#当总体数字特征未知时，我们可以总结出以下的方法来求数字特征" class="headerlink" title="当总体数字特征未知时，我们可以总结出以下的方法来求数字特征"></a>当总体数字特征未知时，我们可以总结出以下的方法来求数字特征</h3><ol><li>用样本均值估计总体均值</li><li>用样本方差估计总体方差</li><li>用样本原点矩估计总体原点矩</li><li>用样本中心矩估计总体中心矩</li></ol><h3 id="统计量的分布被称为抽样分布"><a href="#统计量的分布被称为抽样分布" class="headerlink" title="统计量的分布被称为抽样分布"></a>统计量的分布被称为抽样分布</h3><p>总体服从一般分布，如指数分布均匀，分布等要得出统计量的分布是很困难的<br>总体服从正态分布时统计量样本均值样本方差是可以计算的</p><h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><p>方法：</p><ol><li>求最大最小值，并求极差</li><li>分组定组距（一般数据个数n&gt;=50，分成10组以上；小于的时候，一般分为5组）</li><li>定分点定区间</li><li>统计数据落入各组间的概率</li><li>画出直方图</li></ol><p>作图反应数据特征</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;论数理统计中统计量，常用统计量&quot;&gt;&lt;a href=&quot;#论数理统计中统计量，常用统计量&quot; class=&quot;headerlink&quot; title=&quot;论数理统计中统计量，常用统计量&quot;&gt;&lt;/a&gt;论数理统计中统计量，常用统计量&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://
      
    
    </summary>
    
    
      <category term="数理知识" scheme="https://mr8god.cn/categories/%E6%95%B0%E7%90%86%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="概率论" scheme="https://mr8god.cn/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>论概率论中大数定理及中心极限定理</title>
    <link href="https://mr8god.cn/2020/03/30/%E6%95%B0%E7%90%86%E7%9F%A5%E8%AF%86/%E5%A4%A7%E6%95%B0%E5%AE%9A%E7%90%86%E5%8F%8A%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/"/>
    <id>https://mr8god.cn/2020/03/30/%E6%95%B0%E7%90%86%E7%9F%A5%E8%AF%86/%E5%A4%A7%E6%95%B0%E5%AE%9A%E7%90%86%E5%8F%8A%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/</id>
    <published>2020-03-30T12:11:08.084Z</published>
    <updated>2020-03-31T15:15:47.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大数定理及中心极限定理"><a href="#大数定理及中心极限定理" class="headerlink" title="大数定理及中心极限定理"></a>大数定理及中心极限定理</h1><h2 id="依概率收敛、切比雪夫不等式"><a href="#依概率收敛、切比雪夫不等式" class="headerlink" title="依概率收敛、切比雪夫不等式"></a>依概率收敛、切比雪夫不等式</h2><h3 id="依概率收敛"><a href="#依概率收敛" class="headerlink" title="依概率收敛"></a>依概率收敛</h3><p><strong>定义</strong></p><p><img src="https://i.loli.net/2020/03/31/76nd8sprowBZkF3.jpg" alt="依概率收敛.jpg"></p><p>稍微解释一下哈，当存在一个任意值ε（大于0哈），当我们的n趋向于无穷大的时候，那么这个概率趋向于零。当然这么说就只是表面意思意思了，我们得详细地去了解一下呀。</p><p>这边需要举个例子了</p><p><img src="https://i.loli.net/2020/03/31/rZAgH74IonLY5CK.jpg" alt="依概率收敛的详细解释.jpg"></p><p>江某人有话说：这里看到贝努利试验，我想大家肯定会松了一大口气，因为这个东西大家肯定都懂。像咱们抛一次硬币就算一次贝努利试验，但是我们抛了n次硬币。这就叫做n重贝努利试验。</p><p>扯回正题哈，当咱们对某一件事件进行观测的时候，若事件A（为了便于解释，就把某一件事件设为事件A了）在一次试验发生的概率为P。利用n次事件中出现了na次事件A，算出事件A出现的频率（n/na）。</p><p>注意了。图中的公式是错误的。也就是，当n越大的时候，并不意味这一次事件的概率与咱们算的频率相等。我们讲的频率“稳定于”概率应该从<strong>可能性角度</strong>来讲。</p><p><img src="https://i.loli.net/2020/03/31/qaprc7XbC5zTJAf.jpg" alt="从可能性来讲概率收敛.jpg"></p><p>得出概念，只有满足以下公式</p><script type="math/tex; mode=display">\lim_{n\rightarrow+\infty}P\{|\frac{na}{n}-p|\geq ε\}=0</script><p>（楼上的公式打的不容易呀，害，真刺激！）</p><p>那么这种收敛就称为“依概率收敛”</p><p><strong>依概率收敛的性质：</strong></p><p><img src="https://i.loli.net/2020/03/31/ZYroinA1RM6qgch.jpg" alt="依概率收敛的性质.jpg"></p><p>这边就由我江某人来给大家稍微讲解一下以助于理解哈：</p><p>首先前三行的意思是，当Xn依概率收敛到a，Yn依概率收敛到b，那么当n趋向于无穷是，且函数g(x,y)在点(a,b)上连续，那么g(Xn,Yn)依概率收敛到g(a,b)。</p><p>中间两行的意思是，Xn+Yn会依概率收敛到a+b，Xn/Yn会依概率收敛到a/b，XnxYn会依概率收敛到axb。</p><p>特别需要记住一点的是，最后两行，如果Xn依概率收敛到a，f(x)在a点连续，那么当n趋向于无穷的时候，f(Xn)依概率收敛到f(a)。</p><h3 id="切比雪夫不等式（Chebyshev不等式）"><a href="#切比雪夫不等式（Chebyshev不等式）" class="headerlink" title="切比雪夫不等式（Chebyshev不等式）"></a>切比雪夫不等式（Chebyshev不等式）</h3><p>设随机变量X具有数学期望，且它的数学期望E(X)=μ，方差D(X)=$σ^2$，则对于任意$ε&gt;0$，都有：</p><script type="math/tex; mode=display">P\{|X-μ|\geq ε\} \leq \frac{σ^2}{ε^2}</script><p>定理的等价形式为：</p><script type="math/tex; mode=display">P\{|X-μ| < ε\} \geq 1-\frac{σ^2}{ε^2}</script><p>// 此处明天补上证明过程。。。</p><p>X与它均值的偏差的绝对值大于等于ε的概率小于<script type="math/tex">\frac{σ^2}{ε^2}</script></p><p>适用范围广，但是结果相对来说比较粗糙。</p><p>//  此处后期补上例题解析</p><h2 id="大数定律"><a href="#大数定律" class="headerlink" title="大数定律"></a>大数定律</h2><p>频率的稳定值记为概率，这句话的意思，可以用一个公式来进行描述。</p><script type="math/tex; mode=display">\lim_{n\rightarrow+\infty}P\{|\frac{na}{n}-p|\geq ε\}=0</script><p>这个结论可以用“大数定律”来进行描述</p><p><strong>定理1（贝努力大数定律）</strong></p><p>记na为n重贝努利试验中事件A发生的次数，并记事件A在每次试验中发生的概率为p(0<p<1)，则对于$&forall ε > 0$有</p><script type="math/tex; mode=display">\lim_{n\rightarrow+\infty}P\{|\frac{na}{n}-p|\geq ε\}=0</script><p>即$\frac{na}{n}$趋向于P，当n趋向于+$\infty$</p><p>这就说明了，频率是依概率收敛的事件发生的概率的！！！</p><p>证明：略，明天补上。。。</p><p><strong>贝努力大数定律的重要意义：</strong></p><ol><li>提供了用大量重复独立试验中事件出现概率的极限值来确定概率的理论依据，使得概率的概念才有严格的意义。</li><li>提供了通过试验来确定事件概率的方法——可以通过做试验确定某事件发生的频率，并把它作为相应的概率估计，例如：想估计某产品的不合格品率p,可以随机抽取n（n较大）件，将n件产品的不合格品的比例作为p的估计。</li></ol><p><strong>大数定律(Laws of Large Numbers)</strong></p><p>内容：设X1，X2，……，Xn，……是一列随机变量，则在一定条件下，随机变量序列Yn=$\frac{X1+……+Xn}{n} $，收敛到μ，当n趋向于$\infty$的时候。</p><p>这边需要帮助理解的几个点是：</p><ol><li>随机变量序列Yn收敛到μ的含义是什么？答：依概率收敛</li><li>μ是什么？答：当Xi期望相同时，μ = E(Xi)</li><li>一定条件是什么？答：不一样的条件会得到不同的大数定律</li></ol><p><strong>定理2（切比雪夫大数定律的推论）</strong></p><p><strong>定理3（辛钦大数定律）</strong></p><p><strong>辛钦大数定律的意义：</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;大数定理及中心极限定理&quot;&gt;&lt;a href=&quot;#大数定理及中心极限定理&quot; class=&quot;headerlink&quot; title=&quot;大数定理及中心极限定理&quot;&gt;&lt;/a&gt;大数定理及中心极限定理&lt;/h1&gt;&lt;h2 id=&quot;依概率收敛、切比雪夫不等式&quot;&gt;&lt;a href=&quot;#依概率收
      
    
    </summary>
    
    
      <category term="数理知识" scheme="https://mr8god.cn/categories/%E6%95%B0%E7%90%86%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="概率论" scheme="https://mr8god.cn/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>第7章 函数——C++的编程模块（下）</title>
    <link href="https://mr8god.cn/2020/03/30/C++/%E7%AC%AC7%E7%AB%A0-%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94C++%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>https://mr8god.cn/2020/03/30/C++/%E7%AC%AC7%E7%AB%A0-%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94C++%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2020-03-29T16:22:27.120Z</published>
    <updated>2020-03-30T08:06:43.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="7-2-函数参数和按值传参"><a href="#7-2-函数参数和按值传参" class="headerlink" title="7.2    函数参数和按值传参"></a>7.2    函数参数和按值传参</h2><p>C++中经常性的一种操作就是，案值传递参数，这意味着将数值传递给一个函数，然后后者还会返回一个值赋给一个新的变量。</p><p>在函数中被声明的变量是函数私有的，这是他自己凭本事声明的变量。在函数被调用时，计算机会为他们（指变量）申请内存。在函数结束的时候，计算机会释放掉内存，这样的变量我们称之为<strong>局部变量</strong></p><h3 id="7-2-1-多个参数"><a href="#7-2-1-多个参数" class="headerlink" title="7.2.1    多个参数"></a>7.2.1    多个参数</h3><p>函数可以包含多个参数，例如写成这种形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function(<span class="string">'R'</span>, <span class="number">25</span>);</span><br></pre></td></tr></table></figure><p>上述函数调用将两个参数传递给函数function( )，</p><p>同样，在定义函数时，也在函数头中使用由逗号分割的参数声明列表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> n)</span></span></span><br></pre></td></tr></table></figure><p>之前写的function中R传递给了c，25传递给了n</p><h3 id="7-2-2-另外一个接受两个参数的函数"><a href="#7-2-2-另外一个接受两个参数的函数" class="headerlink" title="7.2.2    另外一个接受两个参数的函数"></a>7.2.2    另外一个接受两个参数的函数</h3><p><strong>注意了注意了，这边要讲一个比较有趣的东西了</strong></p><p>Problem：美国许多州都采用某种纸牌游戏的形式来发行彩票，让参与者从卡片中选择一定数目的选项，例如从51个数字中选取6个，随后彩票管理者将随机抽取6个数，如果参与者选择的数字与这6个完全相同，将赢得大约几百万美元的奖金，我们的函数将计算中奖的几率</p><p>首先，需要一个公式。假设必须要从51个数中选取6个数，而获奖的几率是1/R，则R的计算公式如下</p><script type="math/tex; mode=display">R =\frac  {51×50×49×48×47×46}{6×5×4×3×2×1}</script><p>选择6个数时，分母为前6个整数的乘积或6的阶乘分子也是6个连续整数的乘积，从51开始依次递减一,推而广之，如果从numbers个数中选取picks个数，而分母是picks的阶乘，分子为numbers开始向前的picks个整数的乘积。可以用for循环进行计算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> result = <span class="number">1.0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = numbers, p = picks; p &gt; <span class="number">0</span>; n--, p--)</span><br><span class="line">    result = result * n / p;</span><br></pre></td></tr></table></figure><p>循环不是首先将所有的分子项相乘，而是首先将1.0与第1个分子项相乘，然后除以第1个分母项，然后下一轮循环，乘以第2个分子项并除以第2个分母项，这样得到的乘积和先进行乘法运算得到的一样，例如对于(10*9)/(2×1)和(10÷2)×(9÷1)，前者将计算90÷2得到45，或者将计算5×9得到49，这两种方法得到的结果相同，但前者的中间值90大于后者，因子越多，中间值的差别就越大，当数字非常大时，这种交替进行乘除运算的策略，可以防止中间结果超过最大的浮点数。</p><h3 id="7-3-函数和数组"><a href="#7-3-函数和数组" class="headerlink" title="7.3    函数和数组"></a>7.3    函数和数组</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;7-2-函数参数和按值传参&quot;&gt;&lt;a href=&quot;#7-2-函数参数和按值传参&quot; class=&quot;headerlink&quot; title=&quot;7.2    函数参数和按值传参&quot;&gt;&lt;/a&gt;7.2    函数参数和按值传参&lt;/h2&gt;&lt;p&gt;C++中经常性的一种操作就是，案值传递参
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="C++" scheme="https://mr8god.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>From Mr8god：hexo轻松搭建博客</title>
    <link href="https://mr8god.cn/2020/03/28/%E5%BB%BA%E7%AB%99%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/From%20Mr8god%EF%BC%9Ahexo%E8%BD%BB%E6%9D%BE%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://mr8god.cn/2020/03/28/%E5%BB%BA%E7%AB%99%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/From%20Mr8god%EF%BC%9Ahexo%E8%BD%BB%E6%9D%BE%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-03-28T10:54:20.067Z</published>
    <updated>2020-04-05T14:08:18.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境概述"><a href="#环境概述" class="headerlink" title="环境概述"></a>环境概述</h2><p>我粗略估计了一下哈，大概需要以下东西</p><ul><li>win10系统</li><li>hexo运行环境：node.js</li><li>下载包管理工具：npm</li><li>版本控制工具：git</li><li>IDE：vscode</li><li>主题：我就暂时用初始的landscape了</li></ul><p>当然ide是可以随便换的啦，用记事本也行呢。这种博客后期都是要靠Markdown来上传自己的文章的，且为了要让博客更加的适合自己，做出个性化的博客，需要你们去了解css、js等一些知识。</p><p>如果你学过git，那么这个教程就更简单了，纯粹就是帮你复习一遍git而已啦。</p><p>废话不多说，开始进入正题。</p><h2 id="搭建博客流程"><a href="#搭建博客流程" class="headerlink" title="搭建博客流程"></a>搭建博客流程</h2><h3 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h3><p>node.js需要下载好，官网下载即可</p><p>git也需要提前下载好，官网下载即可</p><h3 id="二、使用hexo博客搭建工具"><a href="#二、使用hexo博客搭建工具" class="headerlink" title="二、使用hexo博客搭建工具"></a>二、使用hexo博客搭建工具</h3><h4 id="Step1-本地新建文件夹"><a href="#Step1-本地新建文件夹" class="headerlink" title="Step1 本地新建文件夹"></a>Step1 本地新建文件夹</h4><p>这个文件夹会存储你博客之后所有的Markdown文件以及你生成的HTML文件</p><h4 id="Step2-进入目录让我们git-bash一下"><a href="#Step2-进入目录让我们git-bash一下" class="headerlink" title="Step2 进入目录让我们git bash一下"></a>Step2 进入目录让我们git bash一下</h4><p>这边我建立了名为“教程演示用博客”的文件夹，右击bash一下</p><p><img src="https://i.loli.net/2020/03/28/sybeN7tziCJREgU.jpg" alt="1.jpg"></p><h4 id="Step3-安装hexo"><a href="#Step3-安装hexo" class="headerlink" title="Step3 安装hexo"></a>Step3 安装hexo</h4><p>命令就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>如果网速慢的话可以采取cnpm安装，这边推荐一个博客讲解cnpm源更改哈：<a href="https://blog.csdn.net/cungudafa/article/details/98739459" target="_blank" rel="noopener">https://blog.csdn.net/cungudafa/article/details/98739459</a></p><p><img src="https://i.loli.net/2020/03/28/FHAVas5SlvbK8XB.jpg" alt="2.jpg"></p><h4 id="Step4-初始化hexo模板"><a href="#Step4-初始化hexo模板" class="headerlink" title="Step4 初始化hexo模板"></a>Step4 初始化hexo模板</h4><p>命令是</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/03/28/FEs67nYOLIJpVTN.jpg" alt="3.jpg"></p><p>在这边你或许会遇到一个问题，初始化速度极慢，令人难以忍受，咳咳，仔细思考哈。这个是有npm安装的，那问题自然出在npm上面，咱们换个源就行了，刚刚上一步你换过了的话这里就不用换啦，这边可以换阿里或者淘宝的源，蛮好的，继续偷懒，放上链接：<a href="https://blog.csdn.net/cungudafa/article/details/98739459" target="_blank" rel="noopener">https://blog.csdn.net/cungudafa/article/details/98739459</a></p><h4 id="Step5-初始化后的文件树"><a href="#Step5-初始化后的文件树" class="headerlink" title="Step5 初始化后的文件树"></a>Step5 初始化后的文件树</h4><p><img src="https://i.loli.net/2020/03/28/xwJP2vzKDOsGWVo.png" alt="43.png"></p><p>其中source_posts里边存放的都是Markdown格式文件，也就是咱们日后的博客文件哟</p><p>注意了，上面这幅图呀，只是为了给大家对照一下本地hexo init之后的文件夹是否缺啥漏啥，不要过分纠结哦。</p><p>比如我这边打开我的“教程演示用博客”文件夹，可以看到里边的文件架构和图片上显示的简直一模一样呢！</p><h4 id="Step6-hexo使用教程"><a href="#Step6-hexo使用教程" class="headerlink" title="Step6 hexo使用教程"></a>Step6 hexo使用教程</h4><p>hexo日常三命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment"># 清空已有hexo网站文件</span></span><br><span class="line">hexo generate(<span class="keyword">or</span> g) <span class="comment"># 依据网页文本与新的CSS样式生成新网站文件</span></span><br><span class="line">hexo server(<span class="keyword">or</span> s) <span class="comment"># 启动本地服务器，可以在localhost:4000查看网站修改效果</span></span><br></pre></td></tr></table></figure><h5 id="hexo入门教学"><a href="#hexo入门教学" class="headerlink" title="hexo入门教学"></a>hexo入门教学</h5><ol><li>老规矩，在博客页面下git bash一下，直接上面三连，这里边的意思呢，是说把上面三个命令，依次输入到咱们的gitbash上面，然后我们在我们的浏览器中输入localhost:4000，即可看到网站效果</li><li>一般咱们都是默认的landscape主题，后期当提交新文章或者新的样式的时候，往往都是从本地看好结果，确认无误后再部署到服务器上的，当然我在本地记录了各个版本。其实git版本控制器就是有这一部分的命令的，不过我暂时没有完全掌握哈，只能用老办法复制粘贴备份本地的博客</li><li>这边要注意了hexo有很多 主题，各种主题都很好请自己选择，官网主题：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></li><li>主题配置，在博客文件夹下主目录找到_config.yml，打开后，修改theme:landscape为自己选择的主题就行了</li></ol><h5 id="部署服务器教学"><a href="#部署服务器教学" class="headerlink" title="部署服务器教学"></a>部署服务器教学</h5><p>部署服务器呢，这里有这三种方案</p><ol><li>部署到github上<br>好处：免费，且安全，而且受众度广，知名度高<br>缺点：由于服务器不在国内，所以访问速度会慢</li><li>部署到gitee上：<br>楼上说的全部反过来就行了<br>好处：访问速度快<br>缺点：绑定自己家的域名居然还要我花钱？？？？害白嫖党不理解，不安全，发生过事故，而且仓库里的代码居然是保存在人家的服务器（阿里云，腾讯云）上的 你敢信？！！！<br>不过还是挺好的，嗯呢，说心里话呢，鼓励他</li><li>既部署到GitHub上又部署到gitee上：<br>嘿嘿嘿，想不到吧，我还能白嫖，取两家之长处，助自己之力，哈哈哈，<br>自主研发，别人还真没有（网上找不到哦）</li></ol><h6 id="部署到github上"><a href="#部署到github上" class="headerlink" title="部署到github上"></a>部署到github上</h6><ol><li><p>首先申请github账号</p></li><li><p>然后开始建仓库，这个建仓库很有讲究</p><p>仓库名应该是账号名加.github.io<br>比方说我github账号为mr8god，我的仓库名就是mr8god.github.io<br>仓库地址就是Mr8god/Mr8god.github.io<br>然后选择public公开就行了其他就OK了</p></li><li><p><img src="https://i.loli.net/2020/03/28/d34ShBQy2JCUgp7.jpg" alt="5.jpg" style="zoom: 50%;" /></p></li><li><p>建完仓库后你会看到这个页面<br>复制http后边那个ssh的地址，待会用得到这边为了演示，我就创建了我的mr6god仓库哈<br>地址就是：git@github.com:Mr8god/mr6god.github.io.git</p></li><li><p>这边我需要插一句，本地上传到服务器的工具就是Git版本控制工具，如果你能够熟练掌握git的使用，那么做这个博客很简单，也就是复习一下git的使用方法而已，但是如果你不熟悉的话，就略微麻烦而已。</p></li><li><p>这边将本地博客推送到githubpage（就是我刚刚说的服务器）之前，需要用到一个命令，在命令行（gitbash）运行这行命令：$ npm install hexo-deployer-git —save</p></li><li><p>然后咱们就可以使用hexo deployer进行推送，在推送的时候会遇到要求输入账号密码，照着输入就行了。<br>但是我们日后推送的话总不能每一次都输入密码吧，这边推荐SSH key秘钥连接，这边就不赘述了哈，自行百度</p></li><li><p>来了来了，最重要的就是这一步修改文件，还是刚刚的_config.yml文件，在文件末尾修改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>注意了，上面仓库填ssh地址，不是HTTP地址，就是这样，这边可以写git@github.com:Mr8god/mr6god.github.io.git</p></li><li><p>然后返回我们的gitbash 输入下面两行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li><li><p>过一会访问域名：<br>https://<Github账号名称>.github.io<br>就可以咯，然后就会是你本地的博客页面了</p></li></ol><h6 id="部署到gitee上"><a href="#部署到gitee上" class="headerlink" title="部署到gitee上"></a>部署到gitee上</h6><ol><li><p>老规矩，申请码云账户，新建仓库</p></li><li><p>仓库名字必须和你注册githee的注册名相同，不然css路径会读错</p></li><li><p>得到咱们的仓库地址，复制下来</p></li><li><p>接下来就是和github不同的一点了，码云需要到它的服务页面打开page功能</p><p><img src="https://i.loli.net/2020/03/28/eiyDRVu9GHqQbB1.jpg" alt="6.jpg" style="zoom:50%;" /></p><p><img src="https://i.loli.net/2020/03/28/QsxBjbqgwpt6uI3.jpg" alt="7.jpg" style="zoom:50%;" /></p><p>启动部署即可</p></li><li><p>返回咱们的本地博客目录，修改主目录下的_config.yml文件，在文件末尾修改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>这边将本地博客推送到码云仓库之前（就是我刚刚说的服务器），需要用到一个命令，在命令行（gitbash）运行这行命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>然后返回我们的gitbash 输入下面两行代码：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li><li><p>然后输入<br> http://&lt;码云用户名&gt;.gitee.io/<br> 就可以 看到我们本地的博客样子了</p></li></ol><h6 id="既部署到GitHub上又部署到gitee上"><a href="#既部署到GitHub上又部署到gitee上" class="headerlink" title="既部署到GitHub上又部署到gitee上"></a>既部署到GitHub上又部署到gitee上</h6><p>在我们干完上面的两件事之后，其实很多都是重复工作，我们只需要修改一个配置文件就行了，就是咱们的网站配置文件_config.yml</p><p><img src="https://i.loli.net/2020/03/28/kqI9ngwjXp2531O.jpg" alt="8.jpg"></p><p>改成上面这个样子就可以了</p><p>我想讲一下为什么会有第三种方案的诞生哈，因为考虑到github的服务器搭在国外，所以我们日常访问上面的博客的时候它会很慢，于是我们可以靠这种方法去分流哈。分流的意思是，当我访问一个域名（这个域名同时解析了我两个博客page的地址）的时候，会自动根据我们离哪个服务器更近而自动去选择访问哪个服务器。</p><p>其实这种做法有专门的名词，叫做负载均衡。可以使用cdn服务来达到同样一个效果。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>emmmm，说一下之后的发展，已经在搭其他框架了，打算用回归老本行，重拾Django，用这个框架做更细致的博客哈。</p><p>然后gitee肯定是要淘汰掉的，因为他居然要付费才能让我选择自定义的域名，每年一百，啧啧啧，害。而且它也不安全嘛，思来想去，换掉它指日可待。</p><p>暂时就写这么多啦。然后呢，有啥问题要交流的，暂时我就放我的QQ啦：1803357141。因为还没做其他功能。害，就是这样。欢迎交流！</p><p>对了对了，最后感谢一位程序媛的博客对我的帮助，放上她的博客地址哈：<a href="https://cungudafa.gitee.io/" target="_blank" rel="noopener">https://cungudafa.gitee.io/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;环境概述&quot;&gt;&lt;a href=&quot;#环境概述&quot; class=&quot;headerlink&quot; title=&quot;环境概述&quot;&gt;&lt;/a&gt;环境概述&lt;/h2&gt;&lt;p&gt;我粗略估计了一下哈，大概需要以下东西&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;win10系统&lt;/li&gt;
&lt;li&gt;hexo运行环境：node
      
    
    </summary>
    
    
      <category term="建博客那些事儿" scheme="https://mr8god.cn/categories/%E5%BB%BA%E5%8D%9A%E5%AE%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    
    
      <category term="hexo_Next" scheme="https://mr8god.cn/tags/hexo-Next/"/>
    
  </entry>
  
  <entry>
    <title>第7章 函数——C++的编程模块（上）</title>
    <link href="https://mr8god.cn/2020/03/25/C++/%E7%AC%AC7%E7%AB%A0%20%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94C++%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97/"/>
    <id>https://mr8god.cn/2020/03/25/C++/%E7%AC%AC7%E7%AB%A0%20%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94C++%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97/</id>
    <published>2020-03-25T08:48:52.497Z</published>
    <updated>2020-03-30T01:08:52.680Z</updated>
    
    <content type="html"><![CDATA[<p>C++自带一个包含函数的大型库（标准ANSI库加上多个C++类），但真正的编程乐趣在于编写自己的函数；另一方面，要提高编程效率，可以更深入地学习STL和BOOSTC++提供的功能。</p><h2 id="7-1-复习函数的基本知识"><a href="#7-1-复习函数的基本知识" class="headerlink" title="7.1    复习函数的基本知识"></a>7.1    复习函数的基本知识</h2><p>来复习一下介绍过的有关函数的知识。要使用C++函数，必须完成以下工作：</p><ul><li>提供函数的定义</li><li>提供函数原型</li><li>调用函数</li></ul><p>库函数是已经定义好和编译好的函数，同时可以使用标准库头文件提供其原型，因此只需正确地调用这种函数即可。比如说strlen()函数，可以用来确定字符串的长度。相关的标准头文件cstring包含了strlen()和其他一些与字符串相关的函数的原型。</p><p>然后还有一点要注意的是，咱们程序员在编写函数的时候，一定要注意三点——定义、提供原型、调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"main() will call the simple() function:\n"</span>;</span><br><span class="line">    simple();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"main() is finished with the simple() function.\n"</span>;</span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm but a simple function.\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是一个小例子。</p><h3 id="7-1-1-定义函数"><a href="#7-1-1-定义函数" class="headerlink" title="7.1.1    定义函数"></a>7.1.1    定义函数</h3><p>可以将函数分为两类：没有返回值的函数和有返回值的函数。没有返回值的函数被称为void函数，其通用格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionName</span><span class="params">(parameterList)</span></span>&#123;</span><br><span class="line">statement(s)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，paramterList指定了传递给函数的参数类型和数量，本章后面将更详细地介绍该列表。可选的返回语句标记了函数的结尾；否则，函数将在右花括号处结束。</p><p>对于返回值，需要注意的是，</p><ul><li>如果原函数的数据类型是double但是返回的是int，返回值将会被强制转化为double</li><li>C++对返回值的类型有一定的限制：不能是数组，但可以是其他任何类型——整数、浮点数、指针、甚至可以是结构和对象（不过我们可以将数组作为结构或对象组成部分来返回）</li><li>若函数包含多条返回语句（例如，它们位于不同的ifelse选项中）则函数在执行遇到的第一条返回语句后结束。</li></ul><p>干货分享：虽然作为一名程序员不需要知道函数是怎么返回值的，但是对这个问题有所了解有助于澄清概念。</p><p>通常函数通过将返回值复制到指定的CPU寄存器或内存单元中来将其返回。</p><p>随后，调用程序将查看该存储单元。</p><p>返回函数和调用函数必须就该内存单元中存储的数据的类型达成一致。</p><p>函数原型将返回值类型告知调用程序，而函数定义命令被调用函数应返回什么类型的数据。</p><p>在原型中提供与定义中相同的信息似乎有些多余，但这样做确实有道理。要让信差从办公室的办公桌上取走一些物品，则向信差和办公室中的同事交代自己的意图，将提高信差顺利完成这项工作的概率。</p><h3 id="7-1-2-函数原型和函数调用"><a href="#7-1-2-函数原型和函数调用" class="headerlink" title="7.1.2    函数原型和函数调用"></a>7.1.2    函数原型和函数调用</h3><p>咱们对函数调用这个知识点是很熟悉的，但是对函数原型并不清楚，函数原型通常隐藏在include文件中。</p><p>　<a href="https://www.baidu.com/s?wd=函数声明&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">函数声明</a>由函数返回类型、函数名和形参列表组成。形参列表必须包括形参类型,但是不必对形参命名。这三个元素被称为函数原型,函数原型描述了函数的接口。</p><h4 id="1-为什么需要原型"><a href="#1-为什么需要原型" class="headerlink" title="1.为什么需要原型"></a>1.为什么需要原型</h4><p>原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> volume = cube(side);</span><br></pre></td></tr></table></figure><p>首先，原型告诉编译器，cube()有一个double 参数。如果程序没有提供这样的参数，原型将让编译器能够捕获这种错误。其次，cube()函数完成计算后，将把返回值放置在指定的位置——可能是CPU寄存器，也可能是内存中。然后调用函数（这里为main()）将从这个位置取得返回值。由于原型指出了cube()的类型为double，因此编译器知道应检索多少个字节以及如何解释它们。如果没有这些信息，编译器将只能进行猜测，而编译器是不会这样做的。</p><p>编译器需要原型，因为这样将提高效率，让编译器在广大的文件里找有用的文件，是一件大海捞针的事儿，且编译器在搜索文件的时候将必须停止 对main()的编译。一个更严重的问题是，函数甚至可能并不在项目的文件中（C++允许将一个程序放在多个文件中，单独编译他们，然后再将它们组合起来），在这种情况下，可能导致编译器在编译main()时无权访问函数代码。如果函数位于库中，情况也将如此。</p><p>综上，避免使用函数原型的唯一办法就是，在首次使用函数之前定义它，但这并不总是可行的。</p><h4 id="2-原型的语法"><a href="#2-原型的语法" class="headerlink" title="2.原型的语法"></a>2.原型的语法</h4><p>函数原型是一条语句，因此必须以分号结束。获取原型的方法就是，复制函数定义中的函数头，并添加分号即可。</p><h4 id="3-原型的功能"><a href="#3-原型的功能" class="headerlink" title="3.原型的功能"></a>3.原型的功能</h4><p>可以极大地降低程序出错的几率。</p><p>原型应确保以下几点：</p><ul><li>编译器正确处理函数返回值</li><li>编译器检查使用的参数数目是否正确</li><li>编译器检查使用的参数类型是否正确。如果不正确，则转换为正确的类型（如果可能的话）。</li></ul><h4 id="讲一讲参数数目不对时将发生的情况"><a href="#讲一讲参数数目不对时将发生的情况" class="headerlink" title="讲一讲参数数目不对时将发生的情况"></a>讲一讲参数数目不对时将发生的情况</h4><p>例如，假设进行了如下调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> z = cube();</span><br></pre></td></tr></table></figure><p>如果没有函数原型，编译器将允许它通过。当函数被调用时，它将找到cube()调用存放值的位置，并使用这里的值。这个正式C语言从C++借鉴原型之前的工作方式。对于ANSI C（美国国家标准规定的C语言）来讲，原型是可选的，因此有些C语言程序正是这样工作的。但在C++中，原型是不可选。因此保证了不会发生这种错误。</p><p>接下来，我们假设提供了一个参数，但是它的类型不正确。在C语言中，这将造成奇怪的错误，例如，如果函数需要一个int值（假设占16位），而程序员传递了一个double值（假设占64位），则函数将只检查64位中的前16位，并试图将它们解释为一个int值。但是C++自动将传递的值转换为原型中指定的类型，条件是两者都是算数类型。</p><p>这个时候我来举个例子吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cheers</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cube</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    cheers(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Give me a number: "</span>;</span><br><span class="line">    <span class="keyword">double</span> side;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; side;</span><br><span class="line">    <span class="keyword">double</span> volume = cube(side);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span> &lt;&lt; side &lt;&lt; <span class="string">"-foot cube has a volume of "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; volume &lt;&lt; <span class="string">" cubic feet.\n"</span>;</span><br><span class="line">    cheers(cube(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cheers</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Cheers! "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cube</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是C++的代码</p><p>这个代码就能够应付下述语句中两次出现的类型不匹配的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cheers(cube(<span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>代码讲解：首先程序将int的值2传递给cube()，而后者期望的是double类型。编译器注意到，cube()原型指定了一个double类型参数，因此将2转化为2.0（一个double值）。接下来cube()返回一个double值(8.0)，这个值被用作cheer()的参数。编译器将再一次检查原型，并发现cheer()要求一个int参数，因此它将返回值转换为整数8.通常原型自动将被传递的参数强制转换为期望的类型</p><p>​    自动类型转换并不能避免所有可能的错误。例如，如果将8.33E27传递给期望一个int值的函数，则这样大的值将不能正确转换为int值。当较大的类型被自动转换为较小的类型时，有些编译器将发生警告，指出这可能丢失数据。</p><p>​    仅当有意义的时候，原型才会导致类型转换。正如原型不会将整数转换为结构或指针。</p><p>在编译阶段进行的原型化被称为静态类型检查(static type checking)。可以看出，静态类型检查可捕获许多在运行阶段非常难以捕获的错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C++自带一个包含函数的大型库（标准ANSI库加上多个C++类），但真正的编程乐趣在于编写自己的函数；另一方面，要提高编程效率，可以更深入地学习STL和BOOSTC++提供的功能。&lt;/p&gt;
&lt;h2 id=&quot;7-1-复习函数的基本知识&quot;&gt;&lt;a href=&quot;#7-1-复习函数的
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="C++" scheme="https://mr8god.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>URI URL统一资源标识符</title>
    <link href="https://mr8god.cn/2020/03/22/%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/URI%20URL%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E8%AF%86%E7%AC%A6/"/>
    <id>https://mr8god.cn/2020/03/22/%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/URI%20URL%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E8%AF%86%E7%AC%A6/</id>
    <published>2020-03-22T05:04:38.809Z</published>
    <updated>2020-03-29T14:25:41.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="URI（Uniform-Resource-Identifier"><a href="#URI（Uniform-Resource-Identifier" class="headerlink" title="URI（Uniform Resource Identifier)"></a>URI（Uniform Resource Identifier)</h2><p>采用一种特定语法标识一个资源的字符串</p><p><strong>格式：</strong></p><p>模式：模式特定部分（模式特定部分的语法取决于所用的模式）</p><p>模式包括：</p><p>由小写字母、数字和加号、点及连号符组成</p><p>data链接中直接包含的Base64编码数据</p><p>file本地磁盘的文件</p><p>ftp FTP服务器</p><p>HTTP使用超文本传输协议的国际互联网服务器</p><p>mailto电子邮件地址</p><p>magnet可以通过对等网络下载的资源</p><p>Telnet与基于Telnet的服务连接</p><p><strong>模式特定部分包扩：</strong></p><p><strong>//authority/path?query(//授权机构/路径？查询字符串)</strong></p><p>由ASCII字母数字符号组成，还可以使用标点符号-、_、·、!、~</p><p>定界符（/、？、&amp;、=）可以有其预定义用途</p><p>所有其他字符及内容中需用到的定界符也应用%转义（空格%20/%2F)</p><p><strong>authority</strong>:负责解析该URI其余部分的授权机构 授权机构是Internet主机，还可提供可选的用户名和端口 如：ftp://mp3:mp3@ci43198-a.ashvill.nc.home.com:33/VanHalen-Jump.mp3</p><p><strong>path</strong>:授权机构用来确定所标识资源的字符串</p><h2 id="URL最常见的URI"><a href="#URL最常见的URI" class="headerlink" title="URL最常见的URI"></a>URL最常见的URI</h2><p>两者区别：URI表示资源是什么，URL表示资源的具体位置，URI是URL的抽象。Java中URL对象对应网络获取的应用层协议的一个表示，而URI对象纯粹用于解析和处理字符串。</p><h3 id="绝对URL"><a href="#绝对URL" class="headerlink" title="绝对URL"></a>绝对URL</h3><p><strong>protocol://userInfo@host.port/path?query#fragment</strong></p><p>host 提供所需资源服务区的名字（主机/服务器ip地址）</p><p>userInfo 可选，服务器登录信息</p><p>port 可选，服务在其默认端口运行，无需此部分</p><p>path 指定服务器上的一个特定目录文件系统，路径相对于服务器的文档跟目录，向公众开放的服务器不会将其整个文件系统展示给客户端，而只是展示指定目录中的内容</p><p>query 向服务器提供附加参数，一般只在http URL中使用，其中包含表单数据，作为输入提供给服务端的运行程序</p><p>fragment 指向远程资源的某个特定部分 HTML 锚 XML XPointer  段  ref     片段标识符在HTML文档中用id属性创建 </p><p>包含片段标识符的是URL引用，不是URL</p><h3 id="相对URL继承了-父文档部分信息的URL"><a href="#相对URL继承了-父文档部分信息的URL" class="headerlink" title="相对URL继承了 父文档部分信息的URL"></a>相对URL继承了 父文档部分信息的URL</h3><p>在相对URL中，缺少的各部分都与所在文档的URL中对应的部分相同</p><p>例如浏览<a href="http://www.ibiblio.org/java/faq/javatutoial.html时" target="_blank" rel="noopener">http://www.ibiblio.org/java/faq/javatutoial.html时</a></p><p><strong>若无”/“开头</strong> 例如<a href="javafaq.html"></p><p>相当于<a href="http://www.ibiblio.org/java/faq/javafaq.html" target="_blank" rel="noopener">http://www.ibiblio.org/java/faq/javafaq.html</a></p><p><strong>若以”/“开头</strong> 如<a href="/projects/ipv61"></p><p>则相当于<a href="http://www.ibiblio.org/projects/ipv61" target="_blank" rel="noopener">http://www.ibiblio.org/projects/ipv61</a></p><p>相对URL允许用多种协议来提供一个文档树，且相对URL允许将整个文档树从一个网站移动或复制到另一个网站，而不会破坏所有的内部连接。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;URI（Uniform-Resource-Identifier&quot;&gt;&lt;a href=&quot;#URI（Uniform-Resource-Identifier&quot; class=&quot;headerlink&quot; title=&quot;URI（Uniform Resource Identifie
      
    
    </summary>
    
    
      <category term="网站开发" scheme="https://mr8god.cn/categories/%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端技术" scheme="https://mr8god.cn/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议通信的学习</title>
    <link href="https://mr8god.cn/2020/03/22/%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/HTTP%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>https://mr8god.cn/2020/03/22/%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/HTTP%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-03-22T04:07:46.484Z</published>
    <updated>2020-03-29T14:25:15.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h2><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。。</p><p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p><h2 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h2><p>HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。</p><p>Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。</p><p>Web服务器根据接收到的请求后，向客户端发送响应信息。</p><p>HTTP默认端口号为80，但是你也可以改为8080或者其他端口。</p><p><strong>HTTP三点注意事项</strong></p><ul><li><p>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p></li><li><p>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</p><p><strong>注释：</strong>MIME Type 是该资源的媒体类型，MIME Type 不是个人指定的，是经过互联网（IETF）组织协商，以 RFC（是一系列以编号排定的文件，几乎所有的互联网标准都有收录在其中） 的形式作为建议的标准发布在网上的，大多数的 Web 服务器和用户代理都会支持这个规范 (顺便说一句，Email 附件的类型也是通过 MIME Type 指定的)。</p><p>媒体类型通常通过HTTP协议，由web服务器告知浏览器的，更准确地说，是通过Content-Type来表示的。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type:text/HTML</span><br></pre></td></tr></table></figure><p>通常只有一些互联网上获得广泛应用的格式才会获得一个 MIME Type，如果是某个客户端自己定义的格式，一般只能以 application/x- 开头</p></li><li><p>HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p></li></ul><p>下图表展示了HTTP协议通信流程：</p><p><img src="https://i.loli.net/2020/03/22/secZDlrKfSwNTvb.gif" alt="cgiarch_1_.gif"></p><h2 id="HTTP消息结构"><a href="#HTTP消息结构" class="headerlink" title="HTTP消息结构"></a>HTTP消息结构</h2><p>HTTP是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。</p><p>一个HTTP”客户端”是一个应用程序（Web浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个HTTP的请求的目的。</p><p>一个HTTP”服务器”同样也是一个应用程序（通常是一个Web服务，如Apache Web服务器或IIS服务器等），通过接收客户端的请求并向客户端发送HTTP响应数据。</p><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</p><p>一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式[RFC5322]和多用途Internet邮件扩展（MIME）[RFC2045]来传送。</p><h3 id="HTTP协议的8种请求类型介绍"><a href="#HTTP协议的8种请求类型介绍" class="headerlink" title="HTTP协议的8种请求类型介绍"></a>HTTP协议的8种请求类型介绍</h3><p>HTTP协议中共定义了八种方法或者叫“动作”来表明对Request-URI指定的资源的不同操作方式，具体介绍如下：</p><ul><li>OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向web服务器发送’*’的请求来测试服务器的功能性。</li><li>HEAD：向服务器所要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息</li><li>GET：向特定的资源发出请求</li><li>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。</li><li>PUT：向指定资源位置上传其最新内容。</li><li>DELETE：请求服务器删除Request-URI所标识的资源。</li><li>TRACE：回显服务器收到的请求，主要用于测试或诊断。</li><li>CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</li></ul><p>虽然HTTP的请求方式有8种，但是我们在实际应用中最常用的也就是<strong>GET</strong>和<strong>POST</strong>，其他请求方式也都可以通过这两种方式间接的来实现。</p><h3 id="客户端请求消息"><a href="#客户端请求消息" class="headerlink" title="客户端请求消息"></a>客户端请求消息</h3><p><strong>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。</strong></p><p><img src="https://i.loli.net/2020/03/22/8oeG6YnhLCUt4Z1.png" alt="2012072810301161_1_.png"></p><h3 id="服务器响应消息"><a href="#服务器响应消息" class="headerlink" title="服务器响应消息"></a>服务器响应消息</h3><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p><p><img src="https://i.loli.net/2020/03/22/xIbszqLNDGXg351.jpg" alt="httpmessage_1_.jpg"></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面实例是一点典型的使用GET来传递数据的实例：</p><p>客户端请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /hello.txt HTTP/<span class="number">1.1</span></span><br><span class="line">User-Agent: curl/<span class="number">7.16</span><span class="number">.3</span> libcurl/<span class="number">7.16</span><span class="number">.3</span> OpenSSL/<span class="number">0.9</span><span class="number">.7l</span> zlib/<span class="number">1.2</span><span class="number">.3</span></span><br><span class="line">Host: www.example.com</span><br><span class="line">Accept-Language: en, mi</span><br></pre></td></tr></table></figure><p>服务端响应：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Date: Mon, <span class="number">27</span> Jul <span class="number">2009</span> <span class="number">12</span>:<span class="number">28</span>:<span class="number">53</span> GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Last-Modified: Wed, <span class="number">22</span> Jul <span class="number">2009</span> <span class="number">19</span>:<span class="number">15</span>:<span class="number">56</span> GMT</span><br><span class="line">ETag: <span class="string">"34aa387-d-1568eb00"</span></span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: <span class="number">51</span></span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World！ My payload includes a trailing CRLF.</span><br></pre></td></tr></table></figure><h2 id="HTTP请求方式"><a href="#HTTP请求方式" class="headerlink" title="HTTP请求方式"></a>HTTP请求方式</h2><p>根据HTTP标准，HTTP请求可以使用多种请求方法。</p><p>HTTP1.0定义了三种请求方法：GET，POST和HEAD方法。</p><p>HTTP1.1新增了六种请求方法OPTIONS,PUT,PATCH,DELETE,TRACE和CONNECT方法。</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">GET</td><td style="text-align:left">请求指定的页面信息，并返回实体主体。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">HEAD</td><td style="text-align:left">类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">POST</td><td style="text-align:left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">PUT</td><td style="text-align:left">从客户端向服务器传送的数据取代指定的文档的内容。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">DELETE</td><td style="text-align:left">请求服务器删除指定的页面。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">CONNECT</td><td style="text-align:left">HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">OPTIONS</td><td style="text-align:left">允许客户端查看服务器的性能。</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">TRACE</td><td style="text-align:left">回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left">PATCH</td><td style="text-align:left">是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td></tr></tbody></table></div><h2 id="HTTP响应头信息"><a href="#HTTP响应头信息" class="headerlink" title="HTTP响应头信息"></a>HTTP响应头信息</h2><p>HTTP请求头提供了关于请求，响应或者其他的发送实体的信息。</p><p>在本章节中我们将具体来介绍HTTP响应头信息。</p><div class="table-container"><table><thead><tr><th style="text-align:left">应答头</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Allow</td><td style="text-align:left">服务器支持哪些请求方法（如GET、POST等）。</td></tr><tr><td style="text-align:left">Content-Encoding</td><td style="text-align:left">文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</td></tr><tr><td style="text-align:left">Content-Length</td><td style="text-align:left">表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</td></tr><tr><td style="text-align:left">Content-Type</td><td style="text-align:left">表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</td></tr><tr><td style="text-align:left">Date</td><td style="text-align:left">当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</td></tr><tr><td style="text-align:left">Expires</td><td style="text-align:left">应该在什么时候认为文档已经过期，从而不再缓存它？</td></tr><tr><td style="text-align:left">Last-Modified</td><td style="text-align:left">文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</td></tr><tr><td style="text-align:left">Location</td><td style="text-align:left">表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</td></tr><tr><td style="text-align:left">Refresh</td><td style="text-align:left">表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<a href="http://host/path&quot;)让浏览器读取指定的页面。" target="_blank" rel="noopener">http://host/path&quot;)让浏览器读取指定的页面。</a>  注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=<a href="http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。" target="_blank" rel="noopener">http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。</a>   注意Refresh的意义是”N秒之后刷新本页面或访问指定页面”，而不是”每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=”Refresh” …＞。   注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</td></tr><tr><td style="text-align:left">Server</td><td style="text-align:left">服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</td></tr><tr><td style="text-align:left">Set-Cookie</td><td style="text-align:left">设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</td></tr><tr><td style="text-align:left">WWW-Authenticate</td><td style="text-align:left">客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。  注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</td></tr></tbody></table></div><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。</p><p>HTTP状态码的英文为HTTP Status Code。</p><p>下面是常见的HTTP状态码：</p><ul><li>200 - 请求成功</li><li>301 - 资源（网页等）被永久转移到其它URL</li><li>404 - 请求的资源（网页等）不存在</li><li>500 - 内部服务器错误</li></ul><h3 id="HTTP状态码分类"><a href="#HTTP状态码分类" class="headerlink" title="HTTP状态码分类"></a>HTTP状态码分类</h3><p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：</p><div class="table-container"><table><thead><tr><th style="text-align:left">分类</th><th style="text-align:left">分类描述</th></tr></thead><tbody><tr><td style="text-align:left">1**</td><td style="text-align:left">信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td style="text-align:left">2**</td><td style="text-align:left">成功，操作被成功接收并处理</td></tr><tr><td style="text-align:left">3**</td><td style="text-align:left">重定向，需要进一步的操作以完成请求</td></tr><tr><td style="text-align:left">4**</td><td style="text-align:left">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td style="text-align:left">5**</td><td style="text-align:left">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table></div><h3 id="HTTP状态码列表"><a href="#HTTP状态码列表" class="headerlink" title="HTTP状态码列表"></a>HTTP状态码列表</h3><div class="table-container"><table><thead><tr><th>状态码</th><th>状态码英文名称</th><th>中文描述</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>继续。<a href="http://www.dreamdu.com/webbuild/client_vs_server/" target="_blank" rel="noopener">客户端</a>应继续其请求</td></tr><tr><td>101</td><td>Switching Protocols</td><td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td></td><td></td><td></td></tr><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET与POST请求</td></tr><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>已接受。已经接受请求，但未处理完成</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>205</td><td>Reset Content</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td>206</td><td>Partial Content</td><td>部分内容。服务器成功处理了部分GET请求</td></tr><tr><td></td><td></td><td></td></tr><tr><td>300</td><td>Multiple Choices</td><td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td>查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>305</td><td>Use Proxy</td><td>使用代理。所请求的资源必须通过代理访问</td></tr><tr><td>306</td><td>Unused</td><td>已经被废弃的HTTP状态码</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td></td><td></td><td></td></tr><tr><td>400</td><td>Bad Request</td><td>客户端请求的语法错误，服务器无法理解</td></tr><tr><td>401</td><td>Unauthorized</td><td>请求要求用户的身份认证</td></tr><tr><td>402</td><td>Payment Required</td><td>保留，将来使用</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>客户端请求中的方法被禁止</td></tr><tr><td>406</td><td>Not Acceptable</td><td>服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td>408</td><td>Request Time-out</td><td>服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td>409</td><td>Conflict</td><td>服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td>410</td><td>Gone</td><td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td>411</td><td>Length Required</td><td>服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td>412</td><td>Precondition Failed</td><td>客户端请求信息的先决条件错误</td></tr><tr><td>413</td><td>Request Entity Too Large</td><td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td>414</td><td>Request-URI Too Large</td><td>请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>服务器无法处理请求附带的媒体格式</td></tr><tr><td>416</td><td>Requested range not satisfiable</td><td>客户端请求的范围无效</td></tr><tr><td>417</td><td>Expectation Failed</td><td>服务器无法满足Expect的请求头信息</td></tr><tr><td></td><td></td><td></td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td>504</td><td>Gateway Time-out</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td>505</td><td>HTTP Version not supported</td><td>服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table></div><h2 id="HTTP-content-type"><a href="#HTTP-content-type" class="headerlink" title="HTTP content-type"></a>HTTP content-type</h2><p>Content-Type（内容类型），一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些PHP网页点击的结果却是下载一个文件或一张图片的原因。</p><p>Content-Type标头告诉客户端实际返回的内容的内容类型。</p><p>语法格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf<span class="number">-8</span></span><br><span class="line">Content-Type: multipart/form-data; boundary=something</span><br></pre></td></tr></table></figure><p>实例：</p><p><img src="https://i.loli.net/2020/03/22/MIPzbna15prGkQ7.jpg" alt="F7E193D6-3C08-4B97-BAF2-FF340DAA5C6E_1_.jpg"></p><p>常见的媒体格式类型如下：</p><ul><li>text/html ： HTML格式</li><li>text/plain ：纯文本格式</li><li>text/xml ： XML格式</li><li>image/gif ：gif图片格式</li><li>image/jpeg ：jpg图片格式</li><li>image/png：png图片格式</li></ul><p>以application开头的媒体格式类型：</p><ul><li>application/xhtml+xml ：XHTML格式</li><li>application/xml： XML数据格式</li><li>application/atom+xml ：Atom XML聚合格式</li><li>application/json： JSON数据格式</li><li>application/pdf：pdf格式</li><li>application/msword ： Word文档格式</li><li>application/octet-stream ： 二进制流数据（如常见的文件下载）</li><li>application/x-www-form-urlencoded ： <form encType="">中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）</li></ul><p>另外一种常见的媒体格式是上传文件之时使用的：</p><ul><li>multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式</li></ul><h3 id="HTTP-content-type对照表"><a href="#HTTP-content-type对照表" class="headerlink" title="HTTP content-type对照表"></a>HTTP content-type对照表</h3><div class="table-container"><table><thead><tr><th>文件扩展名</th><th>Content-Type(Mime-Type)</th><th>文件扩展名</th><th>Content-Type(Mime-Type)</th></tr></thead><tbody><tr><td>.*（ 二进制流，不知道下载文件类型）</td><td>application/octet-stream</td><td>.tif</td><td>image/tiff</td></tr><tr><td>.001</td><td>application/x-001</td><td>.301</td><td>application/x-301</td></tr><tr><td>.323</td><td>text/h323</td><td>.906</td><td>application/x-906</td></tr><tr><td>.907</td><td>drawing/907</td><td>.a11</td><td>application/x-a11</td></tr><tr><td>.acp</td><td>audio/x-mei-aac</td><td>.ai</td><td>application/postscript</td></tr><tr><td>.aif</td><td>audio/aiff</td><td>.aifc</td><td>audio/aiff</td></tr><tr><td>.aiff</td><td>audio/aiff</td><td>.anv</td><td>application/x-anv</td></tr><tr><td>.asa</td><td>text/asa</td><td>.asf</td><td>video/x-ms-asf</td></tr><tr><td>.asp</td><td>text/asp</td><td>.asx</td><td>video/x-ms-asf</td></tr><tr><td>.au</td><td>audio/basic</td><td>.avi</td><td>video/avi</td></tr><tr><td>.awf</td><td>application/vnd.adobe.workflow</td><td>.biz</td><td>text/xml</td></tr><tr><td>.bmp</td><td>application/x-bmp</td><td>.bot</td><td>application/x-bot</td></tr><tr><td>.c4t</td><td>application/x-c4t</td><td>.c90</td><td>application/x-c90</td></tr><tr><td>.cal</td><td>application/x-cals</td><td>.cat</td><td>application/vnd.ms-pki.seccat</td></tr><tr><td>.cdf</td><td>application/x-netcdf</td><td>.cdr</td><td>application/x-cdr</td></tr><tr><td>.cel</td><td>application/x-cel</td><td>.cer</td><td>application/x-x509-ca-cert</td></tr><tr><td>.cg4</td><td>application/x-g4</td><td>.cgm</td><td>application/x-cgm</td></tr><tr><td>.cit</td><td>application/x-cit</td><td>.class</td><td>java/*</td></tr><tr><td>.cml</td><td>text/xml</td><td>.cmp</td><td>application/x-cmp</td></tr><tr><td>.cmx</td><td>application/x-cmx</td><td>.cot</td><td>application/x-cot</td></tr><tr><td>.crl</td><td>application/pkix-crl</td><td>.crt</td><td>application/x-x509-ca-cert</td></tr><tr><td>.csi</td><td>application/x-csi</td><td>.css</td><td>text/css</td></tr><tr><td>.cut</td><td>application/x-cut</td><td>.dbf</td><td>application/x-dbf</td></tr><tr><td>.dbm</td><td>application/x-dbm</td><td>.dbx</td><td>application/x-dbx</td></tr><tr><td>.dcd</td><td>text/xml</td><td>.dcx</td><td>application/x-dcx</td></tr><tr><td>.der</td><td>application/x-x509-ca-cert</td><td>.dgn</td><td>application/x-dgn</td></tr><tr><td>.dib</td><td>application/x-dib</td><td>.dll</td><td>application/x-msdownload</td></tr><tr><td>.doc</td><td>application/msword</td><td>.dot</td><td>application/msword</td></tr><tr><td>.drw</td><td>application/x-drw</td><td>.dtd</td><td>text/xml</td></tr><tr><td>.dwf</td><td>Model/vnd.dwf</td><td>.dwf</td><td>application/x-dwf</td></tr><tr><td>.dwg</td><td>application/x-dwg</td><td>.dxb</td><td>application/x-dxb</td></tr><tr><td>.dxf</td><td>application/x-dxf</td><td>.edn</td><td>application/vnd.adobe.edn</td></tr><tr><td>.emf</td><td>application/x-emf</td><td>.eml</td><td>message/rfc822</td></tr><tr><td>.ent</td><td>text/xml</td><td>.epi</td><td>application/x-epi</td></tr><tr><td>.eps</td><td>application/x-ps</td><td>.eps</td><td>application/postscript</td></tr><tr><td>.etd</td><td>application/x-ebx</td><td>.exe</td><td>application/x-msdownload</td></tr><tr><td>.fax</td><td>image/fax</td><td>.fdf</td><td>application/vnd.fdf</td></tr><tr><td>.fif</td><td>application/fractals</td><td>.fo</td><td>text/xml</td></tr><tr><td>.frm</td><td>application/x-frm</td><td>.g4</td><td>application/x-g4</td></tr><tr><td>.gbr</td><td>application/x-gbr</td><td>.</td><td>application/x-</td></tr><tr><td>.gif</td><td>image/gif</td><td>.gl2</td><td>application/x-gl2</td></tr><tr><td>.gp4</td><td>application/x-gp4</td><td>.hgl</td><td>application/x-hgl</td></tr><tr><td>.hmr</td><td>application/x-hmr</td><td>.hpg</td><td>application/x-hpgl</td></tr><tr><td>.hpl</td><td>application/x-hpl</td><td>.hqx</td><td>application/mac-binhex40</td></tr><tr><td>.hrf</td><td>application/x-hrf</td><td>.hta</td><td>application/hta</td></tr><tr><td>.htc</td><td>text/x-component</td><td>.htm</td><td>text/html</td></tr><tr><td>.html</td><td>text/html</td><td>.htt</td><td>text/webviewhtml</td></tr><tr><td>.htx</td><td>text/html</td><td>.icb</td><td>application/x-icb</td></tr><tr><td>.ico</td><td>image/x-icon</td><td>.ico</td><td>application/x-ico</td></tr><tr><td>.iff</td><td>application/x-iff</td><td>.ig4</td><td>application/x-g4</td></tr><tr><td>.igs</td><td>application/x-igs</td><td>.iii</td><td>application/x-iphone</td></tr><tr><td>.img</td><td>application/x-img</td><td>.ins</td><td>application/x-internet-signup</td></tr><tr><td>.isp</td><td>application/x-internet-signup</td><td>.IVF</td><td>video/x-ivf</td></tr><tr><td>.java</td><td>java/*</td><td>.jfif</td><td>image/jpeg</td></tr><tr><td>.jpe</td><td>image/jpeg</td><td>.jpe</td><td>application/x-jpe</td></tr><tr><td>.jpeg</td><td>image/jpeg</td><td>.jpg</td><td>image/jpeg</td></tr><tr><td>.jpg</td><td>application/x-jpg</td><td>.js</td><td>application/x-javascript</td></tr><tr><td>.jsp</td><td>text/html</td><td>.la1</td><td>audio/x-liquid-file</td></tr><tr><td>.lar</td><td>application/x-laplayer-reg</td><td>.latex</td><td>application/x-latex</td></tr><tr><td>.lavs</td><td>audio/x-liquid-secure</td><td>.lbm</td><td>application/x-lbm</td></tr><tr><td>.lmsff</td><td>audio/x-la-lms</td><td>.ls</td><td>application/x-javascript</td></tr><tr><td>.ltr</td><td>application/x-ltr</td><td>.m1v</td><td>video/x-mpeg</td></tr><tr><td>.m2v</td><td>video/x-mpeg</td><td>.m3u</td><td>audio/mpegurl</td></tr><tr><td>.m4e</td><td>video/mpeg4</td><td>.mac</td><td>application/x-mac</td></tr><tr><td>.man</td><td>application/x-troff-man</td><td>.math</td><td>text/xml</td></tr><tr><td>.mdb</td><td>application/msaccess</td><td>.mdb</td><td>application/x-mdb</td></tr><tr><td>.mfp</td><td>application/x-shockwave-flash</td><td>.mht</td><td>message/rfc822</td></tr><tr><td>.mhtml</td><td>message/rfc822</td><td>.mi</td><td>application/x-mi</td></tr><tr><td>.mid</td><td>audio/mid</td><td>.midi</td><td>audio/mid</td></tr><tr><td>.mil</td><td>application/x-mil</td><td>.mml</td><td>text/xml</td></tr><tr><td>.mnd</td><td>audio/x-musicnet-download</td><td>.mns</td><td>audio/x-musicnet-stream</td></tr><tr><td>.mocha</td><td>application/x-javascript</td><td>.movie</td><td>video/x-sgi-movie</td></tr><tr><td>.mp1</td><td>audio/mp1</td><td>.mp2</td><td>audio/mp2</td></tr><tr><td>.mp2v</td><td>video/mpeg</td><td>.mp3</td><td>audio/mp3</td></tr><tr><td>.mp4</td><td>video/mpeg4</td><td>.mpa</td><td>video/x-mpg</td></tr><tr><td>.mpd</td><td>application/vnd.ms-project</td><td>.mpe</td><td>video/x-mpeg</td></tr><tr><td>.mpeg</td><td>video/mpg</td><td>.mpg</td><td>video/mpg</td></tr><tr><td>.mpga</td><td>audio/rn-mpeg</td><td>.mpp</td><td>application/vnd.ms-project</td></tr><tr><td>.mps</td><td>video/x-mpeg</td><td>.mpt</td><td>application/vnd.ms-project</td></tr><tr><td>.mpv</td><td>video/mpg</td><td>.mpv2</td><td>video/mpeg</td></tr><tr><td>.mpw</td><td>application/vnd.ms-project</td><td>.mpx</td><td>application/vnd.ms-project</td></tr><tr><td>.mtx</td><td>text/xml</td><td>.mxp</td><td>application/x-mmxp</td></tr><tr><td>.net</td><td>image/pnetvue</td><td>.nrf</td><td>application/x-nrf</td></tr><tr><td>.nws</td><td>message/rfc822</td><td>.odc</td><td>text/x-ms-odc</td></tr><tr><td>.out</td><td>application/x-out</td><td>.p10</td><td>application/pkcs10</td></tr><tr><td>.p12</td><td>application/x-pkcs12</td><td>.p7b</td><td>application/x-pkcs7-certificates</td></tr><tr><td>.p7c</td><td>application/pkcs7-mime</td><td>.p7m</td><td>application/pkcs7-mime</td></tr><tr><td>.p7r</td><td>application/x-pkcs7-certreqresp</td><td>.p7s</td><td>application/pkcs7-signature</td></tr><tr><td>.pc5</td><td>application/x-pc5</td><td>.pci</td><td>application/x-pci</td></tr><tr><td>.pcl</td><td>application/x-pcl</td><td>.pcx</td><td>application/x-pcx</td></tr><tr><td>.pdf</td><td>application/pdf</td><td>.pdf</td><td>application/pdf</td></tr><tr><td>.pdx</td><td>application/vnd.adobe.pdx</td><td>.pfx</td><td>application/x-pkcs12</td></tr><tr><td>.pgl</td><td>application/x-pgl</td><td>.pic</td><td>application/x-pic</td></tr><tr><td>.pko</td><td>application/vnd.ms-pki.pko</td><td>.pl</td><td>application/x-perl</td></tr><tr><td>.plg</td><td>text/html</td><td>.pls</td><td>audio/scpls</td></tr><tr><td>.plt</td><td>application/x-plt</td><td>.png</td><td>image/png</td></tr><tr><td>.png</td><td>application/x-png</td><td>.pot</td><td>application/vnd.ms-powerpoint</td></tr><tr><td>.ppa</td><td>application/vnd.ms-powerpoint</td><td>.ppm</td><td>application/x-ppm</td></tr><tr><td>.pps</td><td>application/vnd.ms-powerpoint</td><td>.ppt</td><td>application/vnd.ms-powerpoint</td></tr><tr><td>.ppt</td><td>application/x-ppt</td><td>.pr</td><td>application/x-pr</td></tr><tr><td>.prf</td><td>application/pics-rules</td><td>.prn</td><td>application/x-prn</td></tr><tr><td>.prt</td><td>application/x-prt</td><td>.ps</td><td>application/x-ps</td></tr><tr><td>.ps</td><td>application/postscript</td><td>.ptn</td><td>application/x-ptn</td></tr><tr><td>.pwz</td><td>application/vnd.ms-powerpoint</td><td>.r3t</td><td>text/vnd.rn-realtext3d</td></tr><tr><td>.ra</td><td>audio/vnd.rn-realaudio</td><td>.ram</td><td>audio/x-pn-realaudio</td></tr><tr><td>.ras</td><td>application/x-ras</td><td>.rat</td><td>application/rat-file</td></tr><tr><td>.rdf</td><td>text/xml</td><td>.rec</td><td>application/vnd.rn-recording</td></tr><tr><td>.red</td><td>application/x-red</td><td>.rgb</td><td>application/x-rgb</td></tr><tr><td>.rjs</td><td>application/vnd.rn-realsystem-rjs</td><td>.rjt</td><td>application/vnd.rn-realsystem-rjt</td></tr><tr><td>.rlc</td><td>application/x-rlc</td><td>.rle</td><td>application/x-rle</td></tr><tr><td>.rm</td><td>application/vnd.rn-realmedia</td><td>.rmf</td><td>application/vnd.adobe.rmf</td></tr><tr><td>.rmi</td><td>audio/mid</td><td>.rmj</td><td>application/vnd.rn-realsystem-rmj</td></tr><tr><td>.rmm</td><td>audio/x-pn-realaudio</td><td>.rmp</td><td>application/vnd.rn-rn_music_package</td></tr><tr><td>.rms</td><td>application/vnd.rn-realmedia-secure</td><td>.rmvb</td><td>application/vnd.rn-realmedia-vbr</td></tr><tr><td>.rmx</td><td>application/vnd.rn-realsystem-rmx</td><td>.rnx</td><td>application/vnd.rn-realplayer</td></tr><tr><td>.rp</td><td>image/vnd.rn-realpix</td><td>.rpm</td><td>audio/x-pn-realaudio-plugin</td></tr><tr><td>.rsml</td><td>application/vnd.rn-rsml</td><td>.rt</td><td>text/vnd.rn-realtext</td></tr><tr><td>.rtf</td><td>application/msword</td><td>.rtf</td><td>application/x-rtf</td></tr><tr><td>.rv</td><td>video/vnd.rn-realvideo</td><td>.sam</td><td>application/x-sam</td></tr><tr><td>.sat</td><td>application/x-sat</td><td>.sdp</td><td>application/sdp</td></tr><tr><td>.sdw</td><td>application/x-sdw</td><td>.sit</td><td>application/x-stuffit</td></tr><tr><td>.slb</td><td>application/x-slb</td><td>.sld</td><td>application/x-sld</td></tr><tr><td>.slk</td><td>drawing/x-slk</td><td>.smi</td><td>application/smil</td></tr><tr><td>.smil</td><td>application/smil</td><td>.smk</td><td>application/x-smk</td></tr><tr><td>.snd</td><td>audio/basic</td><td>.sol</td><td>text/plain</td></tr><tr><td>.sor</td><td>text/plain</td><td>.spc</td><td>application/x-pkcs7-certificates</td></tr><tr><td>.spl</td><td>application/futuresplash</td><td>.spp</td><td>text/xml</td></tr><tr><td>.ssm</td><td>application/streamingmedia</td><td>.sst</td><td>application/vnd.ms-pki.certstore</td></tr><tr><td>.stl</td><td>application/vnd.ms-pki.stl</td><td>.stm</td><td>text/html</td></tr><tr><td>.sty</td><td>application/x-sty</td><td>.svg</td><td>text/xml</td></tr><tr><td>.swf</td><td>application/x-shockwave-flash</td><td>.tdf</td><td>application/x-tdf</td></tr><tr><td>.tg4</td><td>application/x-tg4</td><td>.tga</td><td>application/x-tga</td></tr><tr><td>.tif</td><td>image/tiff</td><td>.tif</td><td>application/x-tif</td></tr><tr><td>.tiff</td><td>image/tiff</td><td>.tld</td><td>text/xml</td></tr><tr><td>.top</td><td>drawing/x-top</td><td>.torrent</td><td>application/x-bittorrent</td></tr><tr><td>.tsd</td><td>text/xml</td><td>.txt</td><td>text/plain</td></tr><tr><td>.uin</td><td>application/x-icq</td><td>.uls</td><td>text/iuls</td></tr><tr><td>.vcf</td><td>text/x-vcard</td><td>.vda</td><td>application/x-vda</td></tr><tr><td>.vdx</td><td>application/vnd.visio</td><td>.vml</td><td>text/xml</td></tr><tr><td>.vpg</td><td>application/x-vpeg005</td><td>.vsd</td><td>application/vnd.visio</td></tr><tr><td>.vsd</td><td>application/x-vsd</td><td>.vss</td><td>application/vnd.visio</td></tr><tr><td>.vst</td><td>application/vnd.visio</td><td>.vst</td><td>application/x-vst</td></tr><tr><td>.vsw</td><td>application/vnd.visio</td><td>.vsx</td><td>application/vnd.visio</td></tr><tr><td>.vtx</td><td>application/vnd.visio</td><td>.vxml</td><td>text/xml</td></tr><tr><td>.wav</td><td>audio/wav</td><td>.wax</td><td>audio/x-ms-wax</td></tr><tr><td>.wb1</td><td>application/x-wb1</td><td>.wb2</td><td>application/x-wb2</td></tr><tr><td>.wb3</td><td>application/x-wb3</td><td>.wbmp</td><td>image/vnd.wap.wbmp</td></tr><tr><td>.wiz</td><td>application/msword</td><td>.wk3</td><td>application/x-wk3</td></tr><tr><td>.wk4</td><td>application/x-wk4</td><td>.wkq</td><td>application/x-wkq</td></tr><tr><td>.wks</td><td>application/x-wks</td><td>.wm</td><td>video/x-ms-wm</td></tr><tr><td>.wma</td><td>audio/x-ms-wma</td><td>.wmd</td><td>application/x-ms-wmd</td></tr><tr><td>.wmf</td><td>application/x-wmf</td><td>.wml</td><td>text/vnd.wap.wml</td></tr><tr><td>.wmv</td><td>video/x-ms-wmv</td><td>.wmx</td><td>video/x-ms-wmx</td></tr><tr><td>.wmz</td><td>application/x-ms-wmz</td><td>.wp6</td><td>application/x-wp6</td></tr><tr><td>.wpd</td><td>application/x-wpd</td><td>.wpg</td><td>application/x-wpg</td></tr><tr><td>.wpl</td><td>application/vnd.ms-wpl</td><td>.wq1</td><td>application/x-wq1</td></tr><tr><td>.wr1</td><td>application/x-wr1</td><td>.wri</td><td>application/x-wri</td></tr><tr><td>.wrk</td><td>application/x-wrk</td><td>.ws</td><td>application/x-ws</td></tr><tr><td>.ws2</td><td>application/x-ws</td><td>.wsc</td><td>text/scriptlet</td></tr><tr><td>.wsdl</td><td>text/xml</td><td>.wvx</td><td>video/x-ms-wvx</td></tr><tr><td>.xdp</td><td>application/vnd.adobe.xdp</td><td>.xdr</td><td>text/xml</td></tr><tr><td>.xfd</td><td>application/vnd.adobe.xfd</td><td>.xfdf</td><td>application/vnd.adobe.xfdf</td></tr><tr><td>.xhtml</td><td>text/html</td><td>.xls</td><td>application/vnd.ms-excel</td></tr><tr><td>.xls</td><td>application/x-xls</td><td>.xlw</td><td>application/x-xlw</td></tr><tr><td>.xml</td><td>text/xml</td><td>.xpl</td><td>audio/scpls</td></tr><tr><td>.xq</td><td>text/xml</td><td>.xql</td><td>text/xml</td></tr><tr><td>.xquery</td><td>text/xml</td><td>.xsd</td><td>text/xml</td></tr><tr><td>.xsl</td><td>text/xml</td><td>.xslt</td><td>text/xml</td></tr><tr><td>.xwd</td><td>application/x-xwd</td><td>.x_b</td><td>application/x-x_b</td></tr><tr><td>.sis</td><td>application/vnd.symbian.install</td><td>.sisx</td><td>application/vnd.symbian.install</td></tr><tr><td>.x_t</td><td>application/x-x_t</td><td>.ipa</td><td>application/vnd.iphone</td></tr><tr><td>.apk</td><td>application/vnd.android.package-archive</td><td>.xap</td><td>application/x-silverlight-app</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTTP简介&quot;&gt;&lt;a href=&quot;#HTTP简介&quot; class=&quot;headerlink&quot; title=&quot;HTTP简介&quot;&gt;&lt;/a&gt;HTTP简介&lt;/h2&gt;&lt;p&gt;HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维
      
    
    </summary>
    
    
      <category term="网站开发" scheme="https://mr8god.cn/categories/%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端技术" scheme="https://mr8god.cn/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>什么是MIME TYPE？</title>
    <link href="https://mr8god.cn/2020/03/22/%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/%E4%BB%80%E4%B9%88%20%E6%98%AFMIME%20TYPE%EF%BC%9F/"/>
    <id>https://mr8god.cn/2020/03/22/%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/%E4%BB%80%E4%B9%88%20%E6%98%AFMIME%20TYPE%EF%BC%9F/</id>
    <published>2020-03-22T04:00:44.199Z</published>
    <updated>2020-03-29T14:24:35.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h2><p>我们了解浏览器是如何处理内容的 。在浏览器中显示的内容有 HTML、有 XML、有 GIF、还有 Flash ……那么，浏览器是如何区分它们，决定什么内容用什么形式来显示呢？答案是 MIME Type，也就是该资源的媒体类型。</p><p>媒体类型通常是通过HTTP协议，由web服务器告知浏览器的，更准确地说 ，是通过Content-Type来表示的，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-type:text/HTML</span><br></pre></td></tr></table></figure><p>表示内容是 text/HTML 类型，也就是超文本文件。为什么是“text/HTML”而不是“HTML/text”或者别的什么？MIME Type 不是个人指定的，是经过 ietf 组织协商，以 RFC 的形式作为建议的标准发布在网上的，大多数的 Web 服务器和用户代理都会支持这个规范 (顺便说一句，Email 附件的类型也是通过 MIME Type 指定的)。</p><p>通常只有一些在互联网上获得广泛应用的格式才会获得一个 MIME Type，如果是某个客户端自己定义的格式，一般只能以 application/x- 开头。</p><p>XHTML 正是一个获得广泛应用的格式，因此，在 RFC 3236 中，说明了 XHTML 格式文件的 MIME Type 应该是 application/xHTML+XML。</p><p>当然，处理本地的文件，在没有人告诉浏览器某个文件的 MIME Type 的情况下，浏览器也会做一些默认的处理，这可能和你在操作系统中给文件配置的 MIME Type 有关。比如在 Windows 下，打开注册表的“HKEY_LOCAL_MACHINESOFTWAREClassesMIMEDatabaseContent Type”主键，你可以看到所有 MIME Type 的配置信息。</p><h2 id="然后"><a href="#然后" class="headerlink" title="然后"></a>然后</h2><p>在把输出结果传送到浏览器上的时候，浏览器必须启动适当的应用程序来处理这个输出文档。这可以通过多种类型MIME（多功能网际邮件扩充协议）来完成。在HTTP中，MIME类型被定义在Content-Type header中。</p><p>例如，架设你要传送一个Microsoft Excel文件到客户端。那么这时的MIME类型就是“application/vnd.ms-excel”。在大多数实际情况中，这个文件然后将传送给Execl来处理（假设我们设定Execl为处理特殊MIME类型的应用程序）。在ASP中，设定MIME类型的方法是通过Response对象的ContentType属性。</p><p><strong>多媒体文件格式MIME</strong> </p><p>最早的HTTP协议中，并没有附加的数据类型信息，所有传送的数据都被客户程序解释为超文本标记语言HTML 文档，而为了支持多媒体数据类型，HTTP协议中就使用了附加在文档之前的MIME数据类型信息来标识数据类型。</p><p>MIME意为多目Internet邮件扩展，它设计的最初目的是为了在发送电子邮件时附加多媒体数据，让邮件客户程序能根据其类型进行处理。然而当它被HTTP协议支持之后，它的意义就更为显著了。它使得HTTP传输的不仅是普通的文本，而变得丰富多彩。</p><p>每个MIME类型由两部分组成，前面是数据的大类别，例如声音audio、图像image等，后面定义具体的种类。</p><p><strong>常见的MIME类型有</strong></p><p>超文本标记语言文本 .html,.html text/html<br>普通文本 .txt text/plain<br>RTF文本 .rtf application/rtf<br>GIF图形 .gif image/gif<br>JPEG图形 .ipeg,.jpg image/jpeg<br>au声音文件 .au audio/basic<br>MIDI音乐文件 mid,.midi audio/midi,audio/x-midi<br>RealAudio音乐文件 .ra, .ram audio/x-pn-realaudio<br>MPEG文件 .mpg,.mpeg video/mpeg<br>AVI文件 .avi video/x-msvideo<br>GZIP文件 .gz application/x-gzip<br>TAR文件 .tar application/x-tar </p><p>Internet中有一个专门组织IANA来确认标准的MIME类型，但Internet发展的太快，很多应用程序等不及IANA来确认他们使用的MIME类型为标准类型。因此他们使用在类别中以x-开头的方法标识这个类别还没有成为标准，例如：x-gzip，x-tar等。事实上这些类型运用的很广泛，已经成为了事实标准。只要客户机和服务器共同承认这个MIME类型，即使它是不标准的类型也没有关系，客户程序就能根据MIME类型，采用具体的处理手段来处理数据。而Web服务器和浏览器（包括操作系统）中，缺省都设置了标准的和常见的MIME类型，只有对于不常见的 MIME类型，才需要同时设置服务器和客户浏览器，以进行识别。</p><p>由于MIME类型与文档的后缀相关，因此服务器使用文档的后缀来区分不同文件的MIME类型，服务器中必须定义文档后缀和MIME类型之间的对应关系。而客户程序从服务器上接收数据的时候，它只是从服务器接受数据流，并不了解文档的名字，因此服务器必须使用附加信息来告诉客户程序数据的MIME类型。服务器在发送真正的数据之前，就要先发送标志数据的MIME类型的信息，这个信息使用Content-type关键字进行定义，例如对于HTML文档，服务器将首先发送以下两行MIME标识信息,这个标识并不是真正的数据文件的一部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-type:text/html</span><br></pre></td></tr></table></figure><p>注意，第二行为一个空行，这是必须的 ，使用这个空行 的目的是将MIME信息与真正的数据内容分隔开。</p><p>MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准。<br>MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。<br>官方的 MIME 信息是由 Internet Engineering Task Force (IETF) 在下面的文档中提供的：<br>RFC-822 Standard for ARPA Internet text messages</p><p>RFC-2045 MIME Part 1: Format of Internet Message Bodies</p><p>RFC-2046 MIME Part 2: Media Types</p><p>RFC-2047 MIME Part 3: Header Extensions for Non-ASCII Text</p><p>RFC-2048 MIME Part 4: Registration Procedures</p><p>RFC-2049 MIME Part 5: Conformance Criteria and Examples</p><p>不同的应用程序支持不同的 MIME 类型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;首先&quot;&gt;&lt;a href=&quot;#首先&quot; class=&quot;headerlink&quot; title=&quot;首先&quot;&gt;&lt;/a&gt;首先&lt;/h2&gt;&lt;p&gt;我们了解浏览器是如何处理内容的 。在浏览器中显示的内容有 HTML、有 XML、有 GIF、还有 Flash ……那么，浏览器是如何区分它们
      
    
    </summary>
    
    
      <category term="网站开发" scheme="https://mr8god.cn/categories/%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端技术" scheme="https://mr8god.cn/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>以Django框架为基础的网站开发</title>
    <link href="https://mr8god.cn/2020/03/21/Python/%E4%BB%8A%E5%A4%A9%E4%B8%BB%E8%A6%81%E5%BC%80%E5%A7%8B%E6%88%91%E7%9A%84%E4%BB%A5Django%E6%A1%86%E6%9E%B6%E4%B8%BA%E5%9F%BA%E7%A1%80%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E5%95%A6/"/>
    <id>https://mr8god.cn/2020/03/21/Python/%E4%BB%8A%E5%A4%A9%E4%B8%BB%E8%A6%81%E5%BC%80%E5%A7%8B%E6%88%91%E7%9A%84%E4%BB%A5Django%E6%A1%86%E6%9E%B6%E4%B8%BA%E5%9F%BA%E7%A1%80%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E5%95%A6/</id>
    <published>2020-03-21T15:16:36.461Z</published>
    <updated>2020-03-29T14:12:22.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="今天主要开始我的以Django框架为基础的博客开发啦"><a href="#今天主要开始我的以Django框架为基础的博客开发啦" class="headerlink" title="今天主要开始我的以Django框架为基础的博客开发啦"></a>今天主要开始我的以Django框架为基础的博客开发啦</h2><p>说实话，前段时间由于自己的粗心，没有顾及得上，这一次正好乘着长假期，好好做出这个项目，把《Django企业开发实战》这本书看完，哦了，就这么水一天</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;今天主要开始我的以Django框架为基础的博客开发啦&quot;&gt;&lt;a href=&quot;#今天主要开始我的以Django框架为基础的博客开发啦&quot; class=&quot;headerlink&quot; title=&quot;今天主要开始我的以Django框架为基础的博客开发啦&quot;&gt;&lt;/a&gt;今天主要开始我的
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Python" scheme="https://mr8god.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java中的尾递归——尾递归与垃圾回收的比较</title>
    <link href="https://mr8god.cn/2020/03/20/Java/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84%E5%B0%BE%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E5%B0%BE%E9%80%92%E5%BD%92%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>https://mr8god.cn/2020/03/20/Java/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84%E5%B0%BE%E9%80%92%E5%BD%92%E2%80%94%E2%80%94%E5%B0%BE%E9%80%92%E5%BD%92%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E6%AF%94%E8%BE%83/</id>
    <published>2020-03-20T15:18:19.871Z</published>
    <updated>2020-03-29T14:13:35.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、首先说一下什么是递归"><a href="#一、首先说一下什么是递归" class="headerlink" title="一、首先说一下什么是递归"></a>一、首先说一下什么是递归</h2><ol><li>递归的本质是，某个方法调用了本身，本质还是调用一个方法，只是这个方法它恰好就是本身而已</li><li><p>递归因为是在自身中调用自身，所以会有下面三个较为显著的特点：</p><ol><li><p>调用的是同一个方法</p></li><li><p>因为1，所以只需要写一个方法，就可以让你轻松调用无数次，所以调用的方法可大可小，具体取决于你的实际案例</p></li><li><p>在自身中调用自身，是嵌套调用（栈帧无法回收，开销巨大）</p></li></ol></li><li>结合以上2和3的两个特点，所以递归调用最大的诟病就是开销巨大，栈帧和堆有时候会一起爆掉，俗称内存溢出</li><li>既然会导致内存溢出的话，我们就提出了尾递归这样一种解决思路</li></ol><h2 id="二、尾递归优化"><a href="#二、尾递归优化" class="headerlink" title="二、尾递归优化"></a>二、尾递归优化</h2><ol><li><p>尾递归优化是利用上面的第一个特点“调用同一个方法”来进行优化的</p></li><li><p>尾递归优化其实包括两个东西：1）尾递归的形式；2）编译器对尾递归的优化</p><ol><li>尾递归的形式：<ol><li>尾递归其实只是一种对递归的特殊写法，这种写法原本并不会带来跟递归不一样的影响，它只是写法不一样而已，写成这样不会有任何优化效果，该爆的栈和帧都还会爆</li><li>那么具体的不一样体现在哪里呢<ol><li>前面说了，递归的本质是某个方法调用了自身，尾递归这种形式就要求：某个方法调用自身这件事，一定是该方法做的最后一件事（所以当有需要返回值的时候会是return f(n)，没有返回的话就直接是f(n)了）</li></ol></li><li>要求很简单，就是只有一条，但是有一些常见的误区<ol><li>这个f(n)外不能加其他东西，因为这就不是最后一件事了，值返回来后还要再干点其他的活，变量空间还需要保留<ol><li>比如如果有返回值的，你不能：乘个常数 return 3f(n)；乘个n return n*f(n)；甚至是 f(n)+f(n-1)</li></ol></li></ol></li><li>另外，使用return的尾递归还跟函数式编程有一点关系</li></ol></li></ol></li><li><p>为什么写成尾递归的形式，编译器就能优化了？或者说【编译器对尾递归的优化】的一些深层思想</p><ol><li>说是深层思想，其实也是因为正好编译器其实在这里没做什么复杂的事，所以很简单</li><li>由于这两方面的原因，尾递归优化得以实现，而且效果很好<ol><li>因为在递归调用自身的时候，这一层函数已经没有要做的事情了，虽然被递归调用的函数是在当前的函数里，但是他们之间的关系已经在传参的时候了断了，也就是这一层函数的所有变量什么的都不会再被用到了，所以当前函数虽然没有执行完，不能弹出栈，但它确实已经可以出栈了，这是一方面</li><li>另一方面，正因为调用的是自身，所以需要的存储空间是一毛一样的，那干脆重新刷新这些空间给下一层利用就好了，不用销毁再另开空间</li></ol></li><li>有人对写成尾递归形式的说法是【为了告诉编译器这块要尾递归】，这种说法可能会导致误解，因为不是只告诉编译器就行，而是你需要做优化的前半部分，之后编译器做后半部分</li></ol></li><li><p>所以总结：为了解决递归的开销大问题，使用尾递归优化，具体分两步：1）你把递归调用的形式写成尾递归的形式；2）编译器碰到尾递归，自动按照某种特定的方式进行优化编译</p></li><li><p>举例：</p><p>（no尾递归）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">recsum</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="function">  <span class="keyword">if</span> x </span>== <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> x + recsum(x - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>（使用尾递归）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">tailrecsum</span><span class="params">(x, running_total=<span class="number">0</span>)</span>:</span></span><br><span class="line"><span class="function">  <span class="keyword">if</span> x </span>== <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> running_total</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> tailrecsum(x - <span class="number">1</span>, running_total + x)</span><br></pre></td></tr></table></figure></li></ol><p>但不是所有语言的编译器都做了尾递归优化。比如C实现了，JAVA没有去实现</p><p>说到这里你很容易联想到JAVA中的自动垃圾回收机制，同是处理内存问题的机制，尾递归优化跟垃圾回收是不是有什么关系，这是不是就是JAVA不实现尾递归优化的原因？</p><h2 id="三、所以下面要讲一下垃圾回收（GC）"><a href="#三、所以下面要讲一下垃圾回收（GC）" class="headerlink" title="三、所以下面要讲一下垃圾回收（GC）"></a>三、所以下面要讲一下垃圾回收（GC）</h2><ol><li>首先我们需要谈一下内存机制，这里我们需要了解内存机制的两个部分：栈和堆。下面虽然是在说JAVA，但是C也是差不多的<ol><li>在Java中， JVM中的栈记录了线程的方法调用。每个线程拥有一个栈。在某个线程的运行过程中， 如果有新的方法调用，那么该线程对应的栈就会增加一个存储单元，即栈帧 (frame)。在frame 中，保存有该方法调用的参数、局部变量和返回地址</li><li>Java的参数和局部变量只能是 基本类型 的变量(比如 int)，或者对象的引用(reference) 。因此，在栈中，只保存有基本类型的变量和对象引用。而引用所指向的对象保存在堆中。</li></ol></li><li>然后由栈和堆的空间管理方式的不同，引出垃圾回收的概念<ol><li>当被调用方法运行结束时，该方法对应的帧将被删除，参数和局部变量所占据的空间也随之释放。线程回到原方法，继续执行。当所有的栈都清空时，程序也随之运行结束。</li><li>如上所述，栈 (stack)可以自己照顾自己。但堆必须要小心对待。堆是 JVM中一块可自由分配给对象的区域。当我们谈论垃圾回收 (garbage collection) 时，我们主要<strong>回收堆(heap)的空间</strong>。</li><li>Java的普通对象存活在堆中。与栈不同，堆的空间不会随着方法调用结束而清空（即使它在栈上的引用已经被清空了）（也不知道为什么不直接同步清空）。因此，在某个方法中创建的对象，可以在方法调用结束之后，继续存在于堆中。这带来的一个问题是，如果我们不断的创建新的对象，内存空间将最终消耗殆尽。</li><li>如果没有垃圾回收机制的话，你就需要手动地显式分配及释放内存，如果你忘了去释放内存，那么这块内存就无法重用了（不管是什么局部变量还是其他的什么）。这块内存被占有了却没被使用，这种场景被称之为内存泄露</li></ol></li><li>所以不管是C还是JAVA，最原始的情况，都是需要手动释放堆中的对象，C到现在也是这样，所以你经常需要考虑对象的生存周期，但是JAVA则引入了一个自动垃圾回收的机制，它能智能地释放那些被判定已经没有用的对象</li></ol><h2 id="四、现在我们就可以比较一下尾递归优化和垃圾回收了"><a href="#四、现在我们就可以比较一下尾递归优化和垃圾回收了" class="headerlink" title="四、现在我们就可以比较一下尾递归优化和垃圾回收了"></a>四、<strong>现在我们就可以比较一下尾递归优化和垃圾回收了</strong></h2><ol><li><p>富士达他们最本质的区别是，尾递归优化解决的是内存溢出的问题，而垃圾回收解决的是内存泄露的问题</p><ol><li>内存泄露：指程序中动态分配内存给一些临时对象，但是对象不会被GC所回收，它始终占用内存。即被分配的对象可达但已无用。</li><li>内存溢出：指程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。</li><li>从定义上可以看出内存泄露是内存溢出的一种诱因，不是唯一因素。</li></ol></li><li><p>自动垃圾回收机制的特点是：</p><ol><li>解决了所有情况下的内存泄露的问题，但还可以由于其他原因内存溢出</li><li>针对内存中的堆空间</li><li>正在运行的方法中的堆中的对象是不会被管理的，因为还有引用（栈帧没有被清空）<ol><li>一般简单的自动垃圾回收机制是采用 引用计数 (reference counting)的机制。每个对象包含一个计数器。当有新的指向该对象的引用时，计数器加 1。当引用移除时，计数器减 1，当计数器为0时，认为该对象可以进行垃圾回收</li></ol></li></ol></li><li><p>与之相对，尾递归优化的特点是：</p><ol><li><p>优化了递归调用时的内存溢出问题</p></li><li><p>针对内存中的堆空间和栈空间</p></li><li><p>只在递归调用的时候使用，而且只能对于写成尾递归形式的递归进行优化</p></li><li><p>正在运行的方法的堆和栈空间正是优化的目标</p><p>​    </p></li></ol></li></ol><p>最后可以解答一下前头提出的问题</p><ol><li>通过比较可以发现尾递归和GC是完全不一样的，JAVA不会是因为有GC所以不需要尾递归优化。那为什么呢，我看到有的说法是：JAVA编写组不实现尾递归优化是觉得麻烦又没有太大的必要，就懒得实现了（原话是：在日程表上，但是非常靠后），官方的建议是不使用递归，而是使用while循环，迭代，递推</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、首先说一下什么是递归&quot;&gt;&lt;a href=&quot;#一、首先说一下什么是递归&quot; class=&quot;headerlink&quot; title=&quot;一、首先说一下什么是递归&quot;&gt;&lt;/a&gt;一、首先说一下什么是递归&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;递归的本质是，某个方法调用了本身，本质还是调用一
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>概率论与数理统计</title>
    <link href="https://mr8god.cn/2020/03/20/%E6%95%B0%E7%90%86%E7%9F%A5%E8%AF%86/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    <id>https://mr8god.cn/2020/03/20/%E6%95%B0%E7%90%86%E7%9F%A5%E8%AF%86/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/</id>
    <published>2020-03-20T12:40:15.739Z</published>
    <updated>2020-03-31T13:57:07.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章：随机事件及其概率（1）"><a href="#第一章：随机事件及其概率（1）" class="headerlink" title="第一章：随机事件及其概率（1）"></a>第一章：随机事件及其概率（1）</h2><h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><h4 id="样本空间，随机事件"><a href="#样本空间，随机事件" class="headerlink" title="样本空间，随机事件"></a>样本空间，随机事件</h4><h5 id="来自百度百科"><a href="#来自百度百科" class="headerlink" title="来自百度百科"></a>来自百度百科</h5><h6 id="样本空间"><a href="#样本空间" class="headerlink" title="样本空间"></a>样本空间</h6><h6 id="随机事件E的所有基本结果组成的集合为E的样本空间。样本空间的元素称为样本点或基本事件"><a href="#随机事件E的所有基本结果组成的集合为E的样本空间。样本空间的元素称为样本点或基本事件" class="headerlink" title="# 随机事件E的所有基本结果组成的集合为E的样本空间。样本空间的元素称为样本点或基本事件"></a># 随机事件E的所有基本结果组成的集合为E的样本空间。样本空间的元素称为样本点或基本事件</h6><h6 id="举个例子：设随机试验E是”抛一颗骰子，观察出现的点数”。那么E的样本空间就是S：-1-2-3-4-5-6-。"><a href="#举个例子：设随机试验E是”抛一颗骰子，观察出现的点数”。那么E的样本空间就是S：-1-2-3-4-5-6-。" class="headerlink" title="# 举个例子：设随机试验E是”抛一颗骰子，观察出现的点数”。那么E的样本空间就是S：{1,2,3,4,5,6,}。"></a># 举个例子：设随机试验E是”抛一颗骰子，观察出现的点数”。那么E的样本空间就是S：{1,2,3,4,5,6,}。</h6><h6 id="有些实验有两个或多个可能的样本空间。"><a href="#有些实验有两个或多个可能的样本空间。" class="headerlink" title="# 有些实验有两个或多个可能的样本空间。"></a># 有些实验有两个或多个可能的样本空间。</h6><h6 id="举个例子：从52张扑克牌中随机抽出一张，一个可能的样本空间是数字（A到K），另外一个可能的样本空间是花色（黑桃，红桃，梅花，方块）。-如果要完整地描述一张牌，就需要同时给出数字和花色，这时的样本空间可以通过构建上述两个样本空间的笛卡尔乘积来得到。"><a href="#举个例子：从52张扑克牌中随机抽出一张，一个可能的样本空间是数字（A到K），另外一个可能的样本空间是花色（黑桃，红桃，梅花，方块）。-如果要完整地描述一张牌，就需要同时给出数字和花色，这时的样本空间可以通过构建上述两个样本空间的笛卡尔乘积来得到。" class="headerlink" title="## 举个例子：从52张扑克牌中随机抽出一张，一个可能的样本空间是数字（A到K），另外一个可能的样本空间是花色（黑桃，红桃，梅花，方块）。 如果要完整地描述一张牌，就需要同时给出数字和花色，这时的样本空间可以通过构建上述两个样本空间的笛卡尔乘积来得到。"></a>## 举个例子：从52张扑克牌中随机抽出一张，一个可能的样本空间是数字（A到K），另外一个可能的样本空间是花色（黑桃，红桃，梅花，方块）。 如果要完整地描述一张牌，就需要同时给出数字和花色，这时的样本空间可以通过构建上述两个样本空间的笛卡尔乘积来得到。</h6><h6 id="随机事件"><a href="#随机事件" class="headerlink" title="随机事件"></a>随机事件</h6><h6 id="子主题-4"><a href="#子主题-4" class="headerlink" title="# 子主题 4"></a># 子主题 4</h6><h6 id="随机事件是指在随机试验中，可能出现也可能不出现，而在大量重复试验中具有某种规律性的事件叫做随机事件（简称事件）"><a href="#随机事件是指在随机试验中，可能出现也可能不出现，而在大量重复试验中具有某种规律性的事件叫做随机事件（简称事件）" class="headerlink" title="## 随机事件是指在随机试验中，可能出现也可能不出现，而在大量重复试验中具有某种规律性的事件叫做随机事件（简称事件）"></a>## 随机事件是指在随机试验中，可能出现也可能不出现，而在大量重复试验中具有某种规律性的事件叫做随机事件（简称事件）</h6><h6 id="随机试验中的每一个可能出现的试验结果称为这个试验的一个样本点，全体样本点组成的集合称为这个试验的样本空间。"><a href="#随机试验中的每一个可能出现的试验结果称为这个试验的一个样本点，全体样本点组成的集合称为这个试验的样本空间。" class="headerlink" title="## 随机试验中的每一个可能出现的试验结果称为这个试验的一个样本点，全体样本点组成的集合称为这个试验的样本空间。"></a>## 随机试验中的每一个可能出现的试验结果称为这个试验的一个样本点，全体样本点组成的集合称为这个试验的样本空间。</h6><h6 id="仅含一个样本点的随机事件称为基本事件-含有多个样本点的随机事件称为复合事件"><a href="#仅含一个样本点的随机事件称为基本事件-含有多个样本点的随机事件称为复合事件" class="headerlink" title="## 仅含一个样本点的随机事件称为基本事件 含有多个样本点的随机事件称为复合事件"></a>## 仅含一个样本点的随机事件称为基本事件 含有多个样本点的随机事件称为复合事件</h6><h6 id=""><a href="#" class="headerlink" title="#"></a>#</h6><h6 id="特点"><a href="#特点" class="headerlink" title="# 特点"></a># 特点</h6><h6 id="1、可以在相同的条件下重复进行"><a href="#1、可以在相同的条件下重复进行" class="headerlink" title="## 1、可以在相同的条件下重复进行"></a>## 1、可以在相同的条件下重复进行</h6><h6 id="2、每个试验的可能结果不止一个，并且能实现预测试验的所有可能结果"><a href="#2、每个试验的可能结果不止一个，并且能实现预测试验的所有可能结果" class="headerlink" title="## 2、每个试验的可能结果不止一个，并且能实现预测试验的所有可能结果"></a>## 2、每个试验的可能结果不止一个，并且能实现预测试验的所有可能结果</h6><h6 id="3、进行一次试验之前不能确定哪一个结果会出现"><a href="#3、进行一次试验之前不能确定哪一个结果会出现" class="headerlink" title="## 3、进行一次试验之前不能确定哪一个结果会出现"></a>## 3、进行一次试验之前不能确定哪一个结果会出现</h6><h6 id="特殊事件"><a href="#特殊事件" class="headerlink" title="# 特殊事件"></a># 特殊事件</h6><h6 id="必然事件"><a href="#必然事件" class="headerlink" title="## 必然事件"></a>## 必然事件</h6><h6 id="必然事件记作Ω，样本空间Ω也是其自身的一个子集，Ω也是一个”随机”事件，每次试验中必定有Ω中的一个样本点出现，必然发生。"><a href="#必然事件记作Ω，样本空间Ω也是其自身的一个子集，Ω也是一个”随机”事件，每次试验中必定有Ω中的一个样本点出现，必然发生。" class="headerlink" title="### 必然事件记作Ω，样本空间Ω也是其自身的一个子集，Ω也是一个”随机”事件，每次试验中必定有Ω中的一个样本点出现，必然发生。"></a>### 必然事件记作Ω，样本空间Ω也是其自身的一个子集，Ω也是一个”随机”事件，每次试验中必定有Ω中的一个样本点出现，必然发生。</h6><h6 id="不可能事件"><a href="#不可能事件" class="headerlink" title="## 不可能事件"></a>## 不可能事件</h6><h6 id="不可能事件记作Φ，空集Φ也是样本空间的一个子集，Φ也是一个特殊的”随机”事件，不包含任何样本点，不可能发生。"><a href="#不可能事件记作Φ，空集Φ也是样本空间的一个子集，Φ也是一个特殊的”随机”事件，不包含任何样本点，不可能发生。" class="headerlink" title="### 不可能事件记作Φ，空集Φ也是样本空间的一个子集，Φ也是一个特殊的”随机”事件，不包含任何样本点，不可能发生。"></a>### 不可能事件记作Φ，空集Φ也是样本空间的一个子集，Φ也是一个特殊的”随机”事件，不包含任何样本点，不可能发生。</h6><h6 id="事件关系"><a href="#事件关系" class="headerlink" title="# 事件关系"></a># 事件关系</h6><h6 id="事件A是事件B的子事件，事件A发生必然导致事件B发生，事件A的样本点都是事件B的样本点，记作A⊂B。"><a href="#事件A是事件B的子事件，事件A发生必然导致事件B发生，事件A的样本点都是事件B的样本点，记作A⊂B。" class="headerlink" title="## 事件A是事件B的子事件，事件A发生必然导致事件B发生，事件A的样本点都是事件B的样本点，记作A⊂B。"></a>## 事件A是事件B的子事件，事件A发生必然导致事件B发生，事件A的样本点都是事件B的样本点，记作A⊂B。</h6><h6 id="若A⊂B且B⊂A，那么A-B，称A和B为相等事件，事件A与事件B含有相同的样本点。"><a href="#若A⊂B且B⊂A，那么A-B，称A和B为相等事件，事件A与事件B含有相同的样本点。" class="headerlink" title="## 若A⊂B且B⊂A，那么A=B，称A和B为相等事件，事件A与事件B含有相同的样本点。"></a>## 若A⊂B且B⊂A，那么A=B，称A和B为相等事件，事件A与事件B含有相同的样本点。</h6><h6 id="和事件发生，即事件A发生或事件B发生，事件A与事件B至少一个发生，由事件A与事件B所有样本点组成，记作A∪B。"><a href="#和事件发生，即事件A发生或事件B发生，事件A与事件B至少一个发生，由事件A与事件B所有样本点组成，记作A∪B。" class="headerlink" title="## 和事件发生，即事件A发生或事件B发生，事件A与事件B至少一个发生，由事件A与事件B所有样本点组成，记作A∪B。"></a>## 和事件发生，即事件A发生或事件B发生，事件A与事件B至少一个发生，由事件A与事件B所有样本点组成，记作A∪B。</h6><h6 id="积事件发生，即事件A和事件B同时发生，由事件A与事件B的公共样本点组成，记作AB或A∩B。"><a href="#积事件发生，即事件A和事件B同时发生，由事件A与事件B的公共样本点组成，记作AB或A∩B。" class="headerlink" title="## 积事件发生，即事件A和事件B同时发生，由事件A与事件B的公共样本点组成，记作AB或A∩B。"></a>## 积事件发生，即事件A和事件B同时发生，由事件A与事件B的公共样本点组成，记作AB或A∩B。</h6><h6 id="事件种类"><a href="#事件种类" class="headerlink" title="# 事件种类"></a># 事件种类</h6><h6 id="互斥事件"><a href="#互斥事件" class="headerlink" title="## 互斥事件"></a>## 互斥事件</h6><h6 id="互斥事件（互不相容事件）事件A与事件B，AB-Φ，事件A与事件B不能同时发生，事件A与事件B没有公共的样本点。"><a href="#互斥事件（互不相容事件）事件A与事件B，AB-Φ，事件A与事件B不能同时发生，事件A与事件B没有公共的样本点。" class="headerlink" title="### 互斥事件（互不相容事件）事件A与事件B，AB=Φ，事件A与事件B不能同时发生，事件A与事件B没有公共的样本点。"></a>### 互斥事件（互不相容事件）事件A与事件B，AB=Φ，事件A与事件B不能同时发生，事件A与事件B没有公共的样本点。</h6><h6 id="对立事件"><a href="#对立事件" class="headerlink" title="## 对立事件"></a>## 对立事件</h6><h6 id="事件A的对立事件，事件A不发生，事件A的对立事件是由不属于事件A的样本点组成，记作a。"><a href="#事件A的对立事件，事件A不发生，事件A的对立事件是由不属于事件A的样本点组成，记作a。" class="headerlink" title="### 事件A的对立事件，事件A不发生，事件A的对立事件是由不属于事件A的样本点组成，记作ā。"></a>### 事件A的对立事件，事件A不发生，事件A的对立事件是由不属于事件A的样本点组成，记作ā。</h6><h6 id="差事件"><a href="#差事件" class="headerlink" title="## 差事件"></a>## 差事件</h6><h6 id="差事件发生，即事件A发生且事件B不发生，是由属于事件A但不属于事件B的样本点组成，记作A－B。"><a href="#差事件发生，即事件A发生且事件B不发生，是由属于事件A但不属于事件B的样本点组成，记作A－B。" class="headerlink" title="### 差事件发生，即事件A发生且事件B不发生，是由属于事件A但不属于事件B的样本点组成，记作A－B。"></a>### 差事件发生，即事件A发生且事件B不发生，是由属于事件A但不属于事件B的样本点组成，记作A－B。</h6><h5 id="来自维基百科"><a href="#来自维基百科" class="headerlink" title="来自维基百科"></a>来自维基百科</h5><h6 id="1-例子"><a href="#1-例子" class="headerlink" title="1.例子"></a>1.例子</h6><h6 id="假设我们有一堆52张的扑克牌，并闭着眼睛在这堆牌中抽取一张牌，那么用概率论的术语来说，我们实际上是在做一个随机试验。这时，我们的样本空间是一个有着52个元素的集合，因为任意一张牌都是一个可能的结果。而一个随机事件，则是这个样本空间的任意一个子集（这个任意子集包括空集，一个元素的集合及多个元素的集合）。运用组合知识可以知道，随机事件一共有2-52种。当这个事件仅仅包括样本空间的一个元素（或者说它是一个单元素集合）的时候，称这个事件为一个基本事件。比如说事件”抽到的牌是黑桃7”。当事件是空集时，称这个事件为不可能事件。当事件是全集时，则称事件是必然事件。其它还有各种各样的事件，比如：-“抽到的牌是小丑”（也是不可能事件）-“抽到的牌是红桃3”（基本事件）-“抽到的牌数字是9”（包含4个元素）-“抽到的牌是方块”（包含13个元素）-“抽到的牌是红颜色的并且数字小于等于10”（包含20个元素）-“抽到的牌不是红桃3”（包含51个元素）-由于事件是样本空间的子集，所以也可以写成集合的形式。有时候写成集合的形式可能会很困难。有时候也可以用文氏图来表示事件，这时可以用事件所代表图形的面积来按比例显示事件的概率。"><a href="#假设我们有一堆52张的扑克牌，并闭着眼睛在这堆牌中抽取一张牌，那么用概率论的术语来说，我们实际上是在做一个随机试验。这时，我们的样本空间是一个有着52个元素的集合，因为任意一张牌都是一个可能的结果。而一个随机事件，则是这个样本空间的任意一个子集（这个任意子集包括空集，一个元素的集合及多个元素的集合）。运用组合知识可以知道，随机事件一共有2-52种。当这个事件仅仅包括样本空间的一个元素（或者说它是一个单元素集合）的时候，称这个事件为一个基本事件。比如说事件”抽到的牌是黑桃7”。当事件是空集时，称这个事件为不可能事件。当事件是全集时，则称事件是必然事件。其它还有各种各样的事件，比如：-“抽到的牌是小丑”（也是不可能事件）-“抽到的牌是红桃3”（基本事件）-“抽到的牌数字是9”（包含4个元素）-“抽到的牌是方块”（包含13个元素）-“抽到的牌是红颜色的并且数字小于等于10”（包含20个元素）-“抽到的牌不是红桃3”（包含51个元素）-由于事件是样本空间的子集，所以也可以写成集合的形式。有时候写成集合的形式可能会很困难。有时候也可以用文氏图来表示事件，这时可以用事件所代表图形的面积来按比例显示事件的概率。" class="headerlink" title="# 假设我们有一堆52张的扑克牌，并闭着眼睛在这堆牌中抽取一张牌，那么用概率论的术语来说，我们实际上是在做一个随机试验。这时，我们的样本空间是一个有着52个元素的集合，因为任意一张牌都是一个可能的结果。而一个随机事件，则是这个样本空间的任意一个子集（这个任意子集包括空集，一个元素的集合及多个元素的集合）。运用组合知识可以知道，随机事件一共有2\^52种。当这个事件仅仅包括样本空间的一个元素（或者说它是一个单元素集合）的时候，称这个事件为一个基本事件。比如说事件”抽到的牌是黑桃7”。当事件是空集时，称这个事件为不可能事件。当事件是全集时，则称事件是必然事件。其它还有各种各样的事件，比如： “抽到的牌是小丑”（也是不可能事件） “抽到的牌是红桃3”（基本事件） “抽到的牌数字是9”（包含4个元素） “抽到的牌是方块”（包含13个元素） “抽到的牌是红颜色的并且数字小于等于10”（包含20个元素） “抽到的牌不是红桃3”（包含51个元素） 由于事件是样本空间的子集，所以也可以写成集合的形式。有时候写成集合的形式可能会很困难。有时候也可以用文氏图来表示事件，这时可以用事件所代表图形的面积来按比例显示事件的概率。"></a># 假设我们有一堆52张的扑克牌，并闭着眼睛在这堆牌中抽取一张牌，那么用概率论的术语来说，我们实际上是在做一个随机试验。这时，我们的样本空间是一个有着52个元素的集合，因为任意一张牌都是一个可能的结果。而一个随机事件，则是这个样本空间的任意一个子集（这个任意子集包括空集，一个元素的集合及多个元素的集合）。运用组合知识可以知道，随机事件一共有2\^52种。当这个事件仅仅包括样本空间的一个元素（或者说它是一个单元素集合）的时候，称这个事件为一个基本事件。比如说事件”抽到的牌是黑桃7”。当事件是空集时，称这个事件为不可能事件。当事件是全集时，则称事件是必然事件。其它还有各种各样的事件，比如： “抽到的牌是小丑”（也是不可能事件） “抽到的牌是红桃3”（基本事件） “抽到的牌数字是9”（包含4个元素） “抽到的牌是方块”（包含13个元素） “抽到的牌是红颜色的并且数字小于等于10”（包含20个元素） “抽到的牌不是红桃3”（包含51个元素） 由于事件是样本空间的子集，所以也可以写成集合的形式。有时候写成集合的形式可能会很困难。有时候也可以用文氏图来表示事件，这时可以用事件所代表图形的面积来按比例显示事件的概率。</h6><h4 id="事件的相互关系及运算"><a href="#事件的相互关系及运算" class="headerlink" title="事件的相互关系及运算"></a>事件的相互关系及运算</h4><h4 id="频率"><a href="#频率" class="headerlink" title="频率"></a>频率</h4><h4 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h4><h3 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h3><h4 id="等可能概型（古典概型）"><a href="#等可能概型（古典概型）" class="headerlink" title="等可能概型（古典概型）"></a>等可能概型（古典概型）</h4><h5 id="基本描述"><a href="#基本描述" class="headerlink" title="基本描述"></a>基本描述</h5><h6 id="定义：古典概型也叫传统概率，其定义是由法国数学家拉普拉斯-Laplace-提出的。如果一个随机试验所包含的单位事件是有限的，且每个单位事件发生的可能性均相等，则这个随机试验叫做拉普拉斯试验，这种条件下的概率模型就叫古典概型。"><a href="#定义：古典概型也叫传统概率，其定义是由法国数学家拉普拉斯-Laplace-提出的。如果一个随机试验所包含的单位事件是有限的，且每个单位事件发生的可能性均相等，则这个随机试验叫做拉普拉斯试验，这种条件下的概率模型就叫古典概型。" class="headerlink" title="定义：古典概型也叫传统概率，其定义是由法国数学家拉普拉斯 (Laplace ) 提出的。如果一个随机试验所包含的单位事件是有限的，且每个单位事件发生的可能性均相等，则这个随机试验叫做拉普拉斯试验，这种条件下的概率模型就叫古典概型。"></a>定义：古典概型也叫传统概率，其定义是由法国数学家拉普拉斯 (Laplace ) 提出的。如果一个随机试验所包含的单位事件是有限的，且每个单位事件发生的可能性均相等，则这个随机试验叫做拉普拉斯试验，这种条件下的概率模型就叫古典概型。</h6><h6 id="在这个模型下，随机实验所有可能的结果是有限的，并且每个基本结果发生的概率是相同的。古典概型是概率论中最直观和最简单的模型，概率的许多运算规则，也首先是在这种模型下得到的。"><a href="#在这个模型下，随机实验所有可能的结果是有限的，并且每个基本结果发生的概率是相同的。古典概型是概率论中最直观和最简单的模型，概率的许多运算规则，也首先是在这种模型下得到的。" class="headerlink" title="在这个模型下，随机实验所有可能的结果是有限的，并且每个基本结果发生的概率是相同的。古典概型是概率论中最直观和最简单的模型，概率的许多运算规则，也首先是在这种模型下得到的。"></a>在这个模型下，随机实验所有可能的结果是有限的，并且每个基本结果发生的概率是相同的。古典概型是概率论中最直观和最简单的模型，概率的许多运算规则，也首先是在这种模型下得到的。</h6><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><h6 id="（1）-试验中所有可能出现的基本事件只有有限个；"><a href="#（1）-试验中所有可能出现的基本事件只有有限个；" class="headerlink" title="（1） 试验中所有可能出现的基本事件只有有限个；"></a>（1） 试验中所有可能出现的基本事件只有有限个；</h6><h6 id="有限性"><a href="#有限性" class="headerlink" title="# 有限性"></a># 有限性</h6><h6 id="（2）-试验中每个基本事件出现的可能性相等。"><a href="#（2）-试验中每个基本事件出现的可能性相等。" class="headerlink" title="（2） 试验中每个基本事件出现的可能性相等。"></a>（2） 试验中每个基本事件出现的可能性相等。</h6><h6 id="等可能性"><a href="#等可能性" class="headerlink" title="# 等可能性"></a># 等可能性</h6><h6 id="具有以上两个特点的概率模型是大量存在的，这种概率模型称为古典概率模型，简称古典概型，也叫等可能概型。"><a href="#具有以上两个特点的概率模型是大量存在的，这种概率模型称为古典概率模型，简称古典概型，也叫等可能概型。" class="headerlink" title="具有以上两个特点的概率模型是大量存在的，这种概率模型称为古典概率模型，简称古典概型，也叫等可能概型。"></a>具有以上两个特点的概率模型是大量存在的，这种概率模型称为古典概率模型，简称古典概型，也叫等可能概型。</h6><h5 id="古典概型的判断"><a href="#古典概型的判断" class="headerlink" title="古典概型的判断"></a>古典概型的判断</h5><h6 id="一个试验是否为古典概型，在于这个试验是否具有古典概型的两个特征———有限性和等可能性，只有同时具备这两个特点的概型才是古典概型。"><a href="#一个试验是否为古典概型，在于这个试验是否具有古典概型的两个特征———有限性和等可能性，只有同时具备这两个特点的概型才是古典概型。" class="headerlink" title="一个试验是否为古典概型，在于这个试验是否具有古典概型的两个特征———有限性和等可能性，只有同时具备这两个特点的概型才是古典概型。"></a>一个试验是否为古典概型，在于这个试验是否具有古典概型的两个特征———有限性和等可能性，只有同时具备这两个特点的概型才是古典概型。</h6><h5 id="概率公式"><a href="#概率公式" class="headerlink" title="概率公式"></a>概率公式</h5><h6 id="P（A）-m-n-A包含的基本事件的个数m-基本事件的总数n"><a href="#P（A）-m-n-A包含的基本事件的个数m-基本事件的总数n" class="headerlink" title="P（A）= m/n =A包含的基本事件的个数m/基本事件的总数n"></a>P（A）= m/n =A包含的基本事件的个数m/基本事件的总数n</h6><h6 id="如果一次实验中可能出现的结果有n个，而且所有结果出现的可能性都相等，那么每一个基本事件的概率都是-1-n-；-如果某个事件A包含的结果有m个，那么事件A的概率为P（A）-m-n-A包含的基本事件的个数m-基本事件的总数n"><a href="#如果一次实验中可能出现的结果有n个，而且所有结果出现的可能性都相等，那么每一个基本事件的概率都是-1-n-；-如果某个事件A包含的结果有m个，那么事件A的概率为P（A）-m-n-A包含的基本事件的个数m-基本事件的总数n" class="headerlink" title="如果一次实验中可能出现的结果有n个，而且所有结果出现的可能性都相等，那么每一个基本事件的概率都是 1/n ； 如果某个事件A包含的结果有m个，那么事件A的概率为P（A）= m/n =A包含的基本事件的个数m/基本事件的总数n"></a>如果一次实验中可能出现的结果有n个，而且所有结果出现的可能性都相等，那么每一个基本事件的概率都是 1/n ； 如果某个事件A包含的结果有m个，那么事件A的概率为P（A）= m/n =A包含的基本事件的个数m/基本事件的总数n</h6><h4 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h4><h4 id="全概率公式与贝叶斯公式"><a href="#全概率公式与贝叶斯公式" class="headerlink" title="全概率公式与贝叶斯公式"></a>全概率公式与贝叶斯公式</h4><h4 id="事件独立性"><a href="#事件独立性" class="headerlink" title="事件独立性"></a>事件独立性</h4><h2 id="第二章：随机变量及其分布（1）"><a href="#第二章：随机变量及其分布（1）" class="headerlink" title="第二章：随机变量及其分布（1）"></a>第二章：随机变量及其分布（1）</h2><h3 id="第一部分-1"><a href="#第一部分-1" class="headerlink" title="第一部分"></a>第一部分</h3><h4 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h4><h4 id="离散型随机变量"><a href="#离散型随机变量" class="headerlink" title="离散型随机变量"></a>离散型随机变量</h4><h4 id="分布函数"><a href="#分布函数" class="headerlink" title="分布函数"></a>分布函数</h4><h3 id="第二部分-1"><a href="#第二部分-1" class="headerlink" title="第二部分"></a>第二部分</h3><h4 id="连续型随机变量及其概率密度"><a href="#连续型随机变量及其概率密度" class="headerlink" title="连续型随机变量及其概率密度"></a>连续型随机变量及其概率密度</h4><h4 id="均匀分布与指数分布"><a href="#均匀分布与指数分布" class="headerlink" title="均匀分布与指数分布"></a>均匀分布与指数分布</h4><h4 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h4><h4 id="随机变量函数的分布"><a href="#随机变量函数的分布" class="headerlink" title="随机变量函数的分布"></a>随机变量函数的分布</h4><h3 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h3><h4 id="二元随机变量，离散型随机变量分布律"><a href="#二元随机变量，离散型随机变量分布律" class="headerlink" title="二元随机变量，离散型随机变量分布律"></a>二元随机变量，离散型随机变量分布律</h4><h4 id="二元离散型随机变量边际分布律与条件分布律"><a href="#二元离散型随机变量边际分布律与条件分布律" class="headerlink" title="二元离散型随机变量边际分布律与条件分布律"></a>二元离散型随机变量边际分布律与条件分布律</h4><h5 id="不用看"><a href="#不用看" class="headerlink" title="不用看"></a>不用看</h5><h4 id="二元随机变量分布函数、边际分布函数及条件分布函数"><a href="#二元随机变量分布函数、边际分布函数及条件分布函数" class="headerlink" title="二元随机变量分布函数、边际分布函数及条件分布函数"></a>二元随机变量分布函数、边际分布函数及条件分布函数</h4><h5 id="了解一下边缘分布函数即可"><a href="#了解一下边缘分布函数即可" class="headerlink" title="了解一下边缘分布函数即可"></a>了解一下边缘分布函数即可</h5><h4 id="二元连续性随机变量，联合概率密度"><a href="#二元连续性随机变量，联合概率密度" class="headerlink" title="二元连续性随机变量，联合概率密度"></a>二元连续性随机变量，联合概率密度</h4><h5 id="自个笔记"><a href="#自个笔记" class="headerlink" title="自个笔记"></a>自个笔记</h5><h6 id="子主题-1"><a href="#子主题-1" class="headerlink" title="子主题 1"></a>子主题 1</h6><h3 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h3><h4 id="二元连续型随机变量边际概率密度"><a href="#二元连续型随机变量边际概率密度" class="headerlink" title="二元连续型随机变量边际概率密度"></a>二元连续型随机变量边际概率密度</h4><h4 id="二元连续型随机变量条件概率密度"><a href="#二元连续型随机变量条件概率密度" class="headerlink" title="二元连续型随机变量条件概率密度"></a>二元连续型随机变量条件概率密度</h4><h5 id="不用看-1"><a href="#不用看-1" class="headerlink" title="不用看"></a>不用看</h5><h4 id="二元均匀分布，二元正态分布"><a href="#二元均匀分布，二元正态分布" class="headerlink" title="二元均匀分布，二元正态分布"></a>二元均匀分布，二元正态分布</h4><h4 id="随机变量的独立性"><a href="#随机变量的独立性" class="headerlink" title="随机变量的独立性"></a>随机变量的独立性</h4><h3 id="第五部分"><a href="#第五部分" class="headerlink" title="第五部分"></a>第五部分</h3><h4 id="二元随机变量函数的分布"><a href="#二元随机变量函数的分布" class="headerlink" title="二元随机变量函数的分布"></a>二元随机变量函数的分布</h4><h4 id="Z-X-Y的分布"><a href="#Z-X-Y的分布" class="headerlink" title="Z=X+Y的分布"></a>Z=X+Y的分布</h4><h4 id="max-X-Y-和min-X-Y-的分布"><a href="#max-X-Y-和min-X-Y-的分布" class="headerlink" title="max(X,Y)和min(X,Y)的分布"></a>max(X,Y)和min(X,Y)的分布</h4><h2 id="第三章：随机变量的数字特征"><a href="#第三章：随机变量的数字特征" class="headerlink" title="第三章：随机变量的数字特征"></a>第三章：随机变量的数字特征</h2><h3 id="第一部分-2"><a href="#第一部分-2" class="headerlink" title="第一部分"></a>第一部分</h3><h4 id="随机变量的数学期望"><a href="#随机变量的数学期望" class="headerlink" title="随机变量的数学期望"></a>随机变量的数学期望</h4><h4 id="随机变量函数的数学期望"><a href="#随机变量函数的数学期望" class="headerlink" title="随机变量函数的数学期望"></a>随机变量函数的数学期望</h4><h4 id="数学期望的性质"><a href="#数学期望的性质" class="headerlink" title="数学期望的性质"></a>数学期望的性质</h4><h4 id="方差定义和计算公式"><a href="#方差定义和计算公式" class="headerlink" title="方差定义和计算公式"></a>方差定义和计算公式</h4><h3 id="第二部分-2"><a href="#第二部分-2" class="headerlink" title="第二部分"></a>第二部分</h3><h4 id="方差的性质"><a href="#方差的性质" class="headerlink" title="方差的性质"></a>方差的性质</h4><h4 id="协方差与相关系数"><a href="#协方差与相关系数" class="headerlink" title="协方差与相关系数"></a>协方差与相关系数</h4><h4 id="不相关与独立"><a href="#不相关与独立" class="headerlink" title="不相关与独立"></a>不相关与独立</h4><h4 id="矩，协方差矩阵，多元正态分布的性质"><a href="#矩，协方差矩阵，多元正态分布的性质" class="headerlink" title="矩，协方差矩阵，多元正态分布的性质"></a>矩，协方差矩阵，多元正态分布的性质</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一章：随机事件及其概率（1）&quot;&gt;&lt;a href=&quot;#第一章：随机事件及其概率（1）&quot; class=&quot;headerlink&quot; title=&quot;第一章：随机事件及其概率（1）&quot;&gt;&lt;/a&gt;第一章：随机事件及其概率（1）&lt;/h2&gt;&lt;h3 id=&quot;第一部分&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="数理知识" scheme="https://mr8god.cn/categories/%E6%95%B0%E7%90%86%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="概率论" scheme="https://mr8god.cn/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>祝朱亦宇同学生日快乐！！！</title>
    <link href="https://mr8god.cn/2020/03/19/%E7%94%9F%E6%B4%BB%E9%9C%80%E8%A6%81%E4%B8%80%E4%BA%9B%E8%B6%A3%E5%91%B3%E5%93%A6%EF%BC%81/%E7%A5%9D%E6%9C%B1%E4%BA%A6%E5%AE%87%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/"/>
    <id>https://mr8god.cn/2020/03/19/%E7%94%9F%E6%B4%BB%E9%9C%80%E8%A6%81%E4%B8%80%E4%BA%9B%E8%B6%A3%E5%91%B3%E5%93%A6%EF%BC%81/%E7%A5%9D%E6%9C%B1%E4%BA%A6%E5%AE%87%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/</id>
    <published>2020-03-19T15:02:14.397Z</published>
    <updated>2020-03-29T14:14:59.710Z</updated>
    
    <content type="html"><![CDATA[<p>主题 </p><p>祝朱亦宇同学生日快乐</p><p>　　要想清楚，祝朱亦宇同学生日快乐，到底是一种怎么样的存在。 可是，即使是这样，祝朱亦宇同学生日快乐的出现仍然代表了一定的意义。 歌德说过一句富有哲理的话，读一本好书，就如同和一个高尚的人在交谈。带着这句话，我们还要更加慎重的审视这个问题： 乌申斯基曾经说过，学习是劳动，是充满思想的劳动。带着这句话，我们还要更加慎重的审视这个问题： 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 培根曾经说过，要知道对好事的称颂过于夸大，也会招来人们的反感轻蔑和嫉妒。这句话语虽然很短，但令我浮想联翩。 总结的来说， 一般来说， 一般来说， 就我个人来说，祝朱亦宇同学生日快乐对我的意义，不能不说非常重大。 祝朱亦宇同学生日快乐因何而发生？ 一般来讲，我们都必须务必慎重的考虑考虑。 别林斯基在不经意间这样说过，好的书籍是最贵重的珍宝。这似乎解答了我的疑惑。 爱尔兰曾经说过，越是无能的人，越喜欢挑剔别人的错儿。我希望诸位也能好好地体会这句话。 问题的关键究竟为何？ 我认为。</p><p>　　乌申斯基在不经意间这样说过，学习是劳动，是充满思想的劳动。这启发了我， 既然如此， 总结的来说， 了解清楚祝朱亦宇同学生日快乐到底是一种怎么样的存在，是解决一切问题的关键。 可是，即使是这样，祝朱亦宇同学生日快乐的出现仍然代表了一定的意义。 一般来说， 现在，解决祝朱亦宇同学生日快乐的问题，是非常非常重要的。 所以， 对我个人而言，祝朱亦宇同学生日快乐不仅仅是一个重大的事件，还可能会改变我的人生。 要想清楚，祝朱亦宇同学生日快乐，到底是一种怎么样的存在。 一般来讲，我们都必须务必慎重的考虑考虑。 带着这些问题，我们来审视一下祝朱亦宇同学生日快乐。 总结的来说， 每个人都不得不面对这些问题。 在面对这种问题时， 祝朱亦宇同学生日快乐，到底应该如何实现。 一般来讲，我们都必须务必慎重的考虑考虑。 在这种困难的抉择下，本人思来想去，寝食难安。 带着这些问题，我们来审视一下祝朱亦宇同学生日快乐。 既然如何， 祝朱亦宇同学生日快乐的发生，到底需要如何做到，不祝朱亦宇同学生日快乐的发生，又会如何产生。 培根曾经提到过，阅读使人充实，会谈使人敏捷，写作使人精确。这似乎解答了我的疑惑。</p><p>　　吕凯特说过一句富有哲理的话，生命不可能有两次，但许多人连一次也不善于度过。带着这句话，我们还要更加慎重的审视这个问题： 那么， 要想清楚，祝朱亦宇同学生日快乐，到底是一种怎么样的存在。 带着这些问题，我们来审视一下祝朱亦宇同学生日快乐。 罗曼·罗兰在不经意间这样说过，只有把抱怨环境的心情，化为上进的力量，才是成功的保证。这句话语虽然很短，但令我浮想联翩。 我们都知道，只要有意义，那么就必须慎重考虑。 每个人都不得不面对这些问题。 在面对这种问题时， 这样看来， 就我个人来说，祝朱亦宇同学生日快乐对我的意义，不能不说非常重大。 可是，即使是这样，祝朱亦宇同学生日快乐的出现仍然代表了一定的意义。 从这个角度来看， 我们都知道，只要有意义，那么就必须慎重考虑。 既然如何， 经过上述讨论， 祝朱亦宇同学生日快乐因何而发生？ 总结的来说， 所谓祝朱亦宇同学生日快乐，关键是祝朱亦宇同学生日快乐需要如何写。 一般来讲，我们都必须务必慎重的考虑考虑。 我们不得不面对一个非常尴尬的事实，那就是， 总结的来说， 对我个人而言，祝朱亦宇同学生日快乐不仅仅是一个重大的事件，还可能会改变我的人生。 经过上述讨论， 我们都知道，只要有意义，那么就必须慎重考虑。 吕凯特说过一句富有哲理的话，生命不可能有两次，但许多人连一次也不善于度过。这似乎解答了我的疑惑。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 一般来讲，我们都必须务必慎重的考虑考虑。 每个人都不得不面对这些问题。 在面对这种问题时， 而这些并不是完全重要，更加重要的问题是， 要想清楚，祝朱亦宇同学生日快乐，到底是一种怎么样的存在。 黑塞曾经说过，有勇气承担命运这才是英雄好汉。这似乎解答了我的疑惑。 对我个人而言，祝朱亦宇同学生日快乐不仅仅是一个重大的事件，还可能会改变我的人生。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 塞涅卡曾经说过，生命如同寓言，其价值不在与长短，而在与内容。带着这句话，我们还要更加慎重的审视这个问题： 经过上述讨论， 祝朱亦宇同学生日快乐，发生了会如何，不发生又会如何。 问题的关键究竟为何？ 祝朱亦宇同学生日快乐，发生了会如何，不发生又会如何。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下祝朱亦宇同学生日快乐。 所谓祝朱亦宇同学生日快乐，关键是祝朱亦宇同学生日快乐需要如何写。 对我个人而言，祝朱亦宇同学生日快乐不仅仅是一个重大的事件，还可能会改变我的人生。 这样看来， 可是，即使是这样，祝朱亦宇同学生日快乐的出现仍然代表了一定的意义。 这样看来， 了解清楚祝朱亦宇同学生日快乐到底是一种怎么样的存在，是解决一切问题的关键。</p><p>　　这样看来， 一般来说， 祝朱亦宇同学生日快乐的发生，到底需要如何做到，不祝朱亦宇同学生日快乐的发生，又会如何产生。 了解清楚祝朱亦宇同学生日快乐到底是一种怎么样的存在，是解决一切问题的关键。 问题的关键究竟为何？ 了解清楚祝朱亦宇同学生日快乐到底是一种怎么样的存在，是解决一切问题的关键。 那么， 这样看来， 达尔文说过一句富有哲理的话，敢于浪费哪怕一个钟头时间的人，说明他还不懂得珍惜生命的全部价值。这启发了我， 吕凯特在不经意间这样说过，生命不可能有两次，但许多人连一次也不善于度过。这启发了我， 普列姆昌德曾经说过，希望的灯一旦熄灭，生活刹那间变成了一片黑暗。这启发了我， 所谓祝朱亦宇同学生日快乐，关键是祝朱亦宇同学生日快乐需要如何写。</p><p>　　塞涅卡曾经说过，生命如同寓言，其价值不在与长短，而在与内容。这启发了我， 一般来说， 那么， 总结的来说， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 祝朱亦宇同学生日快乐，到底应该如何实现。 现在，解决祝朱亦宇同学生日快乐的问题，是非常非常重要的。 所以， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 韩非曾经提到过，内外相应，言行相称。这启发了我， 所谓祝朱亦宇同学生日快乐，关键是祝朱亦宇同学生日快乐需要如何写。 培根说过一句富有哲理的话，要知道对好事的称颂过于夸大，也会招来人们的反感轻蔑和嫉妒。这不禁令我深思。 既然如此， 俾斯麦曾经说过，对于不屈不挠的人来说，没有失败这回事。我希望诸位也能好好地体会这句话。 我们不得不面对一个非常尴尬的事实，那就是， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 这样看来， 问题的关键究竟为何？ 祝朱亦宇同学生日快乐的发生，到底需要如何做到，不祝朱亦宇同学生日快乐的发生，又会如何产生。 这样看来， 罗素·贝克在不经意间这样说过，一个人即使已登上顶峰，也仍要自强不息。这不禁令我深思。 那么， 祝朱亦宇同学生日快乐，发生了会如何，不发生又会如何。 可是，即使是这样，祝朱亦宇同学生日快乐的出现仍然代表了一定的意义。 现在，解决祝朱亦宇同学生日快乐的问题，是非常非常重要的。 所以， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 马克思曾经说过，一切节省，归根到底都归结为时间的节省。这似乎解答了我的疑惑。 我认为， 那么， 在这种困难的抉择下，本人思来想去，寝食难安。 在这种困难的抉择下，本人思来想去，寝食难安。</p><p>　　那么， 既然如此， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 现在，解决祝朱亦宇同学生日快乐的问题，是非常非常重要的。 所以， 莎士比亚说过一句富有哲理的话，意志命运往往背道而驰，决心到最后会全部推倒。这句话语虽然很短，但令我浮想联翩。 问题的关键究竟为何？ 韩非曾经提到过，内外相应，言行相称。带着这句话，我们还要更加慎重的审视这个问题： 就我个人来说，祝朱亦宇同学生日快乐对我的意义，不能不说非常重大。 所谓祝朱亦宇同学生日快乐，关键是祝朱亦宇同学生日快乐需要如何写。 既然如此。</p><p>　　从这个角度来看， 可是，即使是这样，祝朱亦宇同学生日快乐的出现仍然代表了一定的意义。 富勒在不经意间这样说过，苦难磨炼一些人，也毁灭另一些人。我希望诸位也能好好地体会这句话。 一般来讲，我们都必须务必慎重的考虑考虑。 经过上述讨论， 可是，即使是这样，祝朱亦宇同学生日快乐的出现仍然代表了一定的意义。 就我个人来说，祝朱亦宇同学生日快乐对我的意义，不能不说非常重大。 一般来说， 祝朱亦宇同学生日快乐，发生了会如何，不发生又会如何。 经过上述讨论， 既然如此， 一般来说， 带着这些问题，我们来审视一下祝朱亦宇同学生日快乐。 现在，解决祝朱亦宇同学生日快乐的问题，是非常非常重要的。 所以， 每个人都不得不面对这些问题。 在面对这种问题时， 在这种困难的抉择下，本人思来想去，寝食难安。 总结的来说， 问题的关键究竟为何？ 就我个人来说，祝朱亦宇同学生日快乐对我的意义，不能不说非常重大。 祝朱亦宇同学生日快乐，到底应该如何实现。 所谓祝朱亦宇同学生日快乐，关键是祝朱亦宇同学生日快乐需要如何写。 问题的关键究竟为何？ 祝朱亦宇同学生日快乐因何而发生？ 而这些并不是完全重要，更加重要的问题是， 了解清楚祝朱亦宇同学生日快乐到底是一种怎么样的存在，是解决一切问题的关键。 可是，即使是这样，祝朱亦宇同学生日快乐的出现仍然代表了一定的意义。 我们都知道，只要有意义，那么就必须慎重考虑。 生活中，若祝朱亦宇同学生日快乐出现了，我们就不得不考虑它出现了的事实。 所谓祝朱亦宇同学生日快乐，关键是祝朱亦宇同学生日快乐需要如何写。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 总结的来说， 俾斯麦说过一句富有哲理的话，失败是坚忍的最后考验。这似乎解答了我的疑惑。 对我个人而言，祝朱亦宇同学生日快乐不仅仅是一个重大的事件，还可能会改变我的人生。 要想清楚，祝朱亦宇同学生日快乐，到底是一种怎么样的存在。 所谓祝朱亦宇同学生日快乐，关键是祝朱亦宇同学生日快乐需要如何写。 苏轼曾经提到过，古之立大事者，不惟有超世之才，亦必有坚忍不拔之志。这句话语虽然很短，但令我浮想联翩。 而这些并不是完全重要，更加重要的问题是， 就我个人来说，祝朱亦宇同学生日快乐对我的意义，不能不说非常重大。 带着这些问题，我们来审视一下祝朱亦宇同学生日快乐。 生活中，若祝朱亦宇同学生日快乐出现了，我们就不得不考虑它出现了的事实。 带着这些问题，我们来审视一下祝朱亦宇同学生日快乐。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 从这个角度来看， 经过上述讨论， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 带着这些问题，我们来审视一下祝朱亦宇同学生日快乐。 生活中，若祝朱亦宇同学生日快乐出现了，我们就不得不考虑它出现了的事实。 祝朱亦宇同学生日快乐，发生了会如何，不发生又会如何。 从这个角度来看， 我们都知道，只要有意义，那么就必须慎重考虑。 每个人都不得不面对这些问题。 在面对这种问题时。</p><p>　　要想清楚，祝朱亦宇同学生日快乐，到底是一种怎么样的存在。 乌申斯基曾经提到过，学习是劳动，是充满思想的劳动。这似乎解答了我的疑惑。 米歇潘曾经提到过，生命是一条艰险的峡谷，只有勇敢的人才能通过。这启发了我， 普列姆昌德曾经提到过，希望的灯一旦熄灭，生活刹那间变成了一片黑暗。这似乎解答了我的疑惑。 富兰克林曾经提到过，读书是易事，思索是难事，但两者缺一，便全无用处。这句话语虽然很短，但令我浮想联翩。 歌德在不经意间这样说过，读一本好书，就如同和一个高尚的人在交谈。这句话语虽然很短，但令我浮想联翩。 从这个角度来看， 总结的来说， 祝朱亦宇同学生日快乐因何而发生？ 问题的关键究竟为何？ 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 莎士比亚曾经提到过，那脑袋里的智慧，就像打火石里的火花一样，不去打它是不肯出来的。这启发了我， 德谟克利特说过一句富有哲理的话，节制使快乐增加并使享受加强。这似乎解答了我的疑惑。 经过上述讨论， 要想清楚，祝朱亦宇同学生日快乐，到底是一种怎么样的存在。 对我个人而言，祝朱亦宇同学生日快乐不仅仅是一个重大的事件，还可能会改变我的人生。 在这种困难的抉择下，本人思来想去，寝食难安。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 每个人都不得不面对这些问题。 在面对这种问题时， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下祝朱亦宇同学生日快乐。 这样看来， 赫尔普斯说过一句富有哲理的话，有时候读书是一种巧妙地避开思考的方法。我希望诸位也能好好地体会这句话。 对我个人而言，祝朱亦宇同学生日快乐不仅仅是一个重大的事件，还可能会改变我的人生。 每个人都不得不面对这些问题。 在面对这种问题时。</p><p>　　查尔斯·史考伯说过一句富有哲理的话，一个人几乎可以在任何他怀有无限热忱的事情上成功。 这似乎解答了我的疑惑。 伏尔泰曾经提到过，不经巨大的困难，不会有伟大的事业。这句话语虽然很短，但令我浮想联翩。 可是，即使是这样，祝朱亦宇同学生日快乐的出现仍然代表了一定的意义。 歌德说过一句富有哲理的话，没有人事先了解自己到底有多大的力量，直到他试过以后才知道。这句话语虽然很短，但令我浮想联翩。 史美尔斯曾经说过，书籍把我们引入最美好的社会，使我们认识各个时代的伟大智者。这不禁令我深思。 带着这些问题，我们来审视一下祝朱亦宇同学生日快乐。 俾斯麦说过一句富有哲理的话，失败是坚忍的最后考验。这似乎解答了我的疑惑。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 祝朱亦宇同学生日快乐的发生，到底需要如何做到，不祝朱亦宇同学生日快乐的发生，又会如何产生。 了解清楚祝朱亦宇同学生日快乐到底是一种怎么样的存在，是解决一切问题的关键。 祝朱亦宇同学生日快乐的发生，到底需要如何做到，不祝朱亦宇同学生日快乐的发生，又会如何产生。 了解清楚祝朱亦宇同学生日快乐到底是一种怎么样的存在，是解决一切问题的关键。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 我们都知道，只要有意义，那么就必须慎重考虑。 斯宾诺莎曾经说过，最大的骄傲于最大的自卑都表示心灵的最软弱无力。这启发了我， 在这种困难的抉择下，本人思来想去，寝食难安。 莫扎特曾经提到过，谁和我一样用功，谁就会和我一样成功。这句话语虽然很短，但令我浮想联翩。 我们都知道，只要有意义，那么就必须慎重考虑。 这样看来， 就我个人来说，祝朱亦宇同学生日快乐对我的意义，不能不说非常重大。 这样看来， 维龙曾经说过，要成功不需要什么特别的才能，只要把你能做的小事做得好就行了。这不禁令我深思。 带着这些问题，我们来审视一下祝朱亦宇同学生日快乐。 问题的关键究竟为何？ 一般来讲，我们都必须务必慎重的考虑考虑。 而这些并不是完全重要，更加重要的问题是。</p><p>　　白哲特曾经说过，坚强的信念能赢得强者的心，并使他们变得更坚强。 带着这句话，我们还要更加慎重的审视这个问题： 鲁巴金在不经意间这样说过，读书是在别人思想的帮助下，建立起自己的思想。这启发了我， 既然如何， 既然如何， 我们不得不面对一个非常尴尬的事实，那就是， 祝朱亦宇同学生日快乐因何而发生？ 就我个人来说，祝朱亦宇同学生日快乐对我的意义，不能不说非常重大。 带着这些问题，我们来审视一下祝朱亦宇同学生日快乐。 吉格·金克拉在不经意间这样说过，如果你能做梦，你就能实现它。这不禁令我深思。 富兰克林在不经意间这样说过，读书是易事，思索是难事，但两者缺一，便全无用处。我希望诸位也能好好地体会这句话。 佚名曾经说过，感激每一个新的挑战，因为它会锻造你的意志和品格。我希望诸位也能好好地体会这句话。 吉姆·罗恩曾经提到过，要么你主宰生活，要么你被生活主宰。这似乎解答了我的疑惑。 生活中，若祝朱亦宇同学生日快乐出现了，我们就不得不考虑它出现了的事实。 爱尔兰曾经提到过，越是无能的人，越喜欢挑剔别人的错儿。我希望诸位也能好好地体会这句话。 了解清楚祝朱亦宇同学生日快乐到底是一种怎么样的存在，是解决一切问题的关键。 总结的来说， 总结的来说， 一般来讲，我们都必须务必慎重的考虑考虑。 而这些并不是完全重要，更加重要的问题是， 总结的来说， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 了解清楚祝朱亦宇同学生日快乐到底是一种怎么样的存在，是解决一切问题的关键。 总结的来说。</p><p>　　我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 可是，即使是这样，祝朱亦宇同学生日快乐的出现仍然代表了一定的意义。 那么， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 问题的关键究竟为何？ 了解清楚祝朱亦宇同学生日快乐到底是一种怎么样的存在，是解决一切问题的关键。 史美尔斯曾经提到过，书籍把我们引入最美好的社会，使我们认识各个时代的伟大智者。带着这句话，我们还要更加慎重的审视这个问题： 在这种困难的抉择下，本人思来想去，寝食难安。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 富兰克林曾经提到过，读书是易事，思索是难事，但两者缺一，便全无用处。这句话语虽然很短，但令我浮想联翩。 祝朱亦宇同学生日快乐，到底应该如何实现。 每个人都不得不面对这些问题。 在面对这种问题时， 祝朱亦宇同学生日快乐的发生，到底需要如何做到，不祝朱亦宇同学生日快乐的发生，又会如何产生。 这样看来。</p><p>　　我们不得不面对一个非常尴尬的事实，那就是， 而这些并不是完全重要，更加重要的问题是， 从这个角度来看， 德国曾经提到过，只有在人群中间，才能认识自己。带着这句话，我们还要更加慎重的审视这个问题： 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 要想清楚，祝朱亦宇同学生日快乐，到底是一种怎么样的存在。 这样看来， 一般来说， 祝朱亦宇同学生日快乐，发生了会如何，不发生又会如何。 从这个角度来看， 带着这些问题，我们来审视一下祝朱亦宇同学生日快乐。 可是，即使是这样，祝朱亦宇同学生日快乐的出现仍然代表了一定的意义。 希腊曾经提到过，最困难的事情就是认识自己。带着这句话，我们还要更加慎重的审视这个问题： 就我个人来说，祝朱亦宇同学生日快乐对我的意义，不能不说非常重大。 生活中，若祝朱亦宇同学生日快乐出现了，我们就不得不考虑它出现了的事实。 一般来讲，我们都必须务必慎重的考虑考虑。 总结的来说， 生活中，若祝朱亦宇同学生日快乐出现了，我们就不得不考虑它出现了的事实。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 祝朱亦宇同学生日快乐，发生了会如何，不发生又会如何。 这样看来， 莎士比亚在不经意间这样说过，人的一生是短的，但如果卑劣地过这一生，就太长了。这启发了我， 拉罗什福科在不经意间这样说过，我们唯一不会改正的缺点是软弱。这似乎解答了我的疑惑。 对我个人而言，祝朱亦宇同学生日快乐不仅仅是一个重大的事件，还可能会改变我的人生。 经过上述讨论， 要想清楚，祝朱亦宇同学生日快乐，到底是一种怎么样的存在。 而这些并不是完全重要，更加重要的问题是， 可是，即使是这样，祝朱亦宇同学生日快乐的出现仍然代表了一定的意义。 希腊曾经说过，最困难的事情就是认识自己。这似乎解答了我的疑惑。 现在，解决祝朱亦宇同学生日快乐的问题，是非常非常重要的。 所以， 乌申斯基在不经意间这样说过，学习是劳动，是充满思想的劳动。我希望诸位也能好好地体会这句话。 祝朱亦宇同学生日快乐，到底应该如何实现。 既然如何， 每个人都不得不面对这些问题。 在面对这种问题时， 生活中，若祝朱亦宇同学生日快乐出现了，我们就不得不考虑它出现了的事实。 每个人都不得不面对这些问题。 在面对这种问题时， 别林斯基在不经意间这样说过，好的书籍是最贵重的珍宝。这启发了我， 要想清楚，祝朱亦宇同学生日快乐，到底是一种怎么样的存在。 要想清楚，祝朱亦宇同学生日快乐，到底是一种怎么样的存在。 这样看来， 那么， 歌德在不经意间这样说过，没有人事先了解自己到底有多大的力量，直到他试过以后才知道。这似乎解答了我的疑惑。</p><p>　　祝朱亦宇同学生日快乐的发生，到底需要如何做到，不祝朱亦宇同学生日快乐的发生，又会如何产生。 要想清楚，祝朱亦宇同学生日快乐，到底是一种怎么样的存在。 莎士比亚在不经意间这样说过，意志命运往往背道而驰，决心到最后会全部推倒。带着这句话，我们还要更加慎重的审视这个问题： 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 既然如此， 祝朱亦宇同学生日快乐，到底应该如何实现。 可是，即使是这样，祝朱亦宇同学生日快乐的出现仍然代表了一定的意义。 就我个人来说，祝朱亦宇同学生日快乐对我的意义，不能不说非常重大。 可是，即使是这样，祝朱亦宇同学生日快乐的出现仍然代表了一定的意义。 对我个人而言，祝朱亦宇同学生日快乐不仅仅是一个重大的事件，还可能会改变我的人生。 祝朱亦宇同学生日快乐因何而发生？ 从这个角度来看， 既然如此， 一般来讲，我们都必须务必慎重的考虑考虑。 邓拓曾经提到过，越是没有本领的就越加自命不凡。这启发了我， 现在，解决祝朱亦宇同学生日快乐的问题，是非常非常重要的。 所以， 可是，即使是这样，祝朱亦宇同学生日快乐的出现仍然代表了一定的意义。 可是，即使是这样，祝朱亦宇同学生日快乐的出现仍然代表了一定的意义。 伏尔泰曾经提到过，坚持意志伟大的事业需要始终不渝的精神。这似乎解答了我的疑惑。 带着这些问题，我们来审视一下祝朱亦宇同学生日快乐。 对我个人而言，祝朱亦宇同学生日快乐不仅仅是一个重大的事件，还可能会改变我的人生。 既然如何， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 从这个角度来看， 从这个角度来看， 而这些并不是完全重要，更加重要的问题是， 海贝尔曾经说过，人生就是学校。在那里，与其说好的教师是幸福，不如说好的教师是不幸。这句话语虽然很短，但令我浮想联翩。 现在，解决祝朱亦宇同学生日快乐的问题，是非常非常重要的。 所以， 祝朱亦宇同学生日快乐，到底应该如何实现。 我认为， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 克劳斯·莫瑟爵士在不经意间这样说过，教育需要花费钱，而无知也是一样。这启发了我， 笛卡儿曾经说过，阅读一切好书如同和过去最杰出的人谈话。这似乎解答了我的疑惑。 带着这些问题，我们来审视一下祝朱亦宇同学生日快乐。 米歇潘曾经提到过，生命是一条艰险的峡谷，只有勇敢的人才能通过。这句话语虽然很短，但令我浮想联翩。 奥普拉·温弗瑞在不经意间这样说过，你相信什么，你就成为什么样的人。我希望诸位也能好好地体会这句话。 现在，解决祝朱亦宇同学生日快乐的问题，是非常非常重要的。 所以， 文森特·皮尔在不经意间这样说过，改变你的想法，你就改变了自己的世界。这启发了我， 从这个角度来看， 每个人都不得不面对这些问题。 在面对这种问题时， 我们都知道，只要有意义，那么就必须慎重考虑。 歌德曾经提到过，没有人事先了解自己到底有多大的力量，直到他试过以后才知道。带着这句话，我们还要更加慎重的审视这个问题： 祝朱亦宇同学生日快乐，到底应该如何实现。 对我个人而言，祝朱亦宇同学生日快乐不仅仅是一个重大的事件，还可能会改变我的人生。 在这种困难的抉择下，本人思来想去，寝食难安。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 我们不得不面对一个非常尴尬的事实，那就是， 吕凯特说过一句富有哲理的话，生命不可能有两次，但许多人连一次也不善于度过。这句话语虽然很短，但令我浮想联翩。 祝朱亦宇同学生日快乐，到底应该如何实现。 带着这些问题，我们来审视一下祝朱亦宇同学生日快乐。 祝朱亦宇同学生日快乐，发生了会如何，不发生又会如何。 这样看来， 祝朱亦宇同学生日快乐，到底应该如何实现。 一般来讲，我们都必须务必慎重的考虑考虑。 可是，即使是这样，祝朱亦宇同学生日快乐的出现仍然代表了一定的意义。 达尔文曾经提到过，敢于浪费哪怕一个钟头时间的人，说明他还不懂得珍惜生命的全部价值。这似乎解答了我的疑惑。 美华纳曾经说过，勿问成功的秘诀为何，且尽全力做你应该做的事吧。我希望诸位也能好好地体会这句话。 总结的来说， 我们不得不面对一个非常尴尬的事实，那就是， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 现在，解决祝朱亦宇同学生日快乐的问题，是非常非常重要的。 所以， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 祝朱亦宇同学生日快乐的发生，到底需要如何做到，不祝朱亦宇同学生日快乐的发生，又会如何产生。 就我个人来说，祝朱亦宇同学生日快乐对我的意义，不能不说非常重大。 我认为， 既然如此， 我们都知道，只要有意义，那么就必须慎重考虑。 祝朱亦宇同学生日快乐，发生了会如何，不发生又会如何。 每个人都不得不面对这些问题。 在面对这种问题时， 在这种困难的抉择下，本人思来想去，寝食难安。 这样看来， 就我个人来说，祝朱亦宇同学生日快乐对我的意义，不能不说非常重大。 我们都知道，只要有意义，那么就必须慎重考虑。 我们不得不面对一个非常尴尬的事实，那就是， 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。</p><p>　　而这些并不是完全重要，更加重要的问题是， 歌德曾经提到过，读一本好书，就如同和一个高尚的人在交谈。带着这句话，我们还要更加慎重的审视这个问题： 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。我希望诸位也能好好地体会这句话。 在这种困难的抉择下，本人思来想去，寝食难安。 我们不得不面对一个非常尴尬的事实，那就是， 了解清楚祝朱亦宇同学生日快乐到底是一种怎么样的存在，是解决一切问题的关键。 一般来讲，我们都必须务必慎重的考虑考虑。 那么， 祝朱亦宇同学生日快乐，到底应该如何实现。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，祝朱亦宇同学生日快乐，到底是一种怎么样的存在。 所谓祝朱亦宇同学生日快乐，关键是祝朱亦宇同学生日快乐需要如何写。 在这种困难的抉择下，本人思来想去，寝食难安。</p><p>　　我认为， 那么， 莎士比亚在不经意间这样说过，人的一生是短的，但如果卑劣地过这一生，就太长了。我希望诸位也能好好地体会这句话。 祝朱亦宇同学生日快乐，到底应该如何实现。 生活中，若祝朱亦宇同学生日快乐出现了，我们就不得不考虑它出现了的事实。 屠格涅夫说过一句富有哲理的话，你想成为幸福的人吗？但愿你首先学会吃得起苦。带着这句话，我们还要更加慎重的审视这个问题： 祝朱亦宇同学生日快乐的发生，到底需要如何做到，不祝朱亦宇同学生日快乐的发生，又会如何产生。 我们都知道，只要有意义，那么就必须慎重考虑。 一般来说， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 既然如何， 对我个人而言，祝朱亦宇同学生日快乐不仅仅是一个重大的事件，还可能会改变我的人生。 普列姆昌德曾经说过，希望的灯一旦熄灭，生活刹那间变成了一片黑暗。这句话语虽然很短，但令我浮想联翩。 要想清楚，祝朱亦宇同学生日快乐，到底是一种怎么样的存在。 从这个角度来看， 老子曾经说过，知人者智，自知者明。胜人者有力，自胜者强。这不禁令我深思。</p><p>　　我认为， 达·芬奇说过一句富有哲理的话，大胆和坚定的决心能够抵得上武器的精良。带着这句话，我们还要更加慎重的审视这个问题： 每个人都不得不面对这些问题。 在面对这种问题时， 问题的关键究竟为何？ 莎士比亚曾经提到过，抛弃时间的人，时间也抛弃他。这启发了我， 在这种困难的抉择下，本人思来想去，寝食难安。 现在，解决祝朱亦宇同学生日快乐的问题，是非常非常重要的。 所以， 既然如此， 现在，解决祝朱亦宇同学生日快乐的问题，是非常非常重要的。 所以， 经过上述讨论， 既然如何， 那么， 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下祝朱亦宇同学生日快乐。 问题的关键究竟为何？ 从这个角度来看， 现在，解决祝朱亦宇同学生日快乐的问题，是非常非常重要的。 所以， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 既然如何， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 一般来讲，我们都必须务必慎重的考虑考虑。 经过上述讨论， 迈克尔·F·斯特利曾经提到过，最具挑战性的挑战莫过于提升自我。我希望诸位也能好好地体会这句话。 问题的关键究竟为何？ 我们都知道，只要有意义，那么就必须慎重考虑。 经过上述讨论， 一般来说， 日本谚语在不经意间这样说过，不幸可能成为通向幸福的桥梁。带着这句话，我们还要更加慎重的审视这个问题： 要想清楚，祝朱亦宇同学生日快乐，到底是一种怎么样的存在。 在这种困难的抉择下，本人思来想去，寝食难安。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主题 &lt;/p&gt;
&lt;p&gt;祝朱亦宇同学生日快乐&lt;/p&gt;
&lt;p&gt;　　要想清楚，祝朱亦宇同学生日快乐，到底是一种怎么样的存在。 可是，即使是这样，祝朱亦宇同学生日快乐的出现仍然代表了一定的意义。 歌德说过一句富有哲理的话，读一本好书，就如同和一个高尚的人在交谈。带着这句话，我们还要
      
    
    </summary>
    
    
      <category term="生活需要一些趣味" scheme="https://mr8god.cn/categories/%E7%94%9F%E6%B4%BB%E9%9C%80%E8%A6%81%E4%B8%80%E4%BA%9B%E8%B6%A3%E5%91%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>Markdown的学习和掌握</title>
    <link href="https://mr8god.cn/2020/03/19/Markdown%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%8E%8C%E6%8F%A1/"/>
    <id>https://mr8god.cn/2020/03/19/Markdown%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%8E%8C%E6%8F%A1/</id>
    <published>2020-03-19T12:01:11.803Z</published>
    <updated>2020-03-29T14:22:13.751Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个普通段落。</p><pre><code>&lt;table&gt;&lt;tr&gt;    &lt;td&gt;Foo&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</code></pre><p>这是一个普通段落</p><p><a href="http://images.google.com/images?num=30&amp;q=larry+bird" target="_blank" rel="noopener">http://images.google.com/images?num=30&amp;q=larry+bird</a>  </p><p><a href="http://images.google.com/images?num=30&amp;q=larry+bird" target="_blank" rel="noopener">http://images.google.com/images?num=30&amp;q=larry+bird</a></p><p>&copy;</p><p>AT&amp;T</p><p>AT&amp;T</p><p>4 &lt; 5<br>健康减肥拉开了</p><ul><li><p>Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam<br>hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla     in, laoreet vitae, risus.<br>发多少</p><ul><li>发多少<ul><li>就是发挥<blockquote><p>This is a test</p></blockquote></li></ul></li></ul></li><li><p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse  id sem consectetuer libero luctus adipiscing.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;include&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;</span><br></pre></td></tr></table></figure></li></ul><ol><li>What a great season</li><li>What a great season</li><li>fdas f adf afs </li><li>fadf</li></ol><ol><li>what a great season</li></ol><p>参考式链接的范例<br>I get 10 times more traffic from <a href="http://google.com/" target="_blank" rel="noopener" title="Google">Google</a> than from <a href="http://search.yahoo.com/" target="_blank" rel="noopener" title="Yahoo Search">Yahoo</a> or <a href="http://search.msn.com/" target="_blank" rel="noopener" title="MSN Search">MSN</a>. </p><p>如果改成用链接名称的方式写</p><p>I get 10 times more traffic from <a href="http://google.com/" target="_blank" rel="noopener" title="Google">Google</a> than from <a href="http://search.yahoo.com/" target="_blank" rel="noopener" title="Yahoo Search">Yahoo</a> or <a href="http://search.msn.com/" target="_blank" rel="noopener" title="MSN Search">MSN</a>.</p><p>行内式的范例，比较实用哈！</p><p>I get 10 times more traffic from <a href="http://google.com/" target="_blank" rel="noopener" title="Google">Google</a> than from <a href="http://search.yahoo.com/" target="_blank" rel="noopener" title="Yahoo Search">Yahoo</a> or <a href="http://search.msn.com/" target="_blank" rel="noopener" title="MSN Search">MSN</a>.</p><p>* 我江某人最棒 <em><br><em>我江某人最棒</em><br>\</em>我就是流批，哈哈哈哈我江某人最棒*<br><strong>我江某人最棒</strong></p><p>\this text is surr<strong>ounded</strong> by literal asterisks\\  </p><ul><li>我江某人最棒*</li></ul><p>*我江某人最棒*</p><p><code>There is a literal backtick(`)</code></p><p>``There i</p><p>``There is a literal backtick()  </p><p><code>`There is a literal backtick(</code>) </p><p><code>There is a literal backtick(`)</code></p><p>Please don’t use any <code>&lt;blink&gt;</code> tags.</p><p>A single backtick in a code span: <code>` </code><br>A backtick-delimited string in a code span: <code>`foo` </code></p><p>Please don’t use any <code>&lt;blink&gt;</code> tags.</p><p><code>&amp;#8212;</code> is the decimal-encoded equivalent of <code>&amp;mdash;</code>.</p><p>AT&amp;T</p><p>「AT&amp;T」</p><h1 id="This-is-an-H1"><a href="#This-is-an-H1" class="headerlink" title="This is an H1 "></a>This is an H1 </h1><h2 id="This-is-an-H2"><a href="#This-is-an-H2" class="headerlink" title="This is an H2 "></a>This is an H2 </h2><h1 id="这是-H1"><a href="#这是-H1" class="headerlink" title="这是 H1"></a>这是 H1</h1><h2 id="这是-H2"><a href="#这是-H2" class="headerlink" title="这是 H2"></a>这是 H2</h2><h3 id="这是-H3"><a href="#这是-H3" class="headerlink" title="这是 H3"></a>这是 H3</h3><blockquote><p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. &gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. </p><p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse<br>id sem consectetuer libero luctus adipiscing.</p><p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p><p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing.</p><p>This is the first level of quoting. </p><blockquote><p>This is nested blockquote. </p></blockquote><p>Back to the first level.</p><h2 id="这是一个标题。"><a href="#这是一个标题。" class="headerlink" title="这是一个标题。"></a>这是一个标题。</h2></blockquote><ol><li>Red</li><li>Green</li><li>Blue</li></ol><ul><li>Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi   posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae,<br>risus. </li><li>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem   consectetuer libero luctus adipiscing.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一个普通段落。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;table&amp;gt;
&amp;lt;tr&amp;gt;
    &amp;lt;td&amp;gt;Foo&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是一个普通段落&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Markdown" scheme="https://mr8god.cn/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>每天和Dell客服学一招Day1</title>
    <link href="https://mr8god.cn/2020/03/19/%E6%AF%8F%E5%A4%A9%E5%92%8CDell%E5%AE%A2%E6%9C%8D%E5%AD%A6%E4%B8%80%E6%8B%9B/%E6%AF%8F%E5%A4%A9%E5%92%8CDell%E5%AE%A2%E6%9C%8D%E5%AD%A6%E4%B8%80%E6%8B%9BDay1/"/>
    <id>https://mr8god.cn/2020/03/19/%E6%AF%8F%E5%A4%A9%E5%92%8CDell%E5%AE%A2%E6%9C%8D%E5%AD%A6%E4%B8%80%E6%8B%9B/%E6%AF%8F%E5%A4%A9%E5%92%8CDell%E5%AE%A2%E6%9C%8D%E5%AD%A6%E4%B8%80%E6%8B%9BDay1/</id>
    <published>2020-03-19T12:01:11.000Z</published>
    <updated>2020-03-29T13:28:02.935Z</updated>
    
    <content type="html"><![CDATA[<p>问题描述：我在每一次使用office的产品，比如说word，抑或者是ppt都会报错，报错显示</p><p>登录word报错信息为</p><p><img src="https://i.loli.net/2020/03/25/YisQv72FSe6W3od.jpg" alt="批注 2020-03-25 114256.jpg"></p><p>登录PPT报错为</p><p><img src="https://i.loli.net/2020/03/25/WMcjbHfzF7DPul5.jpg" alt="批注 2020-03-25 114238.jpg"></p><p>客服给出的解释是：</p><p><img src="https://i.loli.net/2020/03/25/DtNP54F6mKEb3yo.jpg" alt="officeDell客服有话说.jpg"></p><p>好的~您这边先修复看看，如果这边无法修复的话只能卸载重装一下office哦~如果这边激活过的话可以尝试这边的方法下载的哦~<br>1.微软账号登入：<a href="https://dell.to/2JaaMAT" target="_blank" rel="noopener">https://dell.to/2JaaMAT</a><br>2.点击“服务和订阅”模块<br>3.选择下方Pc版office家庭和学生版 对应左侧“管理订阅”<br>4.可以看到“安装office”</p><p>最后呢，我是解决了我的word的问题，但是我还有一个PPT的问题该咋办呢，这个的话我就在Google上的csdn上找到了解答，并且成功解决了问题</p><p><a href="https://blog.csdn.net/u012332816/article/details/103411273" target="_blank" rel="noopener">https://blog.csdn.net/u012332816/article/details/103411273</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;问题描述：我在每一次使用office的产品，比如说word，抑或者是ppt都会报错，报错显示&lt;/p&gt;
&lt;p&gt;登录word报错信息为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/25/YisQv72FSe6W3od.jpg&quot; alt
      
    
    </summary>
    
    
    
      <category term="向Dell客服学习" scheme="https://mr8god.cn/tags/%E5%90%91Dell%E5%AE%A2%E6%9C%8D%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
