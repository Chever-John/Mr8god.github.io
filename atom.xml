<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr8god&#39;s blog</title>
  
  <subtitle>coding,coding,always coding!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mr8god.cn/"/>
  <updated>2020-04-09T12:59:39.045Z</updated>
  <id>https://mr8god.cn/</id>
  
  <author>
    <name>Mr8god</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java——数组</title>
    <link href="https://mr8god.cn/2020/04/09/Java/%E6%95%B0%E7%BB%84%E2%80%94%E2%80%94java/"/>
    <id>https://mr8god.cn/2020/04/09/Java/%E6%95%B0%E7%BB%84%E2%80%94%E2%80%94java/</id>
    <published>2020-04-09T12:59:47.219Z</published>
    <updated>2020-04-09T12:59:39.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java——数组"><a href="#Java——数组" class="headerlink" title="Java——数组"></a>Java——数组</h1><p>数组：可以一次定义，就可以得到多个类型相同、功能相似的变量，本质还是变量</p><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>java类型可以分成基本类型、应用类型</p><ol><li>基本类型：8个<ol><li>引用类型：数组、类、接口、枚举</li></ol></li></ol><p><strong>数组其实就是一种引用类型。</strong></p><p>任何已有的类型，添加一组方括号就可以变成数组类型</p><p>int ：属于基本类型</p><p>int[]：属于引用类型</p><p>int[]（是一个整体，得连在一起写，一定要注意哈！）</p><p>long         -&gt; long[]</p><p>String       -&gt; String[]</p><p>double     -&gt; double[]</p><p>int []         -&gt; int $[][]$</p><p>数组元素的类型：是数组类型去掉一组方括号</p><p> 比如说int[]数组元素的类型，就是int</p><h3 id="创建数组对象（数组初始化）"><a href="#创建数组对象（数组初始化）" class="headerlink" title="创建数组对象（数组初始化）"></a>创建数组对象（数组初始化）</h3><ol><li><p>静态初始化</p><p>new 类型[] {元素1, 元素2,  ……}<br>不指定长度，只指定每个元素。<br><del>静态初始化的简化语法，省略掉in[]，但是这种方法只能在定义数组变量初始值的时候进行使用</del>，只能在定义数组变量，并赋初始值时使用。</p></li><li><p>动态初始化<br>new 类型[] {元素1, 元素2,  ……}<br>只指定长度，不指定每个元素。<br>系统会自动为每个元素分配初始值，其分配规则是：</p><ul><li>所有数组元素为数值类型时，数组元素的初始值为0；</li><li>所有数组元素为boolean类型时，数组元素的初始值为false</li><li>所有数组元素为引用类型时，数组元素的初始值为null</li></ul></li></ol><h3 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h3><ol><li><p>数组都有一个length属性，该属性返回数组的长度</p><p>数组一旦创建，其长度是固定的，他在内存中位置也是固定的。</p></li><li><p>每个数组元素，就相当于一个变量。数组元素的类型，就是数组类型去掉一组方括号<br>访问数组元素：<br>数组元素[索引] ——索引从0开始。最后一个元素的索引是length-1<br>使用的元素超出数组长度，就会导致ArrayIndexOutOfBoundsException: 4（数组索引越界异常）</p></li><li><p>遍历数组 - 依次使用每个元素</p></li><li><p>使用for each循环遍历数组<br>for(元素类型 变量名：数组名){</p><p>​        // 可通过变量名访问每个元素、</p><p>}<br>数组有几个元素，该循环就执行几次，变量会自动、依次等于每个元素。<br>foreach遍历只能访问数组元素的值，不能修改数组元素的值。<br><strong>建议</strong>：永远不要在foreach循环中修改计数器的值！</p></li></ol><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="深入理解数组"><a href="#深入理解数组" class="headerlink" title="深入理解数组"></a>深入理解数组</h3><p>数组是一种引用类型，<strong>引用类型和基本类型的区别在哪里？</strong></p><p>java程序的内存可以分成两种：</p><h4 id="堆-heap-内存："><a href="#堆-heap-内存：" class="headerlink" title="-堆(heap)内存："></a>-堆(heap)内存：</h4><p>java虚拟机启动时分配的一块永久的、很大的内存区。堆内存只有一块。</p><p><strong>java程序必须要使用虚拟机才能运行！</strong>。内存区我们是看不到的。java-Xms可以设置初始java堆大小。比如手 java -Xmx256 内存只有245兆。很容易就会爆内存。 </p><p>Error occurred during initialization of VM<br>Too small initial heap</p><p>上面两行就是爆内存的报错</p><h4 id="栈-stack-内存："><a href="#栈-stack-内存：" class="headerlink" title="-栈(stack)内存："></a>-栈(stack)内存：</h4><p>每次方法运行分配一块临时、很小的内存区。</p><p>每个方法都有自己相应的栈区，方法结束时，对应的栈区就会被回收。</p><p>几个方法就有几个栈区</p><h4 id="在方法中定义的、局部变量（不管是什么类型），都会放入相应的方法栈中去。"><a href="#在方法中定义的、局部变量（不管是什么类型），都会放入相应的方法栈中去。" class="headerlink" title="-在方法中定义的、局部变量（不管是什么类型），都会放入相应的方法栈中去。"></a>-在方法中定义的、局部变量（不管是什么类型），都会放入相应的方法栈中去。</h4><h4 id="new出来的东西，都在堆内存"><a href="#new出来的东西，都在堆内存" class="headerlink" title="-new出来的东西，都在堆内存"></a>-new出来的东西，都在堆内存</h4><p>堆内存中的对象，如果没有引用变量指向它，那它就变成了trash，等待vm的垃圾回收机制回收它。</p><p>计算机的每个内存单元（Byte、字节)在操作系统中都有一个编号，就像是一栋大楼的每个房间号</p><p>【变量赋值的区别：】</p><p>-基本类型的赋值：直接将该值存入变量所在内存</p><p>-引用类型的赋值：将该对象所在第一个内存单元的编号（内存地址）存入变量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java——数组&quot;&gt;&lt;a href=&quot;#Java——数组&quot; class=&quot;headerlink&quot; title=&quot;Java——数组&quot;&gt;&lt;/a&gt;Java——数组&lt;/h1&gt;&lt;p&gt;数组：可以一次定义，就可以得到多个类型相同、功能相似的变量，本质还是变量&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java——类型转换</title>
    <link href="https://mr8god.cn/2020/04/09/Java/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>https://mr8god.cn/2020/04/09/Java/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-04-09T12:59:01.202Z</published>
    <updated>2020-04-09T12:58:55.434Z</updated>
    
    <content type="html"><![CDATA[<p>整形的注意点，</p><ol><li>直接给出一个整形整数值，该整数值默认为int型，但如果该整数位于byte、short的取值范围内，Java也可以直接把整数值当做byte、short处理，</li><li>如果你希望一个整数被当成long处理，必须在整数后添加L或者l。</li><li>整数有4种表达形式：<ol><li>十进制：常用。</li><li>八进制：以0开头，数值不超过7。</li><li>16进制：以0x或0X开头，数值不能超过F、a代表10、b代表11……f代表15。</li><li>二进制：以0b或0B开头，数值不能超过1。</li></ol></li></ol><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="自动转化：取值范围小的，自动转化为取值范围大的"><a href="#自动转化：取值范围小的，自动转化为取值范围大的" class="headerlink" title="自动转化：取值范围小的，自动转化为取值范围大的"></a>自动转化：取值范围小的，自动转化为取值范围大的</h3><p>byte&gt;short&gt;int &gt; long&gt; float&gt;double</p><p>​            char可以转化为int</p><p>每个字符都是有一个编号，计算机只存编号</p><p>short：-32768~+32768</p><p>char:0-65535</p><p>声明变量：</p><p>​            类型 变量[ = 初始值 ]；</p><p>类型 byte，</p><p>自动转化几条规则：</p><ol><li>所有整型都可以自动转成浮点型</li><li>所有整型都可以自动转化为long型</li><li>所有数值型，都可以自动转成double型</li></ol><p>记一下常识性的东西</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\r  <span class="number">13</span></span><br><span class="line"></span><br><span class="line">\n  <span class="number">10</span></span><br><span class="line"></span><br><span class="line">\t<span class="number">9</span></span><br><span class="line"></span><br><span class="line">\<span class="string">'39</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">\''</span><span class="number">34</span></span><br></pre></td></tr></table></figure><h3 id="强制转化："><a href="#强制转化：" class="headerlink" title="强制转化："></a>强制转化：</h3><p>上图上反过来转换，就需要强制转换</p><ol><li>浮点数转整数，砍掉小数部分</li><li>强制转换可能发生“溢出”</li></ol><h3 id="表达式类型的自动提升"><a href="#表达式类型的自动提升" class="headerlink" title="表达式类型的自动提升"></a>表达式类型的自动提升</h3><p>整个表达式的类型，与该表达式中最高等级的操作数的类型相同</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>算术运算符（7个）</p><p>+、-、*、/、%</p><p>++ ：将单个变量的值+1</p><p>​        放在变量之后，表示先用变量的值，再自加</p><p>​        放在变量之前，表示先自加，在用变量的值</p><p>—：将单个变量的值-1</p><p>​        放在变量之后</p><p>对于一些复杂运算需要使用math </p><h4 id="赋值运算符："><a href="#赋值运算符：" class="headerlink" title="赋值运算符：="></a>赋值运算符：=</h4><p>将=右边的值装入左边的容器（变量）</p><p>=左边只能是变量</p><p>=右边可以是任何复杂的表达式</p><p>大部分时候= 右边往往都是复杂的表达式</p><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>$&gt;$</p><p>$&gt;=$</p><p>$&lt;$</p><p>$&lt;=$</p><p>$==$</p><p>$~=$</p><p>比较运算符，用于比较两个变量或两个值，如果符合预期得到true，否则得到false</p><h4 id="逻辑运算符："><a href="#逻辑运算符：" class="headerlink" title="逻辑运算符："></a>逻辑运算符：</h4><p>只能对boolean值进行运算。</p><p>&amp;&amp;        与</p><p> &amp;</p><p>||        或</p><p>|</p><p>！        非</p><p>^        两个条件相同则为false；不同则为true</p><p>富 美</p><p>既富，也美 - and</p><p>富或美  </p><p>短路与和与的区别：如果第一个操作数已经是false，&amp;&amp;运算符不会算第二个操作数，称之为短路。</p><p>​                                    如果第一个操作数已经是false，&amp;运算符依然会计算第二个操作数，称之为不短路</p><p>||和|的区别：同理如短路与！</p><p>一般来说，编程时都用短路与和短路或</p><h4 id="位运算符："><a href="#位运算符：" class="headerlink" title="位运算符："></a>位运算符：</h4><p>它只能对整型（byte、short、int、long、char（0~65535））运算</p><p>负数的进制码：保存的是它的补码</p><p>原码：数，直接算出来叫原码。最高位，又叫做符号位，0代表正数；1代表负数</p><p>反码：除符号位之外，其他位都按位取反</p><p>补码：反码+1。</p><ol><li><p>&amp;：按位与。上下两位都是1时，得到的结果才是1。</p></li><li><p>|：按位或。上下两位有一个1时，得到的结果就是1。</p><p>与位运算符相当常用，当表示状态时，会用特定的数代表开关。文本状态：粗体（1）、斜体（2）、下划线（4）、中划线（8）。就可以靠位与运算符进行控制。</p><p>所有涉及到开关的设计都会用到位于运算符</p></li><li><p>~：按位取反，正数变成负的（绝对值+1），负数变为正的（绝对值-1）。可以通过数学定理证明</p></li><li><p>^：按位异或。上下两位相同时，得到的结果是1.不同的时候，得到的结果为0.</p></li><li><p>&lt;&lt;：左移。左移N位相当于乘以2的N次方</p><p>2乘以8，最快的算法：2&lt;&lt;3</p></li><li><p>$&gt;&gt;$：右移N位，就是除以2的N次方，会砍掉小数，所以在除不尽的情况下，结果会比实际结果略小</p></li><li><p>$&gt;&gt;&gt;$：无符号右移。不太常用<br>如果被移的数是正数，那么该运算符与$&gt;&gt;$运算符效果一样<br>如果被移的数是负数，被空出来的数高位高位总是补0——这个数就会变成正数。</p></li></ol><h4 id="扩展的赋值运算符："><a href="#扩展的赋值运算符：" class="headerlink" title="扩展的赋值运算符："></a>扩展的赋值运算符：</h4><p>a  += b;        a = (类型)（a + b),这种更加好用，因为他可以自动强制转换为原先的类型。</p><p>所以推崇这种写法。</p><p>a -= b             a = (类型)（a - b)</p><p>……………………</p><p>基本上，前面介绍的所有双目运算符都可以和=结合，形成扩展的赋值运算符</p><h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><p>逻辑表达式？ 值1：值2</p><p><strong>常用的是三目运算符的嵌套</strong>！！！</p><p>嵌套后的三目运算符可能返回3个，甚至于更多值的其中之一</p><h4 id="运算符的结合性和优先级"><a href="#运算符的结合性和优先级" class="headerlink" title="运算符的结合性和优先级"></a>运算符的结合性和优先级</h4><p>结合性：控制运算符的运算方向：从左到右？还是从右到左？</p><p>大部分运算符都是从左到右。=运算符是从右到左的</p><p>推荐，记不清的时候，用括号来保证优先级</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol><li>变量定义、复制（简单值、表达式）</li><li>8个基本类型：byte、short、int、long、float、double、char、boolean</li></ol><p>运算符</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ol><li>顺序结构：从上到下、逐行执行</li><li>分支结构：根据具体情况，做出判断</li><li>循环结构：根据条件，让一个或多个步骤<strong>重复</strong>执行很多次</li></ol><p>目前可能存在的问题：</p><ol><li>语法掌握其实并不熟练</li><li>缺乏正确的程序员思维</li></ol><h3 id="顺序结构："><a href="#顺序结构：" class="headerlink" title="顺序结构："></a><strong>顺序结构</strong>：</h3><p>不加什么控制，程序代码都是从上到下，依次执行</p><h3 id="分支结构："><a href="#分支结构：" class="headerlink" title="分支结构："></a><strong>分支结构</strong>：</h3><p>不加什么控制，程序代码都是从上到下，依次执</p><h4 id="if分支："><a href="#if分支：" class="headerlink" title="if分支："></a>if分支：</h4><h5 id="两个注意点："><a href="#两个注意点：" class="headerlink" title="两个注意点："></a>两个注意点：</h5><ol><li>如果条件执行体只有一条语句，条件执行体的花括号可以省略。<br>如果省略了花括号，<strong>if条件只控制到紧跟if条件的第一个分号。</strong></li><li>else。否则，就是对前面条件取反<br>建议：如果if语句中有多个else if块，一定要先处理范围小的条件</li></ol><h4 id="switch分支："><a href="#switch分支：" class="headerlink" title="switch分支："></a>switch分支：</h4><p>switch(表达式){</p><p>​    case 值1：</p><p>​                    执行体</p><p>​                    break；</p><p>​    case 值2：</p><p>​                    执行体</p><p>​                    break;</p><p>…………………………</p><p>​    default:</p><p>​                    执行体</p><p>​                    brake;</p><p>}</p><p>程序会计算switch表达式的值，表达式的值等于哪个case块，就执行哪个case块。</p><p>如果都不等于，就执行default块</p><p>Java的switch不能处理范围！</p><h5 id="两个注意点：-1"><a href="#两个注意点：-1" class="headerlink" title="两个注意点："></a>两个注意点：</h5><ol><li>switch分支的表达式之鞥是byte、char、short、int、枚举、Strin（从java7开始才可以）这六个类型。</li><li>如果不写break，会发生贯穿，<br>贯穿：java会从第一个匹配的case块开始执行，在遇到break之前，直接忽略case值执行每个case块的代码</li></ol><h3 id="循环分支"><a href="#循环分支" class="headerlink" title="循环分支"></a>循环分支</h3><h4 id="while循环："><a href="#while循环：" class="headerlink" title="while循环："></a>while循环：</h4><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><p>while(条件){</p><p>​        // 循环体</p><p>}</p><p>程序首先判断循环条件，如果循环条件为true，执行循环体；</p><p>循环体执行完后，再次判断循环条件，如果循环条件Wietrue，执行循环体；</p><p>直到最后一次判断，循环条件为false，结束循环。</p><p>循环条件执行次数 == 循环体执行次数 + 1</p><p>死循环：无限循环，永远不会停止的循环。</p><h5 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h5><ol><li><p>如果循环体只有一条语句，那么循环体 的花括号可以省略</p><p>如果省略了花括号，while条件只控制到紧跟while条件的第一个分号。</p></li></ol><h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h4><h5 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h5><p>do{</p><p>​    // 循环体</p><p>}while (条件)</p><p>程序先执行一次循环体。</p><p>循环体执行完之后，再次判断循环条件，如果循环条件为true，执行循环体；</p><p>知道最后一次判断，循环条件为false，结束循环。</p><p>循环条件执行次数 == 循环体执行次数</p><h5 id="特征：即使循环条件开始就是false，循环体也会执行一次。"><a href="#特征：即使循环条件开始就是false，循环体也会执行一次。" class="headerlink" title="特征：即使循环条件开始就是false，循环体也会执行一次。"></a>特征：即使循环条件开始就是false，循环体也会执行一次。</h5><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><p>语法：</p><p>for([初始化语句]; [循环条件] ; [迭代语句]){</p><p>​        // 循环体</p><p>}</p><p>所有循环开始前，先执行初始化语句，只执行一次。</p><p>程序判断循环条件，如果循环条件为true，执行循环体；</p><p>循环体执行完后，执行迭代语句，然后再次判断循环条件 ，如果循环条件为true，执行循环体</p><h5 id="for循环的几个用法："><a href="#for循环的几个用法：" class="headerlink" title="for循环的几个用法："></a>for循环的几个用法：</h5><ol><li><p>for循环中，只有两个分号是必须的，其他都是可以省略的。</p><p>如果省略循环条件，循环条件永远都是true。</p><p>一定要写条件语句，不写的话就是死循环了。</p></li><li><p>尽量不要在循环体内改变循环计数器的值</p></li><li><p>初始化语句也可以初始化多个变量，只要它们的数据类型相同即可。<br>迭代语句也可以有多条，多条迭代语句之间用逗号隔开即可。</p></li></ol><h4 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h4><p>循环里再次放置循环，此时里层循环相当于外层循环的一条语句</p><h4 id="break终止结束"><a href="#break终止结束" class="headerlink" title="break终止结束"></a>break终止结束</h4><p>结束循环，跳出循环，break可以带标签，用于结束标签所代表的循环</p><h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p>忽略本次循环continue后面的语句，重新开始执行下一次循环</p><p>所以：不带标签的continue语句，如果是循环体的最后一行，那是没有任何意义的</p><p>continue可以带标签，用于忽略标签所代表的循环，重新开始下一次标签所代表的循环</p><h4 id="return"><a href="#return" class="headerlink" title="return"></a>return</h4><p>结束方法</p><p>循环总是位于方法中的，return既然可以结束方法，无论他在多深的循环里，他可以直接结束</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整形的注意点，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直接给出一个整形整数值，该整数值默认为int型，但如果该整数位于byte、short的取值范围内，Java也可以直接把整数值当做byte、short处理，&lt;/li&gt;
&lt;li&gt;如果你希望一个整数被当成long处理，必须在整数后添加L或
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java类与对象</title>
    <link href="https://mr8god.cn/2020/04/09/Java/Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>https://mr8god.cn/2020/04/09/Java/Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-04-09T12:58:21.734Z</published>
    <updated>2020-04-09T12:58:16.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java类与对象"><a href="#Java类与对象" class="headerlink" title="Java类与对象"></a>Java类与对象</h1><p>面向对象：Java是一门面向对象的语言</p><p>类：某一类对象的统称。相当于是一个概念性的（不是具体存在的东西）</p><p>对象：现实中所能接触到的各种“东西”。</p><p>三句总决：定义类、创建对象、调用方法</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>[修饰符] class 类名</p><p>{</p><p>​        // 成员变量</p><p>​        // 方法</p><p>​        // 构造器</p><p>​        // 内部类</p><p>​        // 初始化块</p><p>}————类体</p><p>类中的五大成员</p><ol><li>修饰符：public、final|abstract。其他的都不能出现，顺序是无所谓的，但是void返回类型一定要在修饰符后边</li><li>类名：语法要求——只要是标识符即可<br>从专业角度来看：多个单词连缀而成。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>[修饰符] 类型 变量名 [ = 初始值];</p><p>修饰符： private| protected|public、final|abstract、static、（transient：序列化相关）</p><p>类型：任意基本类型或引用类型</p><p>变量名：驼峰写法，首字母小写，后面每个单词首字母大写。。。 成员变量，用于描述该类或对象的状态，因此通常建议用名词。项目中，只定义项目感兴趣的状态</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>[修饰符] 返回值类型 方法名(形参列表)</p><p>{</p><p>​        // 代码，之前所有的东西，各种流程控制，定义变量（数组），都是在这个里边写的</p><p>如果声明了返回值类型，必须有return语句。</p><p>}————-方法体</p><ol><li><p>修饰符： private| protected|public、final|abstract、static</p></li><li><p>返回值类型：任意基本类型或引用类型，可使用void</p></li><li><p>方法名：</p><ol><li>语法要求：只要是标识符即可</li><li>专业角度：驼峰写法，首字母小写，后面每个单词首字母大写。。。 成员变量，</li><li>方法：用于描述该类或对象的状态，因此通常建议用<strong>动词</strong>。</li><li>项目中，只定义项目感兴趣的状态</li></ol></li><li><p>形参列表：形参类型1 形参名, 形参类型2 形参名2，……</p><p>每个形参都满足“形参类型 形参名”的格式；多个形参之间用逗号隔开。<br>代表调用方法时要传入的参数。</p></li></ol><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>作用：new调用构造器来创建对象</p><p>如果你没有为类写构造器，系统会默认为该类提供一个无参数的构造器！！！！只能隐藏构造器，但是每个类都会是有构造器的</p><p>[修饰符] 构造器名(形参列表)</p><p>{</p><p>​        // 代码：定义变量（包括数组）、变量赋值、流程控制、数据语</p><p>如果声明了返回值类型，必须有return语句。</p><p>}————-构造器体</p><ol><li>修饰符：private|protected|public</li><li>构造器名必须与类名相同</li></ol><p>判断一个类是不是构造器，要看两点：构造器名是否与类名相同、是否有返回值</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类可以用来干什么呢？</p><ol><li>定义变量<br>所有类，都是引用类型。所有类，都可用于声明变量</li><li>调用static修饰方法或static修饰的变量</li><li>创建对象</li><li>派生子类 </li></ol><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>对象可以用来做什么</p><ol><li>调用无static修饰的成员变量</li><li>调用无static修饰的方法</li></ol><h4 id="类是引用类型"><a href="#类是引用类型" class="headerlink" title="类是引用类型"></a>类是引用类型</h4><p>数组，也是引用类型</p><p>java中的引用类型有很多，只要你定义了一个类，就多了一个引用类型</p><p>引用类型变量的赋值，只是将对象的首地址存入变量中</p><h3 id="this引用："><a href="#this引用：" class="headerlink" title="this引用："></a>this引用：</h3><p>this可以出现非static的方法、构造器中。作用如下：</p><ol><li>出现非static方法中，this代表了该方法的调用者。<br>“谁调用该方法，this就代表谁”</li><li>出现在构造器中，this就代表该构造器正在初始化的对象。</li></ol><p>this.     的很重要作用就是：用于区分方法或构造器的局部变量。</p><p>尤其是与成员变量同名时——更需要使用this进行区分。</p><h2 id="方法详解："><a href="#方法详解：" class="headerlink" title="方法详解："></a>方法详解：</h2><h3 id="方法的所属性："><a href="#方法的所属性：" class="headerlink" title="方法的所属性："></a>方法的所属性：</h3><ol><li>方法类似于函数。但与函数不同的是，方法不能存在，方法必须定义在类里面。</li><li>定义在类中的方法。从逻辑上来看：<br>如果该方法有static修饰，该方法属于类本身，应该用类调用。<br>如果该方法无static修饰，该方法属于对象本身。</li><li>方法不能独立执行。<br>方法一定要有调用者<br>【规则】如果你调用同一个类中方法，可以省略调用者，此时系统会添加默认的调用者。<pre><code>           如果该方法是无static的方法，添加this作为默认的调用者。</code></pre></li></ol><h3 id="形参个数可变的方法："><a href="#形参个数可变的方法：" class="headerlink" title="形参个数可变的方法："></a>形参个数可变的方法：</h3><p>类型… 形参名 ：这就是形参个数可变的方法</p><ul><li>本质就是数组。上面写法等同于：<br>类型[] 形参名</li><li>类型…<br>写法的好处是：调用方法时更加方便。即可直接传入多个元素，系统会自动将它们封装成数组。也可用数组。<br>写法的缺点是：类型…  这种写法只能作为形参列表的最后一个形参。<pre><code>                       【暗示】：一个方法最多只能有一个“个数可变”的形参</code></pre></li></ul><h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><p>方法里调用本身——递归带来了隐式循环。</p><p>递归要避免无限递归。一定要在某些情况下，不再调用方法自身，</p><p>这个时候可能就要说了，这些循环用for之类的循环分支语句不都是可以实现的吗？</p><p>对对对，你说的都对，但是有一种情况只能用递归哦    </p><p>假如我们有：</p><p>f(1) = 2;</p><p>f(2) = 5;</p><p>…</p><p>f(n) = f(n+2) - 2 *  f(n+1)</p><p>要计算：f(10)是多少//代码在40/Recursive   </p><p>【难点】：    要保证递归一定能出现递归结束的条件。</p><h3 id="方法重载："><a href="#方法重载：" class="headerlink" title="方法重载："></a>方法重载：</h3><p>在同一个类中有多个同名的方法，但这多个方法的形参列表不同</p><p>口诀：两同一不同</p><ul><li>修饰符不同不算重载；返回值类型不同也不算重载</li><li>当你要确定一个方法的时候，仅有方法名是不够的的，必须还要结合参数才能确定。</li></ul><h3 id="方法的传参机制："><a href="#方法的传参机制：" class="headerlink" title="方法的传参机制："></a>方法的传参机制：</h3><p>如果定义方法时声明了形参，调用方法时必须传入对应的方法</p><p><strong>Java的参数传递机制：值传递 ，传入的只是参数的副本，并不是参数本身！！！</strong></p><ul><li>如果传递的参数是基本参数，方法中对参数所做的修改 ，完全不会影响参数本身！</li><li>如果传递的参数是引用类型，参数的副本与参数本身指向同一个对象。<br>因此方法通过参数副本修改对象时，会影响参数本身所指向的对象</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java类与对象&quot;&gt;&lt;a href=&quot;#Java类与对象&quot; class=&quot;headerlink&quot; title=&quot;Java类与对象&quot;&gt;&lt;/a&gt;Java类与对象&lt;/h1&gt;&lt;p&gt;面向对象：Java是一门面向对象的语言&lt;/p&gt;
&lt;p&gt;类：某一类对象的统称。相当于是一个概念
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java变量详解</title>
    <link href="https://mr8god.cn/2020/04/09/Java/Java%E5%8F%98%E9%87%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>https://mr8god.cn/2020/04/09/Java/Java%E5%8F%98%E9%87%8F%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-04-09T12:57:33.307Z</published>
    <updated>2020-04-09T12:57:29.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java变量详解"><a href="#Java变量详解" class="headerlink" title="Java变量详解"></a>Java变量详解</h1><p>Java没有全局变量的概念！！！</p><p>Java变量</p><ul><li>成员变量：<ul><li>位置：类中定义成员变量<ul><li>类变量 ： 有static</li><li>实例变量 ： 无static</li></ul></li></ul></li><li>局部变量<ul><li>位置：方法中定义局部变量<ul><li>形参</li><li>普通局部变量</li><li>代码块的局部变量</li></ul></li></ul></li></ul><p>判断变量：</p><ol><li>首先看位置</li><li>然后看修饰符</li></ol><h2 id="成员变量："><a href="#成员变量：" class="headerlink" title="成员变量："></a>成员变量：</h2><p>可以不需要显式指定初始值，系统可以自动分配初始值；</p><p>初始值规则与数组元素的初始值规则完全能相同。</p><p><strong>观点</strong>：程序中，类本身只有一个；程序一定先有类，再有对象（实例）！！！</p><h3 id="类变量："><a href="#类变量：" class="headerlink" title="类变量："></a>类变量：</h3><p>类变量属于类本身，当系统初始化类时，就会为类分别分配空间，并执行初始化。</p><h3 id="实例变量："><a href="#实例变量：" class="headerlink" title="实例变量："></a>实例变量：</h3><p>类变量属于对象本身，系统每次创建对象时，都需要为该对象的实例变量分配空间，并执行初始化。</p><ul><li>严格来说：类变量，应该由类本身进行访问。<pre><code>                实例变量，应该由对象进行访问。</code></pre>Java的一种不知道有啥用的语法（或许可以出题？）：允许通过对象类访问类变量</li></ul><p>比如说static int test这种设立类变量的方法，但是我们在实际访问的时候，举个情景例子哈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Computer c1 = <span class="keyword">new</span> Computer();</span><br><span class="line">        </span><br><span class="line">        Computer c2 = <span class="keyword">new</span> Computer();</span><br><span class="line">       </span><br><span class="line">        System.out.println(c1.test);</span><br><span class="line">        System.out.println(c2.test);<span class="comment">// Java允许通过对象类访问类变量</span></span><br><span class="line">        c2.test = <span class="number">20</span>;</span><br><span class="line">        System.out.println(c2.test);</span><br><span class="line">        System.out.println(c1.test);</span><br><span class="line"><span class="comment">//        System.out.println(test);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边看起来c1，c2看起来是很不错，引用的是咱们的test类变量，其实Java中根本就没有这个玩意儿。这玩意儿开辟出来就是在堆内存中占了个位置，然后谁用它，它就变成谁，说实话目前我还没有找到正确使用这个东西的姿势，over。这边看起来用的c1，c2，其实全是Computer类引用的，效果和下面的代码一样！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Computer c1 = <span class="keyword">new</span> Computer();</span><br><span class="line"></span><br><span class="line">        Computer c2 = <span class="keyword">new</span> Computer();</span><br><span class="line"></span><br><span class="line">        System.out.println(Computer.test);</span><br><span class="line">        System.out.println(Computer.test);<span class="comment">// Java允许通过对象类访问类变量</span></span><br><span class="line">        c2.test = <span class="number">20</span>;</span><br><span class="line">        System.out.println(Computer.test);</span><br><span class="line">        System.out.println(Computer.test);</span><br><span class="line"><span class="comment">//        System.out.println(test);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以我建议</strong>：暂时我们就使用类调用类变量、类方法。</p><p>如果考试的时候，遇到用对象调用类变量、类方法的情况，第一步先把对象换成类。</p><h2 id="局部变量："><a href="#局部变量：" class="headerlink" title="局部变量："></a>局部变量：</h2><p>必须由程序员显式指定初始值，然后才能使用——否则编译报错；</p><p>局部变量的作用域很小，只在方法里有效；</p><p>离开了方法，局部变量就会失效</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java变量详解&quot;&gt;&lt;a href=&quot;#Java变量详解&quot; class=&quot;headerlink&quot; title=&quot;Java变量详解&quot;&gt;&lt;/a&gt;Java变量详解&lt;/h1&gt;&lt;p&gt;Java没有全局变量的概念！！！&lt;/p&gt;
&lt;p&gt;Java变量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;成员
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java——final变量</title>
    <link href="https://mr8god.cn/2020/04/08/Java/%E4%BB%8E%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E4%BB%A3%E7%A0%81%E6%88%91%E5%AD%A6%E4%B9%A0%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F/"/>
    <id>https://mr8god.cn/2020/04/08/Java/%E4%BB%8E%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E4%BB%A3%E7%A0%81%E6%88%91%E5%AD%A6%E4%B9%A0%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F/</id>
    <published>2020-04-08T14:03:15.481Z</published>
    <updated>2020-04-08T14:06:19.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从第一个Java代码我学习到了什么呢？"><a href="#从第一个Java代码我学习到了什么呢？" class="headerlink" title="从第一个Java代码我学习到了什么呢？"></a>从第一个Java代码我学习到了什么呢？</h1><p>emmmmmm，我先上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.experiment1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/816:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberIsPalindrome40</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">100000</span>;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">1</span>;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(max)%(max - min + <span class="number">1</span>) + min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = x;</span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>) &#123;</span><br><span class="line">            cur = cur * <span class="number">10</span> + num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur == x;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = getNum();</span><br><span class="line">        out.println(a);</span><br><span class="line">        out.println(<span class="string">"是"</span> + ((a+<span class="string">""</span>).length()) + <span class="string">"位数"</span> );</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">new</span> NumberIsPalindrome40().isPalindrome(a))&#123;</span><br><span class="line">            out.println(<span class="string">"咱们随机生成的数字："</span> + a + <span class="string">"是一个回文数呢！"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            out.println(<span class="string">"咱们随机生成的数字："</span> + a + <span class="string">"不是一个回文数哦！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从第一个Java代码我学习到了什么呢？&quot;&gt;&lt;a href=&quot;#从第一个Java代码我学习到了什么呢？&quot; class=&quot;headerlink&quot; title=&quot;从第一个Java代码我学习到了什么呢？&quot;&gt;&lt;/a&gt;从第一个Java代码我学习到了什么呢？&lt;/h1&gt;&lt;p&gt;em
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java——抽象类和接口</title>
    <link href="https://mr8god.cn/2020/04/08/Java/Java%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <id>https://mr8god.cn/2020/04/08/Java/Java%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-04-08T07:39:00.032Z</published>
    <updated>2020-04-09T15:30:50.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java——抽象类和接口"><a href="#Java——抽象类和接口" class="headerlink" title="Java——抽象类和接口"></a>Java——抽象类和接口</h1><ul><li>abstract关键字</li><li>抽象类</li><li>接口</li><li>JDK1.8/1.9接口的新特性</li><li>抽象类和接口的比较</li><li>面向对象的七个原则</li></ul><h2 id="abstract关键字"><a href="#abstract关键字" class="headerlink" title="abstract关键字"></a>abstract关键字</h2><p>主要修饰类和方法<br>一个方法没有方法体，就是抽象方法了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAbstract</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类包含了抽象方法，那么这个类必须就是抽象类</p><p>务必要记得，有花括号就是方法体。是一个方法声明占位，具体实现留待子类覆盖/重写</p><p>如果类里边没有抽象方法，类也可以是抽象类——抽象类可以没有抽象方法</p><p>抽象类不能够使用new初始化对象；如果我不想让别人实例化我的类，就可以采用抽象类的方法。</p><p>举个例子：目前我们所学的Calendar类就是一个典型的抽象类，她只有一个静态方法——getInstance()——作用：根据当前的Date获得日历对象。</p><p>全局变量是强耦合为什么不好的一个典型的例子，比如你修改了全局变量的类型，则所有使用该变量的代码会受到影响，因此必须检查、修改和重新测试所有这些代码。不仅如此，所有使用该变量的方法都将通过该变量而彼此耦合</p><p>我们要<strong>适度耦合</strong></p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Java中，接口有两种意思：</p><ol><li>是指概念性的接口，即指系统对外提供的所有服务，类的所有能够被外部使用者访问的方法构成了类的接口</li><li>是指用interface关键字定义的实实在在的接口哦，也称为接口类型</li></ol><p>interface：不怎么提属性，操作，只提这个对象对外提供的功能<br>举例：电视机（按钮接口、红外接口：遥控器）、洗衣机（控制面板、洗衣）</p><p>对于接口来说，只有public、static、final常量，没有实例变量</p><p>JDK1.8之前，一定是抽象方法，不需要使用abstract关键字修饰，接口中的内容可见性默认是public，无论是否用public</p><p>类和接口之间要使用implements关键字（UML：实现realization），意味着类实现了某个接口，类就有这个接口的功能了</p><h3 id="接口的作用"><a href="#接口的作用" class="headerlink" title="接口的作用"></a>接口的作用</h3><ul><li>声明期望实现一个或更多的类的方法</li><li>确定对象的编程接口而无需显示类的实际主体</li><li>捕捉非相关类之间的相似性而无需强制类的关系</li><li>通过声明实现几个接口的类来模拟多重继承</li></ul><h2 id="JDK8的新特性"><a href="#JDK8的新特性" class="headerlink" title="JDK8的新特性"></a>JDK8的新特性</h2><p>增加了默认方法</p><p>如果我们要改接口的话，那么我们使用了接口的所有类都需要更改；</p><p>方法冲突<br>一个类可以实现多个接口，也就是说有可能会发生默认方法冲突</p><ul><li>类中的方法优先级最高</li><li>如果无法根据第一条进行判断，那么子接口的优先级更高；函数签名相同时，优先选择拥有最具体实现的默认方法的接口，即如果B继承了A，那么B就比A更加具体</li><li>最后如果还是无法判断，实现多个接口的类必须<ul><li>创建自己的默认方法，来覆盖重写接口的默认方法</li><li>使用super调用指定接口的默认方法</li></ul></li></ul><h2 id="JDK1-9的新特性"><a href="#JDK1-9的新特性" class="headerlink" title="JDK1.9的新特性"></a>JDK1.9的新特性</h2><p>Java9不仅像Java8一样支持接口默认方法，同时还支持私有方法。<br>在Java9中，一个接口中能定义如下集中变量/方法</p><ul><li>常量</li><li>抽象方法</li><li>默认方法</li><li>静态方法</li><li>私有方法：private</li><li>私有静态方法：private static</li></ul><h2 id="关于抽象类，我再补补课"><a href="#关于抽象类，我再补补课" class="headerlink" title="关于抽象类，我再补补课"></a>关于抽象类，我再补补课</h2><p>abstract（抽象），它只能修饰两个东西：</p><ul><li>方法（抽象方法）</li><li>类（抽象类）</li></ul><p>emmmmm，这边加一个<strong>惨痛经验</strong>，<strong>抽象类的抽象方法，务必不能有方法体</strong><br>这很好理解：我们的抽象类是要给别人去重写的，如果我们给了，那还让人家咋重写，emmmmm，我暂时就这么记了！</p><p>abstract与final是<strong>互斥</strong>的！</p><p> 抽象类的特征：有得有失。<br>抽象类与普通类的区别只有4个字：有得有失。</p><ul><li><p>有得：得到一个新功能：抽象类可以拥有这个抽象方法。</p></li><li><p>有失：抽象类失去了一个功能：创建对象</p></li></ul><h3 id="抽象类必须有构造器"><a href="#抽象类必须有构造器" class="headerlink" title="抽象类必须有构造器"></a>抽象类必须有构造器</h3><p>因为抽象类的主要功能是：派生子类；因为子类的构造器一定会调用父类的构造器一次，因此抽象类必须有构造器。<br>而咱们的final是不能有子类，这就是与abstract互斥的原因啦</p><h4 id="抽象类里边可以没有抽象方法吗？"><a href="#抽象类里边可以没有抽象方法吗？" class="headerlink" title="抽象类里边可以没有抽象方法吗？"></a>抽象类里边可以没有抽象方法吗？</h4><p>可以的！</p><h4 id="抽象类里边能不能没有构造器呀？"><a href="#抽象类里边能不能没有构造器呀？" class="headerlink" title="抽象类里边能不能没有构造器呀？"></a>抽象类里边能不能没有构造器呀？</h4><p>可以的！</p><h4 id="抽象类里边能不能没有初始化块呀？"><a href="#抽象类里边能不能没有初始化块呀？" class="headerlink" title="抽象类里边能不能没有初始化块呀？"></a>抽象类里边能不能没有初始化块呀？</h4><p>可以的！</p><h4 id="抽象类里边能不能有成员变量呀？"><a href="#抽象类里边能不能有成员变量呀？" class="headerlink" title="抽象类里边能不能有成员变量呀？"></a>抽象类里边能不能有成员变量呀？</h4><p>可以的！</p><h4 id="抽象类里边能不能有类变量呀？"><a href="#抽象类里边能不能有类变量呀？" class="headerlink" title="抽象类里边能不能有类变量呀？"></a>抽象类里边能不能有类变量呀？</h4><p>可以的！</p><h4 id="上面开个玩笑哈，只要记住普通类有的，抽象类全都有，只是不能创建对象而已"><a href="#上面开个玩笑哈，只要记住普通类有的，抽象类全都有，只是不能创建对象而已" class="headerlink" title="上面开个玩笑哈，只要记住普通类有的，抽象类全都有，只是不能创建对象而已"></a>上面开个玩笑哈，只要记住普通类有的，抽象类全都有，只是不能创建对象而已</h4><h3 id="抽象方法：只有方法签名，没有方法体的方法"><a href="#抽象方法：只有方法签名，没有方法体的方法" class="headerlink" title="抽象方法：只有方法签名，没有方法体的方法"></a>抽象方法：只有方法签名，没有方法体的方法</h3><p>只有抽象类才能拥有抽象方法，普通类不能有抽象方法</p><p>由于咱们的抽象方法没有方法体，那么很明显这就意味着，抽象方法一定要被子类去重写<br>与此相反的是咱们的final：final的意思是——你可不能重写我的方法哦！ </p><p>抽象方法，一定要交给子类去实现（比如说重写），否则不能调用！</p><h4 id="抽象类的作用"><a href="#抽象类的作用" class="headerlink" title="抽象类的作用"></a>抽象类的作用</h4><ol><li>定义变量。我们的抽象类不能创建实例对象，那么我们的抽象类定义之后要赋值的时候，只能用它的子类的实例。（用子类的实例对父类赋值，这叫做<strong>向上转型</strong>在多态时有学习到这个东西）</li><li>调用类方法和类变量</li><li>派生子类——主要目的</li></ol><h4 id="抽象类派生子类："><a href="#抽象类派生子类：" class="headerlink" title="抽象类派生子类："></a>抽象类派生子类：</h4><p>【得出推论规则】：子类要么重写父类中所有的抽象方法，要么子类也只能是抽象的。</p><h2 id="关于接口，我再补补课"><a href="#关于接口，我再补补课" class="headerlink" title="关于接口，我再补补课"></a>关于接口，我再补补课</h2><h3 id="关于接口的基本知识"><a href="#关于接口的基本知识" class="headerlink" title="关于接口的基本知识"></a>关于接口的基本知识</h3><p>接口相当于一种彻底抽象的类，（其实枚举也类似于一个类）<br>接口体现的是一种规范——要暴露出来供大家遵守的规范。<br>所以接口里的所有东西都用public修饰，不管你写还是不写，始终有public修饰。既然默认都有的话，我们其实可以不用写public修饰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] interface 接口名 extends 父接口1，父接口2，……</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; 没有成员变量，只有常量。默认总是会添加public、static、final修饰。&#x2F;&#x2F; 既然默认都有，我们可以不写</span><br><span class="line">&#x2F;&#x2F; 抽象方法。Java8之后，类方法、默认方法（抽象添加方法体）</span><br><span class="line">&#x2F;&#x2F; 内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口是一种彻底抽象的类，抽象的类的话，那么抽象方法只能存在于抽象类。<br>接口里边只能有抽象方法，现在从Java8之后，接口开始有了类方法、方法体（可以说接口好像是被“污染了”，和以前的语法冲突了），但是呢，为了更大程度的和以前的方法体分开来，于是接口添加了<strong>默认方法</strong>这一概念。其实就是原来的<strong>抽象方法+方法体</strong></p><h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>默认方法就是实例方法，与原来抽象方法的规则完全一样，只不过抽象方法不能加方法体，于是默认方法加上default就可以加方法体了</p><p>接口里不能有初始化块，也不能有构造器</p><p>总结：接口里只有三大成员（常量、抽象方法、内部类）</p><p>接口的修饰符：public、<br>接口是彻底抽象，<strong>不能有final</strong>（final和抽象互斥）<br>抽象已经足够抽象了，因此不需要abstract更抽象了</p><p>【随处哔哔】private只能在类里边的类进行修饰，如果在外边那必是没有意义的呀</p><p>接口名：命名规范基本等同于类名。<br>                接口一般推荐使用形容词。<br>                （看看就好看看就好，我暂时还是看《阿里巴巴开发手册》）</p><h3 id="接口里的成员默认会添加public、static、final修饰"><a href="#接口里的成员默认会添加public、static、final修饰" class="headerlink" title="接口里的成员默认会添加public、static、final修饰"></a>接口里的成员默认会添加public、static、final修饰</h3><h4 id="final的变量初始化"><a href="#final的变量初始化" class="headerlink" title="final的变量初始化"></a>final的变量初始化</h4><p>final修饰的类变量必须在两个地方：定义的时候指定初始值、类初始化块指定初始值</p><p>但是接口里没有类初始化块，所以final修饰的变量（其实也是指定的啦，因为final默认在接口中的常量前面进行修饰的），那么很明显，我们默认用final修饰的变量一定且只能在指定初始值的时候进行指定（=）且进行赋初始值</p><h4 id="final的方法"><a href="#final的方法" class="headerlink" title="final的方法"></a>final的方法</h4><p>因为抽象类中的方法默认都是抽象方法，前头都戴着一定隐形的帽子（“abstract”），所以不用写abstract进行修饰</p><h3 id="接口的前世今生"><a href="#接口的前世今生" class="headerlink" title="接口的前世今生"></a>接口的前世今生</h3><h4 id="Java8以前的接口"><a href="#Java8以前的接口" class="headerlink" title="Java8以前的接口"></a>Java8以前的接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 所有成员变量前默认有public static final</span></span><br><span class="line">    <span class="keyword">int</span> MAX_PRESERVE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认有public abstract ，也就是默认是public abstract void test();</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java8之后的接口（有了main方法之后）"><a href="#Java8之后的接口（有了main方法之后）" class="headerlink" title="Java8之后的接口（有了main方法之后）"></a>Java8之后的接口（有了main方法之后）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前头默认public修饰</span></span><br><span class="line">    <span class="keyword">int</span> MAX_PRESERVE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认有public abstract</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Java8之后可以有static方法，所以就能定义main方法</span></span><br><span class="line">    <span class="comment">// 因此接口也可以直接运行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我再加点东西哈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前头默认public修饰</span></span><br><span class="line">    <span class="keyword">int</span> MAX_PRESERVE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的public可以不写，但是static一定要写，因为不写就成了实例方法了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是类方法，因为我有static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【再随处哔哔】方法重载的规则是：两同一不同</p><ul><li>形参列表不同</li><li>方法名相同</li><li>修饰符不同</li></ul><h3 id="接口有什么用呢？"><a href="#接口有什么用呢？" class="headerlink" title="接口有什么用呢？"></a>接口有什么用呢？</h3><ul><li>定义变量，只能用实现类的实例来赋值（向上转型）</li><li>调用类方法或类变量</li><li>派生实现类</li></ul><h3 id="实现接口的语法是？"><a href="#实现接口的语法是？" class="headerlink" title="实现接口的语法是？"></a>实现接口的语法是？</h3><p>首先我们看一下完整的类的语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 父接口1，父接口2，………</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">// 五大成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，上面的也是实现接口的语法了！嘿嘿嘿</p><p>重写接口中的方法只能用public修饰！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java——抽象类和接口&quot;&gt;&lt;a href=&quot;#Java——抽象类和接口&quot; class=&quot;headerlink&quot; title=&quot;Java——抽象类和接口&quot;&gt;&lt;/a&gt;Java——抽象类和接口&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;abstract关键字&lt;/li&gt;
&lt;li&gt;抽象类
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java——final变量</title>
    <link href="https://mr8god.cn/2020/04/07/Java/Java%E2%80%94%E2%80%94final%E5%8F%98%E9%87%8F/"/>
    <id>https://mr8god.cn/2020/04/07/Java/Java%E2%80%94%E2%80%94final%E5%8F%98%E9%87%8F/</id>
    <published>2020-04-07T13:05:30.728Z</published>
    <updated>2020-04-08T14:06:28.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java——final变量"><a href="#Java——final变量" class="headerlink" title="Java——final变量"></a>Java——final变量</h1><p>可以修饰变量（各种变量）、方法、类。</p><p>final和abstract是互斥的：永远都不能够同时出现！</p><h2 id="final修饰变量"><a href="#final修饰变量" class="headerlink" title="final修饰变量"></a>final修饰变量</h2><p>作用：该变量被赋初始值之后，不能被重新赋值！<br>            final修饰的变量<strong>必须</strong>被赋值，且只能被赋值<strong>一次</strong></p><h2 id="final修饰成员变量"><a href="#final修饰成员变量" class="headerlink" title="final修饰成员变量"></a>final修饰成员变量</h2><p>普通成员变量（非final的成员变量），程序员可以不显式指定初始值，系统会为之分配默认初始值，初始值分配规则与数组元素的初始值分配规则完全相同！</p><p>final 成员变量，程序员必须显式指定初始值</p><ul><li><p>final实例变量，必须显式指定初始值，<strong>只能指定一次</strong>。<strong>只能在以下三个位置的其中之一指定：</strong></p><ul><li>定义时指定为初始值。</li><li>实例初始化块</li><li>每个构造器都需要显示指定一次初始值</li></ul><p>上面3个位置的本质其实只有一个，就是构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Final</span>实例变量 </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        age = 24;// 这边错误，被final修饰的成员变量不能被赋值两次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们这样写就没有问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Final</span>实例变量 </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line">    &#123;</span><br><span class="line">        age = <span class="number">24</span>;<span class="comment">// 这边错误，被final修饰的成员变量不能被赋值两次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再一个正确示范</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Final</span>实例变量 </span>&#123;</span><br><span class="line">    <span class="comment">// final实例变量必须显式指定初始值，而且只能在3个位置中指定</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> lg;</span><br><span class="line">    <span class="keyword">public</span> Final实例变量()</span><br><span class="line">    &#123;</span><br><span class="line">        lg = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>final类变量，必须显示指定初始值。只能在以下2个位置的其中之一指定：</p><ul><li>定义时指定初始值</li><li></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java——final变量&quot;&gt;&lt;a href=&quot;#Java——final变量&quot; class=&quot;headerlink&quot; title=&quot;Java——final变量&quot;&gt;&lt;/a&gt;Java——final变量&lt;/h1&gt;&lt;p&gt;可以修饰变量（各种变量）、方法、类。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java的包装类</title>
    <link href="https://mr8god.cn/2020/04/07/Java/Java%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <id>https://mr8god.cn/2020/04/07/Java/Java%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB/</id>
    <published>2020-04-07T09:19:37.077Z</published>
    <updated>2020-04-08T14:06:24.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java的包装类"><a href="#Java的包装类" class="headerlink" title="Java的包装类"></a>Java的包装类</h1><p>Java有8大基本类型：int、float、double、long、boolean、byte、char、short</p><p>这8个基本类型都不能当成对象使用，不是引用类型，而且也不能接受null值。null值只能赋值给引用类型。</p><p>为了解决上面的问题，Java为8个基本类型提供了对应的包装类——可将它们包装成对象。</p><div class="table-container"><table><thead><tr><th>基本数据类型</th><th>对应的包装类</th></tr></thead><tbody><tr><td>int</td><td>Int</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Char</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>float</td><td>Float</td></tr></tbody></table></div><p><strong>自动装箱</strong>：基本类型的值可以自动当成包装类<br><strong>自动拆箱</strong>：包装类的实例可以自动当成基本类型的值使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关于自动装箱和自动拆箱的代码实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 包装类 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int i = null; // 基本类型不接受null值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2可以自动装箱成Integer</span></span><br><span class="line">        Integer in = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.3自动装箱Double，Double向上转型为</span></span><br><span class="line">        Object ob = <span class="number">2.3</span>;</span><br><span class="line"></span><br><span class="line">        Boolean b = <span class="keyword">true</span>;<span class="comment">// 自动装箱</span></span><br><span class="line"></span><br><span class="line">        Long lg = <span class="number">3L</span>;</span><br><span class="line"></span><br><span class="line">        Long result =  lg * in;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【建议】：做项目的时候，通常来说使用包装类来声明变量。<br>                    好处是：反正基本类型能做的，它都可以做；它还可以当成对象使用。还可以接受null</p><p>包装类的方法：<br>                方法可将字符串转成对应的基本类型值。</p><p>NumberFormatException：要转的字符串不符合数值格式，将会引发该异常。</p><p>当程序对Integer使用自动装箱时，它有一个缓存机制，它会缓存在-128 ~ 127之间的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">heiheihei</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i = <span class="number">20</span>; <span class="comment">// 在-128 ~ 127之间，缓存</span></span><br><span class="line">        Integer j = <span class="number">20</span>; <span class="comment">// 直接用缓存中对象。</span></span><br><span class="line">        System.out.println(i == j);</span><br><span class="line"></span><br><span class="line">        Integer c = <span class="number">204</span>; <span class="comment">// 不在-128 ~ 127之间，不缓存，因为这里边的204超过范围 了</span></span><br><span class="line">        Integer d = <span class="number">204</span>; <span class="comment">// 重新创建</span></span><br><span class="line">        System.out.println(c == d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="两个要被重写的方法："><a href="#两个要被重写的方法：" class="headerlink" title="两个要被重写的方法："></a>两个要被重写的方法：</h2><h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>程序打印对象，或把对象自动转字符串的时候，实际上用的都是该对象的toString()方法的返回值。</p><p>【默认的toString】Object提供的toString返回的是类名@hashCode 方法返回值<br>重写toString：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// toString方法重写实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple123</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参数的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple123</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化全部成员变量的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple123</span><span class="params">(String color, <span class="keyword">double</span> weight)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.color;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">double</span> weight)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWeight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Apple[color="</span> + color</span><br><span class="line">                + <span class="string">", weight="</span> + weight</span><br><span class="line">                + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleTest1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple123 ap = <span class="keyword">new</span> Apple123(<span class="string">"红色"</span> , <span class="number">2.3</span>);</span><br><span class="line">        <span class="comment">// 程序打印对象，或把对象自动转字符串的时候，实际上用的都是该对象的toString()方法的返回值。</span></span><br><span class="line">        <span class="comment">// 下面两行代码是完全相同的</span></span><br><span class="line">        System.out.println(ap);</span><br><span class="line">        System.out.println(ap.toString());</span><br><span class="line"></span><br><span class="line">        Apple123 ap2 = <span class="keyword">new</span> Apple123(<span class="string">"蔡徐坤"</span> , <span class="number">188</span>);</span><br><span class="line">        System.out.println(ap2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任何对象 + ""，就会变成字符串</span></span><br><span class="line">        String str = ap2 + <span class="string">""</span>;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><p>== 如果判断两个引用变量，要求两个引用变量指向同一个对象时，才会返回true。</p><p>但是如果我们直接在main里用equals，还是false，原因是：<br>【默认的equals】Object提供的equals方法，判断两个对象相等的标准与 == 是完全一样的。<br>因此我们要重写equals：根据业务规则来提供两个对象相等的标准。<br>实际项目中，用来作为equals比较的关键成员变量，通常并不需要使用全部的成员变量<br>——只要用它们关键的成员变量即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equals方法重写实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参数的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化全部成员变量的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goat</span><span class="params">(String color, <span class="keyword">double</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// color的setter和getter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// weight</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// this和obj指向同一个对象</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要求obj不为null，且obj必须是Goat</span></span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp; obj.getClass() == Goat<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        </span>&#123;</span><br><span class="line">            Goat target = (Goat)obj;</span><br><span class="line">            <span class="comment">// 业务要求有几个关键属性，此处就比较几个关键属性，比如说这边只有一个color需要比较</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.color.equals(target.color)</span><br><span class="line">                    &amp;&amp; <span class="keyword">this</span>.weight == target.weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Goat goat1 = <span class="keyword">new</span> Goat(<span class="string">"黑色"</span> , <span class="number">78.2</span>);</span><br><span class="line">        Goat goat2 = <span class="keyword">new</span> Goat(<span class="string">"黑色"</span> , <span class="number">78.2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// goat1与goat2分别指向两个不同的对象，因此==判断返回false。</span></span><br><span class="line">        System.out.println(goat1 == goat2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写equals方法，根据业务规则来判断两个对象是否相等。</span></span><br><span class="line">        System.out.println(goat1.equals(goat2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h4 id="static并不是静态的意思。"><a href="#static并不是静态的意思。" class="headerlink" title="static并不是静态的意思。"></a>static并不是静态的意思。</h4><p>static是类的意思， 有static的成员属于类成员，没有static的成员属于势力成员</p><p>static是否可以修饰局部变量？——局部变量不属于成员，因此不能用static修饰。</p><p>static能否修饰外部类？ —— 外部类不属于成员，因此不能用static修饰。</p><h4 id="static修饰的成员：成员变量、方法、初始化块、内部类"><a href="#static修饰的成员：成员变量、方法、初始化块、内部类" class="headerlink" title="static修饰的成员：成员变量、方法、初始化块、内部类"></a>static修饰的成员：成员变量、方法、初始化块、内部类</h4><p>所有类成员，都只能用类名调用！</p><p>Java语法是不好，允许通过对象来调用类成员，是没有意义的 from 李刚老师</p><p>面试的笔试题中，如果遇到使用对象来调用类成员的情形，先把对象改成类——题目马上一目了然。</p><h4 id="static考点（笔试中非常常见）"><a href="#static考点（笔试中非常常见）" class="headerlink" title="static考点（笔试中非常常见）"></a>static考点（笔试中非常常见）</h4><p>static成员不能访问非static成员。<br>非static成员可以访问static成员！</p><p>static成员（4种）不能访问非static成员（5种：方法、变量、构造器、内部类、初始化块）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 方法 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"info"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        info();//Error:(8, 9) java: 无法从静态上下文中引用非静态 方法 info()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 变量  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(age);//Error:(5, 28) java: 无法从静态上下文中引用非静态 变量 age</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 内部类 </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 静态访问，使用了非静态内部类</span></span><br><span class="line"><span class="comment">//        A a = new A();//Error:(9, 15) java: 无法从静态上下文中引用非静态 变量 this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 初始化块 </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;<span class="comment">// 静态成员</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        age = <span class="number">20</span>;<span class="comment">// 非静态成员</span></span><br><span class="line">        <span class="comment">//无法从静态上下文中引用非静态 变量 age</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 初始化块2 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"info 方法"</span>);<span class="comment">// 非静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        info();<span class="comment">// 静态成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 初始块3 </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>最早来自于建筑行业，早期优秀建筑设计师针对建筑给了很多优秀的建筑建议。比如房子有大窗户会更好一点，诸如此类的建筑建议</p><p>对于一批经常出现的设计场景，前人总结出来的比较成功的设计——这就是设计模式。<br>后面的人就应该学习、并模仿他们，从而提高我们的代码质量。</p><p>其中<strong>单例模式</strong>就是设计模式的一种：在某些场景下，某些类只需要（只能）创建一个实例。<br>比如系统的窗口管理器。只能有一个。<br>数据库引擎访问点，整个数据库，Java程序所在JRE环境……都只需要产生一个实例。<br>此时就应该采用单例模式</p><h3 id="如何设计单例模式？"><a href="#如何设计单例模式？" class="headerlink" title="如何设计单例模式？"></a>如何设计单例模式？</h3><ol><li>隐藏构造器——避免被创建实例</li><li>暴露一个static的方法，该方法用于创建实例<br>该方法还需要保证该类只会产生一个实例 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line">    <span class="comment">// 构造器隐藏</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴露一个static方法，用于创建实例变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         Singleton s1 = Singleton.instance();</span><br><span class="line">         Singleton s2 = Singleton.instance();</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java的包装类&quot;&gt;&lt;a href=&quot;#Java的包装类&quot; class=&quot;headerlink&quot; title=&quot;Java的包装类&quot;&gt;&lt;/a&gt;Java的包装类&lt;/h1&gt;&lt;p&gt;Java有8大基本类型：int、float、double、long、boolean、byte
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>面向对象快速回顾(以便于考试快速回顾哈！)</title>
    <link href="https://mr8god.cn/2020/04/07/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE/"/>
    <id>https://mr8god.cn/2020/04/07/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE/</id>
    <published>2020-04-07T08:32:43.436Z</published>
    <updated>2020-04-08T14:06:38.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象快速回顾"><a href="#面向对象快速回顾" class="headerlink" title="面向对象快速回顾"></a>面向对象快速回顾</h1><p>345</p><p>3种类型：类、接口、枚举</p><p>4个修饰符：private|protected|public、final、static、abstract</p><p>5个成员</p><h2 id="定义类的语法"><a href="#定义类的语法" class="headerlink" title="定义类的语法"></a>定义类的语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 类名 extends 父类</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; 5大成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义成员变量"><a href="#定义成员变量" class="headerlink" title="定义成员变量"></a>定义成员变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 类型 变量名[ &#x3D; 初始值];</span><br></pre></td></tr></table></figure><h2 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 返回值类型 方法名（形参列表）</span><br><span class="line">&#123;</span><br><span class="line">语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义构造器"><a href="#定义构造器" class="headerlink" title="定义构造器"></a>定义构造器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 构造器名（形参列表）</span><br><span class="line">&#123;</span><br><span class="line">语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义初始化块"><a href="#定义初始化块" class="headerlink" title="定义初始化块"></a>定义初始化块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[static] &#123;</span><br><span class="line">语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类用于干甚？"><a href="#类用于干甚？" class="headerlink" title="类用于干甚？"></a>类用于干甚？</h2><ul><li>定义变量</li><li>创建对象</li><li>调用类、方法或者是访问类变量</li><li>派生子类</li></ul><h2 id="对象用于干甚？"><a href="#对象用于干甚？" class="headerlink" title="对象用于干甚？"></a>对象用于干甚？</h2><ul><li>调用实例方法或访问实例变量</li></ul><h2 id="方法（传参机制、递归方法、形参个数可变的方法、方法重载）"><a href="#方法（传参机制、递归方法、形参个数可变的方法、方法重载）" class="headerlink" title="方法（传参机制、递归方法、形参个数可变的方法、方法重载）"></a>方法（传参机制、递归方法、形参个数可变的方法、方法重载）</h2><h2 id="变量（判断变量：先看位置，再看static；成员变量和局部变量）"><a href="#变量（判断变量：先看位置，再看static；成员变量和局部变量）" class="headerlink" title="变量（判断变量：先看位置，再看static；成员变量和局部变量）"></a>变量（判断变量：先看位置，再看static；成员变量和局部变量）</h2><h2 id="构造器（构造器重载、this调用）"><a href="#构造器（构造器重载、this调用）" class="headerlink" title="构造器（构造器重载、this调用）"></a>构造器（构造器重载、this调用）</h2><p>this调用——出现在构造器的第一行，表明调用同一个类中重载的构造器</p><h2 id="初始化块（实例初始化块、类初始化块）"><a href="#初始化块（实例初始化块、类初始化块）" class="headerlink" title="初始化块（实例初始化块、类初始化块）"></a>初始化块（实例初始化块、类初始化块）</h2><p>实力初始化块：本质是构造器所有代码之前的代码；</p><p>类初始化块：本质是该类第一次被主动执行时，只运行一次。</p><h2 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h2><p>private —&gt; 不写 —&gt; protected —&gt; public</p><h2 id="继承、多态"><a href="#继承、多态" class="headerlink" title="继承、多态"></a>继承、多态</h2><p>Java是单继承的。</p><p>方法重写：两同两小一大。</p><p>子类构造器一定会调用父类构造器一次：创建任何对象，都是从Object的构造器开始执行的。</p><p>多态中：</p><p>​    方法执行：总是动态绑定实际类型的方法。<br>​                        强制转换、instanceof - 必须在有继承关系的两个类型之间进行处理，否则会编译报错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面向对象快速回顾&quot;&gt;&lt;a href=&quot;#面向对象快速回顾&quot; class=&quot;headerlink&quot; title=&quot;面向对象快速回顾&quot;&gt;&lt;/a&gt;面向对象快速回顾&lt;/h1&gt;&lt;p&gt;345&lt;/p&gt;
&lt;p&gt;3种类型：类、接口、枚举&lt;/p&gt;
&lt;p&gt;4个修饰符：private|p
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java面向对象基础回顾</title>
    <link href="https://mr8god.cn/2020/04/06/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/"/>
    <id>https://mr8god.cn/2020/04/06/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/</id>
    <published>2020-04-06T15:52:38.083Z</published>
    <updated>2020-04-08T09:28:02.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java面向对象基础回顾"><a href="#Java面向对象基础回顾" class="headerlink" title="Java面向对象基础回顾"></a>Java面向对象基础回顾</h1><p>定义类、创建对象、调用方法</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><pre><code>[修饰符] class 类名{    //成员变量    //方法    //构造器    //初始化块    //内部类}</code></pre><h2 id="定义成员变量"><a href="#定义成员变量" class="headerlink" title="定义成员变量"></a>定义成员变量</h2><p>[修饰符]    类型    变量名[ = 初始值]；</p><h2 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h2><pre><code>[修饰符]    返回值类型    方法名（形参列表）{    // 各种代码。定义变量、赋值语句、流程控制、输出语句}</code></pre><h2 id="定义构造器"><a href="#定义构造器" class="headerlink" title="定义构造器"></a>定义构造器</h2><pre><code>[修饰符]    构造器名（形参列表）{    // 各种代码。定义变量、赋值语句、流程控制、输出语句}</code></pre><p>构造器，很像一个特殊的方法</p><p>跟方法的两点区别：</p><ol><li>没有返回值类型声明，</li><li>构造器名必须类名相同。</li></ol><p>构造器作用：用于初始化对象——构造器永远属于实例。它不可能用static修饰。</p><h2 id="类可以用来干什么？"><a href="#类可以用来干什么？" class="headerlink" title="类可以用来干什么？"></a>类可以用来干什么？</h2><ol><li>定义变量。所有类都是引用类型。</li><li>调用类变量或类方法。</li><li>创建对象。</li><li>派生子类。</li></ol><h2 id="对象可以用来干什么？"><a href="#对象可以用来干什么？" class="headerlink" title="对象可以用来干什么？"></a>对象可以用来干什么？</h2><ol><li>调用实例变量</li><li>调用实例方法</li></ol><p>调用方法或变量：</p><pre><code>    调用者.方法([参数]);    调用者.实例变量;</code></pre><h2 id="方法详解"><a href="#方法详解" class="headerlink" title="方法详解"></a>方法详解</h2><ul><li>方法所属性。<ul><li>从定义的角度来看，方法不能独立定义，方法必须定义在类里面。</li><li>从调入的角度来看，方法不能独立执行，方法必须有调入者才能执行。<ul><li>类方法：也称静态方法，在方法前加static关键字，就代表这个方法属于这个类本身，不属于它的任何实例。换句话说，这个方法不通过实例进行调用，并且所有实例都共享这一个方法，对方法的调用各个实例相互可见。</li><li>实例方法：一个方法如果不加上static关键字，那么这个方法就是实例方法。意思是它属于类的某个实例，通过这个实例调用它，对类的其他实例不产生影响。</li><li>无论如何，方法都需要调用者，区别在于你在写的时候，要根据方法的类型，是类方法就用类名，是实例方法就用对象去调用它。有些情况下，</li><li>在同一个类里面的一个方法调用另一个方法，这个时候可以省略前面的调用者。省略也分两种情况，<ul><li>如果被调用的是实例方法，那么省略的就是；</li><li>如果被调用的是类方法，那么省略的就是类名（不是对象哦！）</li></ul></li></ul></li></ul></li></ul><p>我再补充几句哈，免得有人看不懂，上面其实说得就是这么个意思，如果你用的是静态方法（前头加static的那个），那么这边建议你用类名调用，不建议了，强制比较好一点。然后呢，这边又提出了个省略型，静态方法的调用呢，我们甚至可以省略掉类名，直接上咱们的方法。</p><p>如果你使用的是非静态方法（不加static，亦或者叫做实例方法），那么你就必须得创建一个对象，然后用对象来调用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fn1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fn2"</span>);</span><br><span class="line">        Test.fn1();<span class="comment">// 这边也可以直接省略掉Test.，比如说向下边这么写</span></span><br><span class="line">        <span class="comment">//fn1();  // 这就是上面说的，直接省略掉类名，上咱们的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">        t.fn2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>形参个数可变的方法</li><li>递归方法：</li><li>方法重载：2同1不同</li><li>方法的传参机制：值传递，传递的是参数的副本，并不是参数本身</li></ul><h2 id="变量的详解"><a href="#变量的详解" class="headerlink" title="变量的详解"></a>变量的详解</h2><p>成员变量（类里面定义）</p><ul><li>类变量。有static。静态变量</li><li>实例变量。无static。非静态变量</li></ul><p>成员变量，无需由程序员显式指定初始值，系统会为之分配默认初始值；</p><p>初始值规则：与数组元素的初始值规则完全相同</p><ul><li><p>类变量：是在第一次用该类的时候，系统会为该类变量分配空间，并初始化。</p><p>每个类的类变量都只有一个</p></li><li><p>实例变量：每次创建对象，系统都会为该对象的实例变量分配空间，并初始化。</p><pre><code>  程序中有几个对象，系统就会为这些对象的实例变量分配对应的空间。</code></pre></li></ul><p>局部变量（方法里定义）</p><ul><li>形参</li><li>方法里局部变量</li><li>代码块的局部变量</li></ul><p>局部变量</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装、继承、多态——面向对象的3大特征。</p><p>封装包含了两方面的内容</p><ul><li>隐藏：隐藏的内部实现细节。</li><li>暴露：将一些操作界面暴露出来。<br>如果通过暴露的界面来操作对象，该对象的内部状态不会被破坏。</li></ul><p>简而言之：封装要求合理隐藏、合理暴露、</p><ul><li>通过访问控制器实现：</li></ul><p>private -&gt;         不写        -&gt;        protected        -&gt;        public</p><p>private（类访问权限）：该修饰符修饰的成员，只能在该类中被访问。</p><p>不写（包访问权限）：该修饰符修饰的成员，只能在该类及其该类所在包中被访问。</p><p>protected（子类访问权限）：该修饰符修饰的成员，只能在该类、及其该类所在包、该类的子类中被访问。</p><p>public（公共）：该修饰符修饰的成员可以在任意地方被访问。</p><div class="table-container"><table><thead><tr><th></th><th>private</th><th>不写</th><th>protected</th><th>public</th></tr></thead><tbody><tr><td>当前类</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>同一个包</td><td>×</td><td>√</td><td>√</td><td>√</td></tr><tr><td>子类</td><td>×</td><td>×</td><td>√</td><td>√</td></tr><tr><td>任意</td><td>×</td><td>×</td><td>×</td><td>√</td></tr><tr><td></td><td>彻底隐藏</td><td>部分隐藏</td><td>部分暴露</td><td>彻底暴露</td></tr></tbody></table></div><p>指导原则：</p><ol><li>成员变量（实例变量），通常用private修饰，为了隐藏实现细节</li><li>为每个成员变量提供getter、setter方法，用于控制该成员变量</li><li>需要暴露的方法，通常用public修饰</li><li>如果希望一个方法主要用于被子类重写，用protected修饰。</li></ol><ul><li><p>包<br>不同公司完全可以定义同名的类，为解决类名冲突的问题，不同公司不同项目的类名重复的问题。<br>Java就引入了“包”的机制。</p><p>举例理解：同一个班的两个同名的同学，为了区别他们，我们通常 会加一些修饰语，比如说“大江”“小江”<br>这边就是在类名前面添加一个前缀。<br>Java如何为类定义包？</p><ul><li>在源代码中用package包名；</li><li>将生成class文件要放在对应的文件结构下。</li></ul><p>包名的命名规范：语法要求，只要标识符即可</p><pre><code>          专业要求，推荐用公司域名倒写：比如org.fkjava.项目名;就挺好。</code></pre><p>【备注】一旦你为类指定了包名之后，使用该类时应该用完整类名：包名+类名</p></li><li><p>导入包<br>impo的作用：为了省略写包名。</p><pre><code>                    如果不用import，每次用类时都需要使用包名+类名的形式。</code></pre><ul><li>import 包名.类名；——每次导入一个类</li><li>import 包名.* ——导入指定的所有类</li><li>Java程序默认已导入java.lang包下所有包</li></ul></li><li>静态导入 import static<ul><li>import的作用：为了省略写包名。</li><li>import static的作用：可以省略写类名。<pre><code>                                  用于导入指定类的所有静态成员，导入之后，即可省略写类名。</code></pre></li><li>import static 包名.类名.静态成员名; ——每次只导入一个静态成员。</li><li>import static 包名.类名.*;  ——导入指定类的所有静态成员。</li></ul></li><li>Java源程序的结构：<br>一条package语句<br>N条import语句<br>N个class定义</li></ul><h2 id="构造器详解"><a href="#构造器详解" class="headerlink" title="构造器详解"></a>构造器详解</h2><h3 id="构造器规则"><a href="#构造器规则" class="headerlink" title="构造器规则"></a>构造器规则</h3><ol><li>构造器用于初始化对象。</li><li>构造器如何调用？必须用new来调用啦。这样就可以返回一个初始化完成的对象。</li><li>如果你不为一个类提供构造器，那么系统会自动为该类提供一个无参数的构造器</li></ol><h2 id="构造器重载"><a href="#构造器重载" class="headerlink" title="构造器重载"></a>构造器重载</h2><p>一个类中可以定义多个构造器（因此构造器名必然相同），必须要求形参列表不同——这就是构造器的重载</p><p>this调用与this引用</p><p>this引用：this紧跟一个。<br>                    this.name;<br>                    this.walk();</p><p>this调用：this紧跟圆括号。<br>                 this（参数）<br>                    this调用代表调用同一个类中重载的构造器——this调用只能出现在【构造器】的【第一行】</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>封装、继承、多态——面向对象三大特征</p><h3 id="理解继承"><a href="#理解继承" class="headerlink" title="理解继承"></a>理解继承</h3><p>苹果类继承了水果类</p><p>老虎继承了动物类</p><p>东北虎继承了老虎类</p><p>Java的继承：是一种类与类之间关系<br>                        是一种由一般到特殊的关系，子类是一种特殊的父类<br>                        子类实例，完全可以当做父类实例来使用！</p><p>父类（超类、基类、大类，一些别称）；</p><p>子类（派生类、小类：一些别称）。</p><h3 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 类名 extends 父类</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明</p><ul><li>Java是单继承，只能有一个直接父类。</li><li>如果你不显式继承父类，Java默认是继承Object类（JDK系统提供的类）</li></ul><p>子类继承父类，可以得到父类的：</p><ul><li>成员变量</li><li>方法</li></ul><p>继承的好处：【代码复用】     </p><h2 id="方法重写（override）"><a href="#方法重写（override）" class="headerlink" title="方法重写（override）"></a>方法重写（override）</h2><p>当子类发现父类不适合自己时，就要重写父类的方法。</p><p>方法重写口诀</p><ol><li><p>方法名相同、形参列表相同。</p></li><li><p>返回值类型相同或更小， 声明跑出的异常相同或更小</p></li><li><p>访问权限相同或更大（如果父类访问权限是public的话，那么我们重写只能是public，因为public的权限是最大的了）</p><p>@Override：作用是报错。</p><pre><code>                    要求被修饰的方法必须重写父类方法，否则就报错。                比如说如果我们重写的类名写错了，用这个方法可以帮我们发现这个错误，比如我们                    需要重写的类名是fly()，而我们写成了f1y()。</code></pre></li></ol><p>Java找变量先就近，</p><h2 id="super限定"><a href="#super限定" class="headerlink" title="super限定"></a>super限定</h2><p>与前面this引用非常相似，super用于限定访问父类定义的实例变量或实例方法</p><p>super.父类定义的实例变量</p><p>super.父类定义的实例方法(参数)</p><h2 id="子类构造器调用父类的构造器"><a href="#子类构造器调用父类的构造器" class="headerlink" title="子类构造器调用父类的构造器"></a>子类构造器调用父类的构造器</h2><p><strong>子类构造器【一定调用】父类构造器【一次】——有且仅有一次。</strong></p><ol><li><p>如果子类构造器没有显式调用父类构造器，那么系统会自动在子类构造器的第一行先调用父类无参数的构造器</p></li><li><p>子类构造器的第一行显式使用super来调用父类构造器<br>super调用一定是调用的父类的构造器。只能出现在构造器的第一行。<br>this调用是调用当前类的构造器。只能出现在构造器的第一行<br>【很明显，super调用和this调用不可能同时出现。】</p><p>super限定：super紧跟一个   <strong>.</strong></p><pre><code>                  super.name;                  super.walk();</code></pre><p>super调用：super后边紧跟括号。</p><pre><code>                  super(参数);</code></pre></li></ol><p>【备注】：如果父类没有无参数的构造器，子类的构造器必须显式调用父类指定的构造器。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>我再回顾一下345</p><p>3种类型：类、接口、枚举。<br>4个修饰符：private|protected|public、final、static、abstract<br>5大成员：成员变量、方法、构造器、初始化块、内部类</p><p>多态的意义：<br>我们先吹一吹<strong>变态</strong>的概念：from 百度百科</p><ul><li>心理、行为上异于常人而且呈现病态。</li><li>经常做出正常人无法理解事情或违背常理行为的人。</li><li>能做出令人厌恶、反常的举动。</li><li>精神病或者神经不正常。</li></ul><p>很明显，这个的意思是，在寻常的正常的一群人或者正常的成长路线中，个别人（对象）呈现出变异的行为特征——这个就是变态的定义</p><p>再说一说<strong>拟态</strong>：动物为了生存下来，变成令人害怕的样子，吓唬别人</p><p><strong>多态</strong>：同一个类型的多个实例、在执行同一个方法，呈现出多种的行为特征——这就叫做“多态”</p><p>举个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 多态 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bird b1 = <span class="keyword">new</span> Sparrow();<span class="comment">// 这边需要注意的是，我的Sparrow类里边是没有fly方法的</span></span><br><span class="line"></span><br><span class="line">        Bird b2 = <span class="keyword">new</span> Ostrich();<span class="comment">// 这边需要注意的是，我的Ostrich类里边是有fly方法的</span></span><br><span class="line"></span><br><span class="line">        b1.fly();<span class="comment">// 当我的b1动态绑定类的fly方法的时候，发现我的Sparrow类里边没有fly方法，于是我的b1就开始寻找父类了，父类Bird里边果然有，所以我输出了“鸟在天上飞”</span></span><br><span class="line"></span><br><span class="line">        b2.fly();<span class="comment">// 当我的b2动态绑定类的fly方法的时候，发现我的Ostrich类里边是有fly方法的，于是我就输出了“鸵鸟当然只能跑啦！”这句话</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我相信上面的例子肯定能够助大家理解什么是多态</span></span><br><span class="line">        <span class="comment">// 相同类型的实例，在执行同一个方法的时候，呈现出多个行为特征。这就叫多态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bird类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name = <span class="string">"鸟"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鸟在天上飞"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sparrow类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ostrich类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ostrich</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鸵鸟当然只能跑啦！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向上转型：子类对象可以直接赋值给父类变量。"><a href="#向上转型：子类对象可以直接赋值给父类变量。" class="headerlink" title="向上转型：子类对象可以直接赋值给父类变量。"></a>向上转型：子类对象可以直接赋值给父类变量。</h3><h3 id="向下转型：父类变量赋值给子类变量。"><a href="#向下转型：父类变量赋值给子类变量。" class="headerlink" title="向下转型：父类变量赋值给子类变量。"></a>向下转型：父类变量赋值给子类变量。</h3><p>强制转换。<br>（类型）变量名。</p><h3 id="为什么会有多态呢？"><a href="#为什么会有多态呢？" class="headerlink" title="为什么会有多态呢？"></a>为什么会有多态呢？</h3><p>当我们的Java执行方法时，方法的执行是 动态绑定的。方法总是执行该变量实际所指向对象的方法。</p><h3 id="变量的类型（这边再讲一个概念）"><a href="#变量的类型（这边再讲一个概念）" class="headerlink" title="变量的类型（这边再讲一个概念）"></a>变量的类型（这边再讲一个概念）</h3><p>编译时的类型：声明该变量时指定的类型。<br>                           在Java程序的编译阶段，Java编译器只认编译时的类型。</p><p>运行时的类型（实际类型）：该变量实际所引用的对象的类型。</p><h3 id="强制转换运算符的注意点："><a href="#强制转换运算符的注意点：" class="headerlink" title="强制转换运算符的注意点："></a>强制转换运算符的注意点：</h3><ol><li><p>强制转换运算符只能在具有编译类型具有父子关系的变量之间进行转换。否则编译错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"在平面上绘制图形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> <span class="keyword">extends</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是一个矩形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">round</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"绕着圆形走一圈"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 多态2 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// s1编译类型是Shape，实际类型是Rect</span></span><br><span class="line">        Shape s1 = <span class="keyword">new</span> Rect();</span><br><span class="line">        s1.draw();</span><br><span class="line"><span class="comment">//        s1.info();// 无法调用，找不到info方法，因为，Java在编译的时候，只认编译类型。对于Java编译器来说，s1是Shape类型</span></span><br><span class="line">        <span class="comment">// 实际上是可以允许的，s1是有这个方法的，是可以运行的，只是编译不能通过</span></span><br><span class="line">        Shape s2 = <span class="keyword">new</span> Circle();</span><br><span class="line">        <span class="comment">// 对于编译器而言，s2是Shape类型，Shape没有round方法</span></span><br><span class="line"><span class="comment">//        s2.round();// 无法运行，同上理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// s2编译类型是Shape，c要求是Circle，Shape无法转换为Circle。，这个时候要用强制转换</span></span><br><span class="line"><span class="comment">//        Circle c = s2;</span></span><br><span class="line">        <span class="comment">// 解决上面的方法是强制转换。</span></span><br><span class="line">        Circle c = (Circle)s2;</span><br><span class="line">        c.round();</span><br><span class="line"></span><br><span class="line">        Circle c2 = (Circle)s1;<span class="comment">// 类型转换异常，s1指向的是Rect，强制转换只能是本来指向要转换的类才能进行转换</span></span><br><span class="line">        <span class="comment">// 比如这边的s2本来就是指向Circle的，于是可以转换</span></span><br><span class="line">        <span class="comment">// 这边的s1本来是指向Rect，所以不能转换</span></span><br><span class="line">        c2.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子加以说明</p></li><li><p>如果在编译类型具有继承关系的变量之间转换，如果被转变量的实际类型，不是要转的目标类型，那么程序就会引发ClassCastException（类型转换异常）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 强转2 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object str1 = <span class="string">"Mr8god"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 强转</span></span><br><span class="line"></span><br><span class="line">        String str = <span class="string">"Mr8god"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Integer it = (Integer) str;// 会报不兼容的错误，因为String跟Integer没有继承关系，所以编译就会报错，报不兼容的类型</span></span><br><span class="line">        Integer it = (Integer) str1;<span class="comment">// 这边Object与Integer之间有继承关系，所以编译能通过，但是运行会出现异常。</span></span><br><span class="line">        <span class="comment">// 编译器要求：必须在编译类型具有继承关系才能强转</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上头还是我写的一个小栗子；</p></li></ol><h3 id="instanceof运算符（为了避免ClassCastException异常）："><a href="#instanceof运算符（为了避免ClassCastException异常）：" class="headerlink" title="instanceof运算符（为了避免ClassCastException异常）："></a>instanceof运算符（为了避免ClassCastException异常）：</h3><p>为了避免ClassCastException异常，Java就增加了这个运算符。</p><p>变量名 instanceof 类型 —— 当前面的变量所引用对象是后面类或者子类的实例时，该运算符返回true。</p><p>instanceof 只能在编译类型具有继承关系之间进行判断，否则编译报错：不兼容的类型。</p><p>所以我们以后在强制转换之前，都要做到先判断再转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 强转2 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object str1 = <span class="string">"Mr8god"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 强转</span></span><br><span class="line"></span><br><span class="line">        String str = <span class="string">"Mr8god"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Integer it = (Integer) str;// 会报不兼容的错误，因为String跟Integer没有继承关系，所以编译就会报错，报不兼容的类型</span></span><br><span class="line"><span class="comment">//        Integer it = (Integer) str1;// 这边Object与Integer之间有继承关系，所以编译能通过，但是运行会出现异常。</span></span><br><span class="line">        <span class="comment">// 编译器要求：必须在编译类型具有继承关系才能强转</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (str1 <span class="keyword">instanceof</span> Integer)</span><br><span class="line">        &#123;</span><br><span class="line">            Integer it = (Integer)str1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有在编译类型具有继承关系才能进行判断，否则编译报错，下面的例子又是一个不兼容的问题，String无法转换为Integer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 强转2 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String s = <span class="string">"Mr8god"</span>;</span><br><span class="line"><span class="comment">//        System.out.println(s instanceof Integer);//是不能运行的，因为String无法转换为Integer。。。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h2><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[修饰符]&#123;</span><br><span class="line"></span><br><span class="line">​各种语句</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化块是没有名字的，<br>修饰符只能出现一个：static。</p><ul><li>有static的叫做类初始化块（静态初始化块）；</li><li>无static的叫做实例初始化块（非静态初始化块）；</li></ul><p>初始化块代码小栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">happy1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">2</span>;<span class="comment">// 成员变量-&gt; 实例变量</span></span><br><span class="line"><span class="comment">//    String name;</span></span><br><span class="line"><span class="comment">//    name = "Mr8god";</span></span><br><span class="line">    <span class="comment">//赋值语句不能放在类里边，赋值语句放在方法中</span></span><br><span class="line">    </span><br><span class="line">    String name ;</span><br><span class="line">    &#123;name = <span class="string">"Mr8god"</span>;&#125;<span class="comment">// 这样就变成初始化块了，就可以写了。这个东西叫做代码块中的初始化块（一种特例）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化块分成两种："><a href="#初始化块分成两种：" class="headerlink" title="初始化块分成两种："></a>初始化块分成两种：</h3><h4 id="实例初始化块（无static）"><a href="#实例初始化块（无static）" class="headerlink" title="实例初始化块（无static）"></a>实例初始化块（无static）</h4><p>实例初始化块其实是一种“假象”，一个类在编译之后，实例初始化块就会消失。</p><p>实力初始化块的所有代码会被还原到每个构造器的开始部分。<br>举个代码小栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitTest</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Mr8god"</span>);<span class="comment">// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面有两个构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InitTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一个无参构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InitTest</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"带String参数的构造器， 参数为："</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译之后，上面所以代码会变成下面的样子，下面的代码就是上面的本质。</span></span><br><span class="line"><span class="comment">//    public InitTest()</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("Mr8god");// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println("这是一个无参构造器");</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    public InitTest(String name)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("Mr8god");// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println("带String参数的构造器， 参数为：" + name);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边介绍一个命令javap -c 用于分析Java 的class文件<br><img src="https://i.loli.net/2020/04/07/mH9yhbtZ7dSeiwJ.jpg" alt="javap之后的真相.jpg"></p><p>经过反编译，得到具体代码运行过程后，我们发现事实确实是这样的哈。</p><p>这边再附上一个代码调用上面的类，以方便以后复现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Init in = <span class="keyword">new</span> Init();</span><br><span class="line"></span><br><span class="line">        Init in2 = <span class="keyword">new</span> Init(<span class="string">"江某人来了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实例初始化块的作用："><a href="#实例初始化块的作用：" class="headerlink" title="实例初始化块的作用："></a>实例初始化块的作用：</h5><ol><li>类似于C++中的全局变量，只需要维护一个地方就够了，不需要到每个构造器里操作。</li><li>将多个构造器前面部分相同的代码可以提取到实例初始化块中！</li></ol><h5 id="实例初始化块何时执行呢？"><a href="#实例初始化块何时执行呢？" class="headerlink" title="实例初始化块何时执行呢？"></a>实例初始化块何时执行呢？</h5><p>只要程序调用构造器创建对象，程序总会先执行实例初始化块——因为实例初始化块被还原到每个构造器的所有代码之前。</p><h5 id="定义实例变量"><a href="#定义实例变量" class="headerlink" title="定义实例变量"></a>定义实例变量</h5><p>当我的init类是这个时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Init</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Mr8god"</span>);<span class="comment">// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 下面有两个构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一个无参构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Init</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"带String参数的构造器， 参数为："</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initTest是这个时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Init in = <span class="keyword">new</span> Init();</span><br><span class="line"></span><br><span class="line">        Init in2 = <span class="keyword">new</span> Init(<span class="string">"江某人来了"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(in2.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果并不是如我刚开始想象的那样是20，因为我以为初始化的20 ，是分散到两个方法里去了，那么引用的话，应该是20呀。结果却是2。</p><p><strong>定义实例变量时指定的初始值，也是“假象” 。</strong></p><p><strong>——指定初始值，编译之后就变成构造器所有代码之前一条赋值语句！</strong></p><p>这里边的int age = 2，本质上是int age ;我们可以通过反编译工具看到</p><p><img src="https://i.loli.net/2020/04/07/5jsBlRHOqDAVC2Z.jpg" alt="age没有赋值.jpg"></p><p>所以我上面的Init类现在实际上已经变成了这个样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Init</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 下面有两个构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mr8god"</span>);<span class="comment">// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">        age = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">"这是一个无参构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Init</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mr8god"</span>);<span class="comment">// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">        age = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">"带String参数的构造器， 参数为："</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么很明显，最近一次的赋值age是2。所以会出现问题，不是我想象中的20，也是理所应当了</p><p>这里边大费周章又是比较代码又是反编译的，其实主要是为了说明一点</p><p>即使我们的赋值语句不在代码块中，编译之后，也是会一起到构造语句中的。over</p><p>也就是说，如果我把int age = 2;放在类中的首行，也就是public Init()的上一行，我们得出的结果就会是20了，只是一个age赋值先后顺序的关系。</p><h5 id="总结总结总结"><a href="#总结总结总结" class="headerlink" title="总结总结总结"></a>总结总结总结</h5><p>实例初始化块的语句要还原到构造器的所有代码之前；定义变量指定的初始值，也要还原到构造器的所有代码之前；那么这两者的先后顺序呢？按照它们在源代码中的顺序。</p><h4 id="类初始化块（有static）"><a href="#类初始化块（有static）" class="headerlink" title="类初始化块（有static）"></a>类初始化块（有static）</h4><p>类初始化块——负责对类执行初始化。<br>                            当程序<strong>第一次主动</strong>使用该类时，系统会为该类分配内存空间、并执行初始化（调用类初始化块）</p><h5 id="对-第一次主动-概念做解释："><a href="#对-第一次主动-概念做解释：" class="headerlink" title="对 第一次主动 概念做解释："></a>对 <strong>第一次主动</strong> 概念做解释：</h5><p>除了用类去声明变量，其他只要你使用该类，都算是第一次主动使用该类。可以从Java编译器的角度去理解</p><h5 id="类初始化块何时执行"><a href="#类初始化块何时执行" class="headerlink" title="类初始化块何时执行"></a>类初始化块何时执行</h5><p>程序第一次【主动】使用该类时，会执行该类的类初始化块。<br>程序运行时，该类初始化块只会执行一次！</p><div class="table-container"><table><thead><tr><th></th><th>执行次数</th><th>执行先后</th><th>何时执行</th></tr></thead><tbody><tr><td>类初始化块</td><td>1次·</td><td>先</td><td>第一次主动用该类</td></tr><tr><td>实例初始化块</td><td>N次</td><td>后</td><td>每次调用构造器</td></tr></tbody></table></div><p><strong>定义实例变量时指定的初始值，也是“假象” 。</strong></p><p><strong>——指定初始值，编译之后就变成类初始化中的一条赋值语句！但到底是在类初始化块的代码之前，还是代码之后呢，取决于它在源代码中的顺序。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInit</span> </span>&#123;</span><br><span class="line"><span class="comment">//    static int age = 30;</span></span><br><span class="line"><span class="comment">//    // 类初始化块</span></span><br><span class="line"><span class="comment">//    static &#123;</span></span><br><span class="line"><span class="comment">//        age = 300;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上面代码的本质，如下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 类初始化块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        age = <span class="number">30</span>;</span><br><span class="line">        age = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="大一统"><a href="#大一统" class="headerlink" title="大一统"></a>大一统</h4><p>先上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base11</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Base11 的类初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Base11 的实例始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base11</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Base11 无参数构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base11</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Base11 的（String）参数构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mid</span> <span class="keyword">extends</span> <span class="title">Base11</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Mid 的类初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Mid 的实例初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">(<span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        System.out.println(<span class="string">"Mid 的(int)构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"Mr8god"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Mid 的无参数构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub1</span> <span class="keyword">extends</span> <span class="title">Mid</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Sub 的类初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Sub 的实例初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sub1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sub 的无参数构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sub1</span><span class="params">(<span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        System.out.println(<span class="string">"Sub 的（double）构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Sub1(<span class="number">3.4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【结论】：初始化任何类之前，一定先从Object开始初始化，依次初始化它所有祖先类，最后才到它自己；创建任何对象的时候，一定是从Object构造器开始执行，执行它所有祖先类的构造器，最后才执行它自己的构造器！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java面向对象基础回顾&quot;&gt;&lt;a href=&quot;#Java面向对象基础回顾&quot; class=&quot;headerlink&quot; title=&quot;Java面向对象基础回顾&quot;&gt;&lt;/a&gt;Java面向对象基础回顾&lt;/h1&gt;&lt;p&gt;定义类、创建对象、调用方法&lt;/p&gt;
&lt;h2 id=&quot;定义类&quot;
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java内存</title>
    <link href="https://mr8god.cn/2020/04/04/Java/%E6%B5%85%E8%B0%88Java%E5%86%85%E5%AD%98/"/>
    <id>https://mr8god.cn/2020/04/04/Java/%E6%B5%85%E8%B0%88Java%E5%86%85%E5%AD%98/</id>
    <published>2020-04-04T15:31:53.815Z</published>
    <updated>2020-04-04T15:39:20.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅谈Java内存"><a href="#浅谈Java内存" class="headerlink" title="浅谈Java内存"></a>浅谈Java内存</h1><h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><p><img src="https://i.loli.net/2020/04/04/RMaGdC8hxOqc9SY.jpg" alt="Java虚拟机运行时数据区.jpg"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a><strong>程序计数器</strong></h3><ol><li>作用：当前线程所执行的字节码的行号指示器。</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li>存在的意义：Java虚拟机的多线程是通过线程轮流切换实现的，类似于操作系统的时间片算法来分配核心（处理器）的执行时间。所以，为了线程每一次切换后能够恢复到之前正确的执行位置，每个线程就需要各自独立的程序计数器。</li><li>如果线程此时正在执行的是一个Java方法，计数器记录的即是正在执行的虚拟机字节码指令的地址；如果正在执行的是Nativie方法，这个计数器即是空（Undefined）。</li></ol><h3 id="Java虚拟机栈（就是大家常说的栈内存）"><a href="#Java虚拟机栈（就是大家常说的栈内存）" class="headerlink" title="Java虚拟机栈（就是大家常说的栈内存）"></a><strong>Java虚拟机栈</strong>（就是大家常说的栈内存）</h3><p>虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个<strong>栈帧</strong>，用于存储局部变量表、操作栈、动态链接、方法出口等信息。</p><p>每一个方法被调用直至执行完成的过程，就对应着一个<strong>栈帧</strong>在虚拟机栈中从入栈到出栈的过程。</p><p>大部分程序员把Java的内存区域划分为堆内存（Heap）和栈内存（Stack），事实上Java内存区域的划分远比这复杂。其中所指的“堆”在后边会聊到，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变量表部分。</p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>局部变量表存放了编译期可知的8种基本数据类型（int、char、byte、short、long、double、boolean、float）、对象引用和returnAddress类型</p><p>这边插一句关于对象引用类型的分析解释：字如其意，是一种引用，就是C中的指针嘛，我们来看一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>=左边的arr是变量部分，=右边的是一个对象。</p><p>右边只是一个指向对象起始地址的引用指针。</p><p>左边的arr是变量，所以被存放在栈内存中。右边的是对象， 所以被存放在堆内存中，两者靠指针来维系关系。上面这句话应该这么来理解。</p><p>continue！继续聊局部变量表，8种基本数据类型里64位长度的long和double类型的数据会占用2个局部变量空间，其余的数据类型只占用1个。</p><p>局部变量表所需的内存空间在编译期间就完成了分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是早就确定好的，而且我们在方法运行期间不会改变 局部变量表的大小。</p><p>continue！继续聊虚拟机栈，我们聊报错</p><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p>有两种：</p><ol><li>StackOverflowError异常：如果线程请求的栈深度大于虚拟机所允许的深度</li><li>OutOfMemoryError异常：当我们使用的虚拟机栈的内存不够时就会出现这个报错</li></ol><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>与虚拟机栈作用相似 ，区别在于虚拟机栈是为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用的Native方法服务。</p><p>甚至于有的虚拟机（比如Sun HotSpot虚拟机）直接将本地方法栈和虚拟机栈合二为一。</p><p>与虚拟机栈一样，本地方法栈区域也会抛出两种报错StackOverflowError和OutOfMemoryError。</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>是Java虚拟机所管理的内存中最大的一块。在虚拟机启动时就被创建了。</p><p>唯一目的就是存放对象实例，只要我们new的对象实例都在这边分配了内存。</p><p>Java对可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。</p><p>当前主流的虚拟机都是按照可扩展来实现的（通过 -Xmx：最大多少内存空间，-Xms：最小多少内存空间   来控制）</p><p>如果堆中内存不够的话，将会抛出OutOfMemoryError异常，我称之为爆内存，并且在下面给出爆内存的具体例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 爆内存 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> it = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">long</span>[] arr = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">100</span>];</span><br><span class="line">        arr[<span class="number">99</span>] = <span class="number">33</span>;</span><br><span class="line">        System.out.println(arr[<span class="number">99</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//教你如何爆内存哈，在终端输入Java -Xmx256 爆内存</span></span><br></pre></td></tr></table></figure><p>当然爆内存知识OutOfMemoryError异常三种情况中的一种，之后我也会仔细围绕这个好好讲讲，<a href="https://blog.csdn.net/z453588/article/details/83743837，可以先看看这个博客解解馋" target="_blank" rel="noopener">https://blog.csdn.net/z453588/article/details/83743837，可以先看看这个博客解解馋</a></p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>与Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>可以和Java堆一样不需要连续的内存 和可以选择固定大小或者可扩展外</p><p>还可以选择不识闲垃圾回收。相对而言，垃圾收集行为在这个区域很少见。但是并非是说数据进入方法区就永久存在了。</p><p>这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>是方法区的一部分。</p><p>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池相对于Class文件常量池的另外一个重要特征就是<strong>具备动态性</strong>。</p><p>动态性：Java语言并不要求常量一定只能在编译期产生，运行期间也可能将新的常量放入池中。这种特性被开发人员用的较多的就是String类的intern()方法。</p><p>既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当无法再申请到内存时会抛出OutOfMemoryError异常。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</p><p>JDK1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用来进行操作。这样在一些场景中能显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><p>既然是直接内存，那么这一部分内存是不会受到Java堆大小的限制的咯，</p><p>但是既然是内存，则肯定还是会受到本机总共内存的大小和处理器寻址空间的限制。</p><p>服务器管理员配置虚拟机参数时，一般会根据实际内存设置 -Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制（包括物理上的限制和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。</p><h3 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h3><p>上面都是从Java虚拟机的运行时数据区来讨论的，这边在讨论一个话题：对象访问是如何进行的呢？</p><p>对象访问是Java中的常客，即使是最简答的访问，也会涉及到Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系。举个例子说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>等号左边的一部分会被保存在Java栈的本地变量表里，我之前也有所涉及，作为一个reference类型数据出现，一个引用类型嘛。</p><p>而右边的部分会被存储到Java堆中去。形成一块连在一起的结构化内存（类似于数组一样的结构）</p><p>另外在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。</p><h4 id="对象访问的两种方法：使用句柄和直接指针"><a href="#对象访问的两种方法：使用句柄和直接指针" class="headerlink" title="对象访问的两种方法：使用句柄和直接指针"></a>对象访问的两种方法：使用句柄和直接指针</h4><p>如果<strong>使用句柄访问方式</strong>，Java堆中将会划分出一块内存来作为句柄池，栈内存中存储的就是<strong>对象的句柄地址</strong>，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。</p><p><img src="https://i.loli.net/2020/04/04/a8p6zHbD1cl9NEF.jpg" alt="通过句柄访问对象.jpg"></p><p>如果使用<strong>直接指针访问方式</strong>，Java堆对象的布局就必须要考虑如何放置访问类型数据的相关信息，栈内存中直接存储的就是<strong>对象地址</strong></p><p><img src="https://i.loli.net/2020/04/04/9FjKNb6Xy3zU2tx.jpg" alt="通过直接指针访问对象.jpg"></p><p>各有优势：</p><p>使用句柄访问方式的最大好处就是堆内存中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针就行了。</p><p>使用直接指针访问方式的最大好处是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此此类开销积少成多后会非常可观。</p><h2 id="各种异常实战"><a href="#各种异常实战" class="headerlink" title="各种异常实战"></a>各种异常实战</h2><p>明儿个再补充</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浅谈Java内存&quot;&gt;&lt;a href=&quot;#浅谈Java内存&quot; class=&quot;headerlink&quot; title=&quot;浅谈Java内存&quot;&gt;&lt;/a&gt;浅谈Java内存&lt;/h1&gt;&lt;h2 id=&quot;Java内存区域&quot;&gt;&lt;a href=&quot;#Java内存区域&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>你所不知道的函数小知识——结构体与函数</title>
    <link href="https://mr8god.cn/2020/04/03/C++/%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%87%BD%E6%95%B0%E5%B0%8F%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E5%87%BD%E6%95%B0/"/>
    <id>https://mr8god.cn/2020/04/03/C++/%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%87%BD%E6%95%B0%E5%B0%8F%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E5%87%BD%E6%95%B0/</id>
    <published>2020-04-03T15:33:37.914Z</published>
    <updated>2020-04-03T15:32:58.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构体与函数之间的那点儿事"><a href="#结构体与函数之间的那点儿事" class="headerlink" title="结构体与函数之间的那点儿事"></a>结构体与函数之间的那点儿事</h1><p>正如标题哈，本篇博文讲的就是结构体和函数。不是新手向的教程哈，更多的这是一篇记录经验的文章。话不多说，开始咯！</p><p>我们将注意力从之前的数组转到结构上面。为结构写函数可比为数组写函数要简单得多了。虽然结构变量和数组一样，都可以存储多个数据项。但是在涉及到函数的时候，结构变量的行为更接近与基本的单值变量。这个名词可能太专业了哈。我做一下解释，还是拿数组来做比较，数组中都是一个元素为单位存储的，在结构中，相应的便是将数据组合成一个实体，实体就是数据，数据就是实体。<strong>实体（结构）==元素（数组）</strong>。</p><p>这边实现传值的思想主要是利用了<strong>一个结构可以赋给另外一个结构</strong>这样子的常识知识。就像普通变量一样。我需要额外补充的是，函数将使用原始结构的副本。</p><p>函数也可以返回结构 。这边与<strong>使用数组名就是代表了数组第一个元素的地址</strong>这样的观点不同的是，结构名只是结构的名称，<strong>要获得结构的地址，必须使用地址运算符&amp;</strong>。</p><p>咱们传递结构体的基本方法就是<strong>按值传递</strong>（圈起来，要考！）但是C++作为一门精细的语言，细节到每一个内存都要深挖，不能忍受这种方法的一个缺点：<strong>如果结构非常大的话，复制结构将增加内存要求，降低系统运行的速度。</strong>出于这种原因，我们更愿意的是采取<strong>按地址传递</strong>（没错，又是“该死”的指针，所以说C++指针一定要学好！）。然后使用指针来访问结构的内容。</p><h2 id="首先介绍“按值传递”"><a href="#首先介绍“按值传递”" class="headerlink" title="首先介绍“按值传递”"></a>首先介绍“按值传递”</h2><p>当结构比较小时，按值传递最舒服了用起来。接下来举的例子来源于《C++ Primer Plus（第六版）》</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从a到b城需要3小时50分钟，而从b到g城需要1小时25分钟，对于这种时间，可以使用结构来表示——一个成员表示小时值，另一个成员表示分钟值，将两个时间加起来需要一些技巧，因为可能需要将分钟值转换为小时。例如前面列出的两个时间的总和为4小时75分钟，应将它转化为5小时15分钟，下面开发用于表示时间值的结构，然后再开发一个函数，它接受两个这样的结构为参数并返回表示参数的和的结构。</span><br></pre></td></tr></table></figure><p>突出介绍一下结构函数的写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">travel_time</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> hours;</span><br><span class="line">    <span class="keyword">int</span> mins;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在已经定义好时间的结构的前提下，开始声明结构函数</span></span><br><span class="line"></span><br><span class="line"><span class="function">travel_time <span class="title">sum</span><span class="params">(travel_time t1, travel_time t2)</span></span>;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">travel_time</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> hours;</span><br><span class="line">    <span class="keyword">int</span> mins;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mins_per_hr = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">travel_time <span class="title">sum</span><span class="params">(travel_time t1, travel_time t2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_time</span><span class="params">(travel_time t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    travel_time day1 = &#123;<span class="number">5</span>, <span class="number">45</span>&#125;;</span><br><span class="line">    travel_time day2 = &#123;<span class="number">4</span>, <span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line">    travel_time trip = sum(day1, day2);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Two-day total: "</span>;</span><br><span class="line">    show_time(trip);</span><br><span class="line"></span><br><span class="line">    travel_time day3 = &#123;<span class="number">4</span>, <span class="number">32</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Three-day total: "</span>;</span><br><span class="line">    show_time(sum(trip, day3));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">travel_time <span class="title">sum</span><span class="params">(travel_time t1, travel_time t2)</span></span>&#123;</span><br><span class="line">    travel_time total;</span><br><span class="line"></span><br><span class="line">    total.mins = (t1.mins + t2.mins) % Mins_per_hr;</span><br><span class="line">    total.hours = t1.hours + t2.hours + (t1.mins + t2.mins) / Mins_per_hr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_time</span><span class="params">(travel_time t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t.hours &lt;&lt; <span class="string">" hours, "</span> &lt;&lt; t.mins &lt;&lt; <span class="string">" minutes\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><p>travel_time 就像是一个标准的类型名，可以用来声明变量、函数的返回类型和函数的参数类型。</p><p>然后试travel_time结构的变量total 和t1，使用成员运算符进行数据的操作。代码很简单，可以看得懂。</p><h2 id="然后介绍“按地址传递”"><a href="#然后介绍“按地址传递”" class="headerlink" title="然后介绍“按地址传递”"></a>然后介绍“按地址传递”</h2><p>这一次我换了个题目，题目的内容我简要地说一下哈：通常我们表示一件物品的位置的时候，都是采取选择参照系利用直角坐标系或者极坐标系进行精确表示的，这边写了一个程序用于两种坐标系之间的转换。就是这样。</p><p>由于和上面的代码极其类似，所以我认为看看例子就能理解欧，就不做解析了。over</p><p>这个代码有一个小东西讲讲熬，就是while里边的cin&gt;&gt; 的用法，cin的特性是可以输入int整型数，但是一旦发现你输入的不是数字的时候，他就会不满足条件，变为0，然后while就会跳出循环，蛮好用的小技巧，推荐学习！</p><p>代码奉上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">polar</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> distance;</span><br><span class="line">    <span class="keyword">double</span> angle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rect</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rect_to_polar</span><span class="params">(<span class="keyword">const</span> <span class="built_in">rect</span> * pxy, polar * pda)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_polar</span><span class="params">(<span class="keyword">const</span> polar * pda)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">rect</span> rplace;</span><br><span class="line">    polar pplace;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter the x and y values: "</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; rplace.x &gt;&gt; rplace.y)&#123;</span><br><span class="line">        rect_to_polar(&amp;rplace, &amp;pplace);</span><br><span class="line">        show_polar(&amp;pplace);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Next two numbers (q to quit): "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Done.\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rect_to_polar</span><span class="params">(<span class="keyword">const</span> <span class="built_in">rect</span> * pxy, polar * pda)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    pda-&gt;distance = <span class="built_in">sqrt</span>(pxy-&gt;x * pxy-&gt;x + pxy-&gt;y * pxy-&gt;y);</span><br><span class="line">    pda-&gt;angle = <span class="built_in">atan2</span>(pxy-&gt;y, pxy-&gt;x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_polar</span><span class="params">(<span class="keyword">const</span> polar * pda)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> Rad_to_deg = <span class="number">57.29577951</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"distance = "</span> &lt;&lt; pda-&gt;distance;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">", angle = "</span> &lt;&lt; pda-&gt;angle * Rad_to_deg;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" degrees\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;结构体与函数之间的那点儿事&quot;&gt;&lt;a href=&quot;#结构体与函数之间的那点儿事&quot; class=&quot;headerlink&quot; title=&quot;结构体与函数之间的那点儿事&quot;&gt;&lt;/a&gt;结构体与函数之间的那点儿事&lt;/h1&gt;&lt;p&gt;正如标题哈，本篇博文讲的就是结构体和函数。不是新手向
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="C++" scheme="https://mr8god.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++函数中的指针应用</title>
    <link href="https://mr8god.cn/2020/04/02/C++/C++%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E5%BA%94%E7%94%A8/"/>
    <id>https://mr8god.cn/2020/04/02/C++/C++%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E5%BA%94%E7%94%A8/</id>
    <published>2020-04-02T08:00:25.063Z</published>
    <updated>2020-04-02T07:59:50.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数与数组"><a href="#函数与数组" class="headerlink" title="函数与数组"></a>函数与数组</h1><p>虽然我上面开了两篇博客准备一锅把函数端掉，但是当我想到数组哈，我觉得还是有必要对它好好搞一番。为什么呢？因为当我们在形参中放一个数组时，要开始注意了昂，这个数组是按照数组基本的操作传递值的，它是以指针的方式运转的！！！一提到指针哈，就得好好琢磨琢磨了，毕竟我江某人如今的观点是C++最重要的有两个：指针和STL库。</p><p>要我说，之前讲的两章，着实是对函数基础知识的总结。而我们日常使用中，是不会这么简单的。比如说我们企业中要计算某个项目中每个用户所购买的东西之和。我们很容易想到每个数组可以索引指向一个顾客，要计算总共有多少个东西被买掉了，我们可以使用循环来计算出总和。这不是不可以哈。但是呢，我们其实可以用一个函数来实现它。我们可以在声明函数时，放入一个数组形状的形参，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">( <span class="keyword">int</span> arr[], <span class="keyword">int</span> a)</span></span></span><br></pre></td></tr></table></figure><p>很明显，这里边arr就是咱们即将要传递的数组，[]里边是空的，说明我们待会要传递的数组的长度是需要额外设置的。但是我再强调一点哈，这个arr实际上并不是数组，而是一个指针！但是呢，我们在编写函数的时候，是可以将arr看做是数组的。</p><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p>下面是我写的一个小example</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ArSize = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">int</span> counts[ArSize] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>,<span class="number">128</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = sums(counts, ArSize);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Total counts: "</span> &lt;&lt; sum &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        total = total + arr[i];</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我来详细讲一讲哈，其实我们当初在学习数组的时候就知道，数组名是可以当做指针来用的，数组名指向该数组的第一个元素的地址。但是呢，这边在函数中讨论数组和指针的话。我得把需要注意的几个点额外说一哈</p><ol><li>数组声明使用数组名来表示存储位置</li><li>对数组使用sizeof得到的是整个数组的长度，举个例子哈，int aaa[8]，int是4个字节，对这个数组使用sizeof的话，我们得到的长度为32位字节</li><li>如果我们使用取地址符&amp;的话，我们得到的也会是一个长度为32字节的内存块的地址。</li></ol><p>arr是咱们的数组名，根据C++规则，arr指代的是第一个元素的地址。 所以咱们的函数传递的也是地址哈。元素的类型是int，那么咱们的指针也应该是int类型的。因此，我们可以使用int *来表示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = sums(<span class="keyword">int</span> * arr, <span class="keyword">int</span> n)</span><br></pre></td></tr></table></figure><p>易知，int * arr 替换了int arr[]，这两个的含义是相同的。</p><p>但是呢，其实这两种表达方法也是有区别的，</p><p>数组表达式（int arr[])提醒咱们的程序员，arr不仅指向int，还指向了int数组的第一个int。当指针指向数组的第一个元素时，本书使用了数组表达法；</p><p>指针表达式可以用在当我们指针指向一个独立的值，而不是第一个值的时候。</p><p>！！！要记住只有在这边是可以的等价的，在其他地方都是不等价的哦。例如我们不能再函数体中将两者相替换。</p><p>经过我们的挖掘后，知道了arr数组名实际上是一个指针的事实后，我们也可以 用方括号数组表示法来访问数组元素。无论arr是指针还是数组名，表达式arr[3]都指的是数组的第4 个元素。</p><p>这边总结出两个式子，希望能记住：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr[i] == *(ar + i)</span><br><span class="line">&amp;arr[i] == ar + i</span><br></pre></td></tr></table></figure><p>在强调一点，指针加一的意义，指的是加上一个与指针指向的类型的长度。例如上文中的32字节内存块。对于遍历数组而言，使用指针加法和数组下标是等效的。</p><h2 id="数组作为参数有啥意义呢？"><a href="#数组作为参数有啥意义呢？" class="headerlink" title="数组作为参数有啥意义呢？"></a>数组作为参数有啥意义呢？</h2><p>讲得更加清楚一点，实际上数组内容并没有传递给函数，而是将数组的地址、包含的元素类型以及元素数目提交给了函数。有了这些信息后，函数便可以使用原来的数组。传递<strong>常规变量时</strong>，函数将<strong>使用该变量的拷贝</strong>；但传递<strong>数组</strong>时，函数将<strong>使用原来的数组</strong>。</p><p>一种是拷贝了原始数据，并进行操作，一种是使用指针，直接操作原始数据。都实现了函数的值传递。但是我想两种方法肯定是有利有弊的呀。继续往下分析。</p><h3 id="数组名与指针对应是否是好事呢？"><a href="#数组名与指针对应是否是好事呢？" class="headerlink" title="数组名与指针对应是否是好事呢？"></a>数组名与指针对应是否是好事呢？</h3><p>先说回答哈，确实是一件好事。将数组地址作为参数可以节省复制整个数组所需要的时间和内存。如果数组很大的话。则使用拷贝的系统开销将非常大；程序不仅需要更多的计算机内存，还需要花费时间来复制大块的数据。</p><p>但是呢，有利有弊哈，我们使用指针其本质上时使用了原始数据，增加了破坏数据的风险。不过不怕，C++可以解决它，ANSI C也可以解决它，那就是const限定符了。稍后我在写例子哈。</p><p>这边再写一个例子，用于演示咱们的指针是如何运转的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ArSize = <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> things[ArSize] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>,<span class="number">64</span>,<span class="number">128</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; things &lt;&lt; <span class="string">" = arr address, "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(things) &lt;&lt; <span class="string">" = sizeof things\n"</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = sums(things, ArSize);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Total things: "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    sum = sums(things, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"First tree people buy "</span> &lt;&lt; sum &lt;&lt; <span class="string">" things.\n"</span>;</span><br><span class="line">    sum = sums(things + <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Last four people buy "</span> &lt;&lt; sum &lt;&lt; <span class="string">" things.\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; arr &lt;&lt; <span class="string">" = arr, "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(* arr) &lt;&lt; <span class="string">" = sizeof  arr\n "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        total += arr[i];</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边的地址值和数组的长度会随着系统的变化而变化哈，如果你和你的小伙伴们运行出不一样的结果，不要诧异哦！此外，有些C++实现 的是以十进制而不是十六进制格式显示地址哈，所以不要太大惊小怪，显得见识浅薄了些。还有一些编译器以十六进制显示地址时，会加上前缀0x呢。</p><p><strong>代码说明：</strong></p><p>首先我这边things和arr指向了同一个地址。但是sizeof(things)的值为32，而sizeof(arr)为4（是我电脑上运行的结果哈）。这是由于sizeof(things)是整个数组的长度，而sizeof(arr)只是指针变量的长度。顺道加一个知识点，这也是必须显式传递数组长度，而不能在sums()中使用sizeof(arr)的原因；指针本身并没有之处数组的长度。</p><p>因为咱们的sums()只能通过第二个参数获知数组中的元素数量，我们可以对函数做修改。例如，程序第二次使用该函数时，这样调用它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = sums(things， <span class="number">3</span>)；</span><br></pre></td></tr></table></figure><p>通过告诉函数things有3个元素，可以让它计算前3个元素的总和。</p><p>也可以提供假的数组起始位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = sums(things + <span class="number">4</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>由于things是第一个元素的地址，因此things+4是第五个元素的地址。这条语句将计算数组第5、6、7、8个元素的总和。请注意输出中第三次函数调用选择将不同于前两个调用的地址赋给arr的。</p><p><strong>Attention！</strong></p><p>我们可以数组类型和元素数量告诉数组处理函数，通过两个不同的参数来传递他们：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> n)</span></span></span><br></pre></td></tr></table></figure><p>而不要试图使用方括号表示法来传递数组长度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">int</span> arr[<span class="built_in">size</span>])</span></span></span><br></pre></td></tr></table></figure><h2 id="各种例子，来更深入了解数组函数"><a href="#各种例子，来更深入了解数组函数" class="headerlink" title="各种例子，来更深入了解数组函数"></a>各种例子，来更深入了解数组函数</h2><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>假设要使用一个数组来记录房地产的价值。</p><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>首先要明确使用哪种类型。当然double的取值范围比int和long大，并且提供了足够多的有效位数来精确地表示这些值。</p><p>接下来必须决定数组元素的数目。（这边不考虑动态数组）如果房地产数目不超过5个，则可以使用一个包含5个元素的double数组。</p><p>考虑操作：两个基本的操作，一、将值读入到数组中和显示数组内容。二、重新评估每种房地产的值。</p><p>简单起见，我们规定房地产以相同比率增加或者减少。</p><h3 id="1-填充数组"><a href="#1-填充数组" class="headerlink" title="1.填充数组"></a>1.填充数组</h3><p>顾客不止一个，所以我们可以做多个数组，房产得有上限，毕竟我这边不搞花里胡哨的动态数组。所以函数定义为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill_array</span><span class="params">(<span class="keyword">double</span> arr[], <span class="keyword">int</span> limit)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数接受两个参数，一个是数组名，另一个指定了要读取的最大元素数；该函数返回实际读取的元素数。例如，如果使用该函数处理一个包含了5个元素的数组，则将5作为第二个参数。如果只输入3个值，则该函数将返回3.</p><p>可有循环连续地将值读入到数组中，但是我们该如何提早结束循环呢？有两种思路，一、使用一个特殊值来指定输出结束。由于所有的属性不为负，我们可以使用负值来指出输入结束。二、该函数应对错误输入做出反应，如停止输入等。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill_array</span><span class="params">(<span class="keyword">double</span> arr[], <span class="keyword">int</span> limit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">double</span> temp;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter value # "</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">cin</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">cin</span>.<span class="built_in">get</span>() != <span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Bad input; input process terminated.\n"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        arr[i] = temp;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数可以判断输入是否出错，比如说负值啦等等。如果输入正确的话，则循环将会在读取最大数目的值后结束。循环完成的最后一项工作后，将i加1，因此循环结束后，i将比最后一个数组索引大1，即等于填充的元素数目。然后，函数返回这个值。</p><h3 id="2-显示数组及用const保护数组"><a href="#2-显示数组及用const保护数组" class="headerlink" title="2.显示数组及用const保护数组"></a>2.显示数组及用const保护数组</h3><p>不是啥高大的东西，就是显示元素的数组，但是最重要的东西应该是const保护数组。</p><p>当我们用数组名表示指针传递值时，会导致原始数据受到威胁。这个时候我呼应了上文中所要讲的方法const保护数组不被修改。</p><p>为了防止函数无意中修改数组的内容，我们可以在声明形参时使用关键字const：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> arr[], <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>该声明表明，指针arr指向的是常量数据。这意味着不能使用arr修改该数据，也就是说，可以使用值，但是不会修改。咳咳，这并不是意味着原始数组必须是常量，而只是意味着不能在show_array()函数中使用arr来修改数据。因此该函数将数组视为只读数据。 如果你要在函数中给原数组赋值的话，是会报错的。</p><p>show_array函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Property #"</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">": $"</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-修改数组"><a href="#3-修改数组" class="headerlink" title="3.修改数组"></a>3.修改数组</h3><p>实现的功能是对数组中每个元素与同一个重新评估因子相乘。需要给函数传递3个参数：因子、数组和元素数目。该函数不需要返回值，因此代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Property #"</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">": $"</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就和上一个函数不一样了，这边是必须要修改值的，所以不能加const</p><h2 id="4-组合代码解出题目"><a href="#4-组合代码解出题目" class="headerlink" title="4.组合代码解出题目"></a>4.组合代码解出题目</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill_array</span><span class="params">(<span class="keyword">double</span> arr[], <span class="keyword">int</span> limit)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> arr[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">revalue</span><span class="params">(<span class="keyword">double</span> r, <span class="keyword">double</span> arr[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">double</span> properties[Max];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = fill_array(properties, Max);</span><br><span class="line">    show_array(properties, <span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter revaluation factor: "</span>;</span><br><span class="line">        <span class="keyword">double</span> factor;</span><br><span class="line">        <span class="keyword">while</span> (!(<span class="built_in">cin</span> &gt;&gt; factor))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">cin</span>.<span class="built_in">get</span>() != <span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Bad input; Please enter a number: "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        revalue(factor, properties, <span class="built_in">size</span>);</span><br><span class="line">        show_array(properties, <span class="built_in">size</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Done.\n"</span>;</span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill_array</span><span class="params">(<span class="keyword">double</span> arr[], <span class="keyword">int</span> limit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">double</span> temp;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter value #"</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">cin</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">cin</span>.<span class="built_in">get</span>() != <span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Bad input; input process terminated.\n"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Property #"</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">": $"</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">revalue</span><span class="params">(<span class="keyword">double</span> r, <span class="keyword">double</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        arr[i] *= r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-程序说明"><a href="#5-程序说明" class="headerlink" title="5.程序说明"></a>5.程序说明</h3><p>回顾一下整个过程。我们首先考虑的是通过数据类型和设计适当的函数来处理数据，然后讲这些函数组合成一个程序。有时这个也称为自下而上的程序设计（bottom-up programming)，因为设计过程是从组建到整体进行。这种方法非常适合于OOP——它首先强调的是数据表示和操纵。</p><p>以前的过程性编程倾向于从上而下的程序设计，首先指定模块化设计方案，然后在研究细节，</p><p>最终产品都是模块化程序，也就是我们最后得到的东西都是模块化的东西，据我目前的经验来看，当代程序的思路都是模块化！</p><h3 id="6-数组处理函数的常用编写方式"><a href="#6-数组处理函数的常用编写方式" class="headerlink" title="6.数组处理函数的常用编写方式"></a>6.数组处理函数的常用编写方式</h3><p>总结一下数组处理函数无非就两种情况</p><p>情况一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_modify</span><span class="params">(<span class="keyword">double</span> ar[], <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>情况二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _f_no_change(<span class="keyword">const</span> <span class="keyword">double</span> ar[], <span class="keyword">int</span> n);</span><br></pre></td></tr></table></figure><p>再扯几句哈，函数原型是可以省略变量名的，也可以将返回类型作指定，比如这边就指定了void。</p><h3 id="7-使用数组区间的函数"><a href="#7-使用数组区间的函数" class="headerlink" title="7.使用数组区间的函数"></a>7.使用数组区间的函数</h3><p>上面我们讲数组和函数的时候，用的是传统的C++方法，将指向数组起始处的指针作为一个参数，将数组长度作为第二个参数（指针指出数组的位置和数组类型），这样便给函数提供了找到所有数据所需要的信息。</p><p>我们处理数组的C++函数，必须将数组中的数据种类、数组的起始位置和数组中元素数量给函数。</p><p>还有一种给函数提供所需信息的方法是，即指定元素区间，这可以通过传递两个指针来完成：一个指针表示数组的开头，另一个指针标识数组的尾部。（C++标准模板库STL中将区间方法广义化了，STL方法使用“ 超尾”概念来指定区间，也就是说，对于数组而言，标识数组结尾的参数将是指向最后一个元素后面的指针。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> elboud[<span class="number">20</span>];</span><br></pre></td></tr></table></figure><p>指针elboud和elboud+20定义了区间。唉，其实就是数组名+多少个（数字）从而做出区间，写个小例子便于理解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ArSize = <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> * <span class="built_in">begin</span>, <span class="keyword">const</span> <span class="keyword">int</span> * <span class="built_in">end</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">int</span> things[ArSize] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = sums(things, things + ArSize);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Total things eaten: "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    sum = sums(things, things + <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"First three people buy "</span> &lt;&lt; sum &lt;&lt; <span class="string">" things.\n"</span>;</span><br><span class="line">    sum = sums(things + <span class="number">4</span>, things + <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Last four people buy "</span> &lt;&lt; sum &lt;&lt; <span class="string">" things.\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> * <span class="built_in">begin</span>, <span class="keyword">const</span> <span class="keyword">int</span> * <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> * pt;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(pt = <span class="built_in">begin</span>; pt != <span class="built_in">end</span>; pt++)</span><br><span class="line">        total += *pt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>太简单了，不解释了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;函数与数组&quot;&gt;&lt;a href=&quot;#函数与数组&quot; class=&quot;headerlink&quot; title=&quot;函数与数组&quot;&gt;&lt;/a&gt;函数与数组&lt;/h1&gt;&lt;p&gt;虽然我上面开了两篇博客准备一锅把函数端掉，但是当我想到数组哈，我觉得还是有必要对它好好搞一番。为什么呢？因为当我们在
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="C++" scheme="https://mr8god.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>是个值得纪念的日子呢</title>
    <link href="https://mr8god.cn/2020/04/01/%E7%94%9F%E6%B4%BB%E9%9C%80%E8%A6%81%E4%B8%80%E4%BA%9B%E8%B6%A3%E5%91%B3%E5%93%A6%EF%BC%81/%E6%98%AF%E4%B8%AA%E5%80%BC%E5%BE%97%E7%BA%AA%E5%BF%B5%E7%9A%84%E6%97%A5%E5%AD%90%E5%91%A2/"/>
    <id>https://mr8god.cn/2020/04/01/%E7%94%9F%E6%B4%BB%E9%9C%80%E8%A6%81%E4%B8%80%E4%BA%9B%E8%B6%A3%E5%91%B3%E5%93%A6%EF%BC%81/%E6%98%AF%E4%B8%AA%E5%80%BC%E5%BE%97%E7%BA%AA%E5%BF%B5%E7%9A%84%E6%97%A5%E5%AD%90%E5%91%A2/</id>
    <published>2020-04-01T05:28:32.919Z</published>
    <updated>2020-04-01T05:30:59.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="韶光易逝，劝君惜取少年时！"><a href="#韶光易逝，劝君惜取少年时！" class="headerlink" title="韶光易逝，劝君惜取少年时！"></a>韶光易逝，劝君惜取少年时！</h1><p><img src="https://i.loli.net/2020/04/01/V1cH7yJTen8SgZz.jpg" alt="Screenshot_2020-03-31-18-16-24-491_com.maimemo.an.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;韶光易逝，劝君惜取少年时！&quot;&gt;&lt;a href=&quot;#韶光易逝，劝君惜取少年时！&quot; class=&quot;headerlink&quot; title=&quot;韶光易逝，劝君惜取少年时！&quot;&gt;&lt;/a&gt;韶光易逝，劝君惜取少年时！&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.n
      
    
    </summary>
    
    
      <category term="生活需要一些趣味" scheme="https://mr8god.cn/categories/%E7%94%9F%E6%B4%BB%E9%9C%80%E8%A6%81%E4%B8%80%E4%BA%9B%E8%B6%A3%E5%91%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>论数理统计中统计量，常用统计量</title>
    <link href="https://mr8god.cn/2020/04/01/%E6%95%B0%E7%90%86%E7%9F%A5%E8%AF%86/%E8%AE%BA%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E4%B8%AD%E7%BB%9F%E8%AE%A1%E9%87%8F%EF%BC%8C%E5%B8%B8%E7%94%A8%E7%BB%9F%E8%AE%A1%E9%87%8F/"/>
    <id>https://mr8god.cn/2020/04/01/%E6%95%B0%E7%90%86%E7%9F%A5%E8%AF%86/%E8%AE%BA%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E4%B8%AD%E7%BB%9F%E8%AE%A1%E9%87%8F%EF%BC%8C%E5%B8%B8%E7%94%A8%E7%BB%9F%E8%AE%A1%E9%87%8F/</id>
    <published>2020-04-01T05:23:07.889Z</published>
    <updated>2020-04-01T05:23:49.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="论数理统计中统计量，常用统计量"><a href="#论数理统计中统计量，常用统计量" class="headerlink" title="论数理统计中统计量，常用统计量"></a>论数理统计中统计量，常用统计量</h1><p><img src="https://i.loli.net/2020/04/01/iLPZ5e413UNdvW6.jpg" alt="391.jpg"></p><h2 id="从样本中提取有用的信息来研究总体的分布及各种特征数的过程叫做构造统计量"><a href="#从样本中提取有用的信息来研究总体的分布及各种特征数的过程叫做构造统计量" class="headerlink" title="从样本中提取有用的信息来研究总体的分布及各种特征数的过程叫做构造统计量"></a>从样本中提取有用的信息来研究总体的分布及各种特征数的过程叫做构造统计量</h2><p>统计量：样本的不含任何位置参数的函数</p><p><img src="https://i.loli.net/2020/04/01/KDc79iWh8Tvz6xy.jpg" alt="392.jpg"></p><h2 id="常用统计量"><a href="#常用统计量" class="headerlink" title="常用统计量"></a>常用统计量</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>样本均值<br>样本方差<br>样本标准差<br>样本矩</p><h4 id="样本均值和总体均值的区别"><a href="#样本均值和总体均值的区别" class="headerlink" title="样本均值和总体均值的区别"></a>样本均值和总体均值的区别</h4><p><img src="https://i.loli.net/2020/04/01/oOYC6BNKpJxyRDu.jpg" alt="393.jpg"></p><p><img src="https://i.loli.net/2020/04/01/cWUvxPpwblEDnhQ.jpg" alt="394.jpg"></p><p><img src="https://i.loli.net/2020/04/01/KbjzXNJBZxSL8ht.jpg" alt="395.jpg"></p><p>从上面的例子我们可以总结出这样的结论</p><p>样本均值的平均值等于总体均值<br>样本方差的平均值等于总体均值</p><h3 id="当总体数字特征未知时，我们可以总结出以下的方法来求数字特征"><a href="#当总体数字特征未知时，我们可以总结出以下的方法来求数字特征" class="headerlink" title="当总体数字特征未知时，我们可以总结出以下的方法来求数字特征"></a>当总体数字特征未知时，我们可以总结出以下的方法来求数字特征</h3><ol><li>用样本均值估计总体均值</li><li>用样本方差估计总体方差</li><li>用样本原点矩估计总体原点矩</li><li>用样本中心矩估计总体中心矩</li></ol><h3 id="统计量的分布被称为抽样分布"><a href="#统计量的分布被称为抽样分布" class="headerlink" title="统计量的分布被称为抽样分布"></a>统计量的分布被称为抽样分布</h3><p>总体服从一般分布，如指数分布均匀，分布等要得出统计量的分布是很困难的<br>总体服从正态分布时统计量样本均值样本方差是可以计算的</p><h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><p>方法：</p><ol><li>求最大最小值，并求极差</li><li>分组定组距（一般数据个数n&gt;=50，分成10组以上；小于的时候，一般分为5组）</li><li>定分点定区间</li><li>统计数据落入各组间的概率</li><li>画出直方图</li></ol><p>作图反应数据特征</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;论数理统计中统计量，常用统计量&quot;&gt;&lt;a href=&quot;#论数理统计中统计量，常用统计量&quot; class=&quot;headerlink&quot; title=&quot;论数理统计中统计量，常用统计量&quot;&gt;&lt;/a&gt;论数理统计中统计量，常用统计量&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://
      
    
    </summary>
    
    
      <category term="数理知识" scheme="https://mr8god.cn/categories/%E6%95%B0%E7%90%86%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="概率论" scheme="https://mr8god.cn/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>论概率论中大数定理及中心极限定理</title>
    <link href="https://mr8god.cn/2020/03/30/%E6%95%B0%E7%90%86%E7%9F%A5%E8%AF%86/%E5%A4%A7%E6%95%B0%E5%AE%9A%E7%90%86%E5%8F%8A%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/"/>
    <id>https://mr8god.cn/2020/03/30/%E6%95%B0%E7%90%86%E7%9F%A5%E8%AF%86/%E5%A4%A7%E6%95%B0%E5%AE%9A%E7%90%86%E5%8F%8A%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/</id>
    <published>2020-03-30T12:11:08.084Z</published>
    <updated>2020-03-31T15:15:47.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大数定理及中心极限定理"><a href="#大数定理及中心极限定理" class="headerlink" title="大数定理及中心极限定理"></a>大数定理及中心极限定理</h1><h2 id="依概率收敛、切比雪夫不等式"><a href="#依概率收敛、切比雪夫不等式" class="headerlink" title="依概率收敛、切比雪夫不等式"></a>依概率收敛、切比雪夫不等式</h2><h3 id="依概率收敛"><a href="#依概率收敛" class="headerlink" title="依概率收敛"></a>依概率收敛</h3><p><strong>定义</strong></p><p><img src="https://i.loli.net/2020/03/31/76nd8sprowBZkF3.jpg" alt="依概率收敛.jpg"></p><p>稍微解释一下哈，当存在一个任意值ε（大于0哈），当我们的n趋向于无穷大的时候，那么这个概率趋向于零。当然这么说就只是表面意思意思了，我们得详细地去了解一下呀。</p><p>这边需要举个例子了</p><p><img src="https://i.loli.net/2020/03/31/rZAgH74IonLY5CK.jpg" alt="依概率收敛的详细解释.jpg"></p><p>江某人有话说：这里看到贝努利试验，我想大家肯定会松了一大口气，因为这个东西大家肯定都懂。像咱们抛一次硬币就算一次贝努利试验，但是我们抛了n次硬币。这就叫做n重贝努利试验。</p><p>扯回正题哈，当咱们对某一件事件进行观测的时候，若事件A（为了便于解释，就把某一件事件设为事件A了）在一次试验发生的概率为P。利用n次事件中出现了na次事件A，算出事件A出现的频率（n/na）。</p><p>注意了。图中的公式是错误的。也就是，当n越大的时候，并不意味这一次事件的概率与咱们算的频率相等。我们讲的频率“稳定于”概率应该从<strong>可能性角度</strong>来讲。</p><p><img src="https://i.loli.net/2020/03/31/qaprc7XbC5zTJAf.jpg" alt="从可能性来讲概率收敛.jpg"></p><p>得出概念，只有满足以下公式</p><script type="math/tex; mode=display">\lim_{n\rightarrow+\infty}P\{|\frac{na}{n}-p|\geq ε\}=0</script><p>（楼上的公式打的不容易呀，害，真刺激！）</p><p>那么这种收敛就称为“依概率收敛”</p><p><strong>依概率收敛的性质：</strong></p><p><img src="https://i.loli.net/2020/03/31/ZYroinA1RM6qgch.jpg" alt="依概率收敛的性质.jpg"></p><p>这边就由我江某人来给大家稍微讲解一下以助于理解哈：</p><p>首先前三行的意思是，当Xn依概率收敛到a，Yn依概率收敛到b，那么当n趋向于无穷是，且函数g(x,y)在点(a,b)上连续，那么g(Xn,Yn)依概率收敛到g(a,b)。</p><p>中间两行的意思是，Xn+Yn会依概率收敛到a+b，Xn/Yn会依概率收敛到a/b，XnxYn会依概率收敛到axb。</p><p>特别需要记住一点的是，最后两行，如果Xn依概率收敛到a，f(x)在a点连续，那么当n趋向于无穷的时候，f(Xn)依概率收敛到f(a)。</p><h3 id="切比雪夫不等式（Chebyshev不等式）"><a href="#切比雪夫不等式（Chebyshev不等式）" class="headerlink" title="切比雪夫不等式（Chebyshev不等式）"></a>切比雪夫不等式（Chebyshev不等式）</h3><p>设随机变量X具有数学期望，且它的数学期望E(X)=μ，方差D(X)=$σ^2$，则对于任意$ε&gt;0$，都有：</p><script type="math/tex; mode=display">P\{|X-μ|\geq ε\} \leq \frac{σ^2}{ε^2}</script><p>定理的等价形式为：</p><script type="math/tex; mode=display">P\{|X-μ| < ε\} \geq 1-\frac{σ^2}{ε^2}</script><p>// 此处明天补上证明过程。。。</p><p>X与它均值的偏差的绝对值大于等于ε的概率小于<script type="math/tex">\frac{σ^2}{ε^2}</script></p><p>适用范围广，但是结果相对来说比较粗糙。</p><p>//  此处后期补上例题解析</p><h2 id="大数定律"><a href="#大数定律" class="headerlink" title="大数定律"></a>大数定律</h2><p>频率的稳定值记为概率，这句话的意思，可以用一个公式来进行描述。</p><script type="math/tex; mode=display">\lim_{n\rightarrow+\infty}P\{|\frac{na}{n}-p|\geq ε\}=0</script><p>这个结论可以用“大数定律”来进行描述</p><p><strong>定理1（贝努力大数定律）</strong></p><p>记na为n重贝努利试验中事件A发生的次数，并记事件A在每次试验中发生的概率为p(0<p<1)，则对于$&forall ε > 0$有</p><script type="math/tex; mode=display">\lim_{n\rightarrow+\infty}P\{|\frac{na}{n}-p|\geq ε\}=0</script><p>即$\frac{na}{n}$趋向于P，当n趋向于+$\infty$</p><p>这就说明了，频率是依概率收敛的事件发生的概率的！！！</p><p>证明：略，明天补上。。。</p><p><strong>贝努力大数定律的重要意义：</strong></p><ol><li>提供了用大量重复独立试验中事件出现概率的极限值来确定概率的理论依据，使得概率的概念才有严格的意义。</li><li>提供了通过试验来确定事件概率的方法——可以通过做试验确定某事件发生的频率，并把它作为相应的概率估计，例如：想估计某产品的不合格品率p,可以随机抽取n（n较大）件，将n件产品的不合格品的比例作为p的估计。</li></ol><p><strong>大数定律(Laws of Large Numbers)</strong></p><p>内容：设X1，X2，……，Xn，……是一列随机变量，则在一定条件下，随机变量序列Yn=$\frac{X1+……+Xn}{n} $，收敛到μ，当n趋向于$\infty$的时候。</p><p>这边需要帮助理解的几个点是：</p><ol><li>随机变量序列Yn收敛到μ的含义是什么？答：依概率收敛</li><li>μ是什么？答：当Xi期望相同时，μ = E(Xi)</li><li>一定条件是什么？答：不一样的条件会得到不同的大数定律</li></ol><p><strong>定理2（切比雪夫大数定律的推论）</strong></p><p><strong>定理3（辛钦大数定律）</strong></p><p><strong>辛钦大数定律的意义：</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;大数定理及中心极限定理&quot;&gt;&lt;a href=&quot;#大数定理及中心极限定理&quot; class=&quot;headerlink&quot; title=&quot;大数定理及中心极限定理&quot;&gt;&lt;/a&gt;大数定理及中心极限定理&lt;/h1&gt;&lt;h2 id=&quot;依概率收敛、切比雪夫不等式&quot;&gt;&lt;a href=&quot;#依概率收
      
    
    </summary>
    
    
      <category term="数理知识" scheme="https://mr8god.cn/categories/%E6%95%B0%E7%90%86%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="概率论" scheme="https://mr8god.cn/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>第7章 函数——C++的编程模块（下）</title>
    <link href="https://mr8god.cn/2020/03/30/C++/%E7%AC%AC7%E7%AB%A0-%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94C++%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>https://mr8god.cn/2020/03/30/C++/%E7%AC%AC7%E7%AB%A0-%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94C++%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2020-03-29T16:22:27.120Z</published>
    <updated>2020-03-30T08:06:43.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="7-2-函数参数和按值传参"><a href="#7-2-函数参数和按值传参" class="headerlink" title="7.2    函数参数和按值传参"></a>7.2    函数参数和按值传参</h2><p>C++中经常性的一种操作就是，案值传递参数，这意味着将数值传递给一个函数，然后后者还会返回一个值赋给一个新的变量。</p><p>在函数中被声明的变量是函数私有的，这是他自己凭本事声明的变量。在函数被调用时，计算机会为他们（指变量）申请内存。在函数结束的时候，计算机会释放掉内存，这样的变量我们称之为<strong>局部变量</strong></p><h3 id="7-2-1-多个参数"><a href="#7-2-1-多个参数" class="headerlink" title="7.2.1    多个参数"></a>7.2.1    多个参数</h3><p>函数可以包含多个参数，例如写成这种形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function(<span class="string">'R'</span>, <span class="number">25</span>);</span><br></pre></td></tr></table></figure><p>上述函数调用将两个参数传递给函数function( )，</p><p>同样，在定义函数时，也在函数头中使用由逗号分割的参数声明列表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> n)</span></span></span><br></pre></td></tr></table></figure><p>之前写的function中R传递给了c，25传递给了n</p><h3 id="7-2-2-另外一个接受两个参数的函数"><a href="#7-2-2-另外一个接受两个参数的函数" class="headerlink" title="7.2.2    另外一个接受两个参数的函数"></a>7.2.2    另外一个接受两个参数的函数</h3><p><strong>注意了注意了，这边要讲一个比较有趣的东西了</strong></p><p>Problem：美国许多州都采用某种纸牌游戏的形式来发行彩票，让参与者从卡片中选择一定数目的选项，例如从51个数字中选取6个，随后彩票管理者将随机抽取6个数，如果参与者选择的数字与这6个完全相同，将赢得大约几百万美元的奖金，我们的函数将计算中奖的几率</p><p>首先，需要一个公式。假设必须要从51个数中选取6个数，而获奖的几率是1/R，则R的计算公式如下</p><script type="math/tex; mode=display">R =\frac  {51×50×49×48×47×46}{6×5×4×3×2×1}</script><p>选择6个数时，分母为前6个整数的乘积或6的阶乘分子也是6个连续整数的乘积，从51开始依次递减一,推而广之，如果从numbers个数中选取picks个数，而分母是picks的阶乘，分子为numbers开始向前的picks个整数的乘积。可以用for循环进行计算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> result = <span class="number">1.0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = numbers, p = picks; p &gt; <span class="number">0</span>; n--, p--)</span><br><span class="line">    result = result * n / p;</span><br></pre></td></tr></table></figure><p>循环不是首先将所有的分子项相乘，而是首先将1.0与第1个分子项相乘，然后除以第1个分母项，然后下一轮循环，乘以第2个分子项并除以第2个分母项，这样得到的乘积和先进行乘法运算得到的一样，例如对于(10*9)/(2×1)和(10÷2)×(9÷1)，前者将计算90÷2得到45，或者将计算5×9得到49，这两种方法得到的结果相同，但前者的中间值90大于后者，因子越多，中间值的差别就越大，当数字非常大时，这种交替进行乘除运算的策略，可以防止中间结果超过最大的浮点数。</p><h3 id="7-3-函数和数组"><a href="#7-3-函数和数组" class="headerlink" title="7.3    函数和数组"></a>7.3    函数和数组</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;7-2-函数参数和按值传参&quot;&gt;&lt;a href=&quot;#7-2-函数参数和按值传参&quot; class=&quot;headerlink&quot; title=&quot;7.2    函数参数和按值传参&quot;&gt;&lt;/a&gt;7.2    函数参数和按值传参&lt;/h2&gt;&lt;p&gt;C++中经常性的一种操作就是，案值传递参
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="C++" scheme="https://mr8god.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>From Mr8god：hexo轻松搭建博客</title>
    <link href="https://mr8god.cn/2020/03/28/%E5%BB%BA%E7%AB%99%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/From%20Mr8god%EF%BC%9Ahexo%E8%BD%BB%E6%9D%BE%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://mr8god.cn/2020/03/28/%E5%BB%BA%E7%AB%99%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/From%20Mr8god%EF%BC%9Ahexo%E8%BD%BB%E6%9D%BE%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-03-28T10:54:20.067Z</published>
    <updated>2020-04-05T14:08:18.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境概述"><a href="#环境概述" class="headerlink" title="环境概述"></a>环境概述</h2><p>我粗略估计了一下哈，大概需要以下东西</p><ul><li>win10系统</li><li>hexo运行环境：node.js</li><li>下载包管理工具：npm</li><li>版本控制工具：git</li><li>IDE：vscode</li><li>主题：我就暂时用初始的landscape了</li></ul><p>当然ide是可以随便换的啦，用记事本也行呢。这种博客后期都是要靠Markdown来上传自己的文章的，且为了要让博客更加的适合自己，做出个性化的博客，需要你们去了解css、js等一些知识。</p><p>如果你学过git，那么这个教程就更简单了，纯粹就是帮你复习一遍git而已啦。</p><p>废话不多说，开始进入正题。</p><h2 id="搭建博客流程"><a href="#搭建博客流程" class="headerlink" title="搭建博客流程"></a>搭建博客流程</h2><h3 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h3><p>node.js需要下载好，官网下载即可</p><p>git也需要提前下载好，官网下载即可</p><h3 id="二、使用hexo博客搭建工具"><a href="#二、使用hexo博客搭建工具" class="headerlink" title="二、使用hexo博客搭建工具"></a>二、使用hexo博客搭建工具</h3><h4 id="Step1-本地新建文件夹"><a href="#Step1-本地新建文件夹" class="headerlink" title="Step1 本地新建文件夹"></a>Step1 本地新建文件夹</h4><p>这个文件夹会存储你博客之后所有的Markdown文件以及你生成的HTML文件</p><h4 id="Step2-进入目录让我们git-bash一下"><a href="#Step2-进入目录让我们git-bash一下" class="headerlink" title="Step2 进入目录让我们git bash一下"></a>Step2 进入目录让我们git bash一下</h4><p>这边我建立了名为“教程演示用博客”的文件夹，右击bash一下</p><p><img src="https://i.loli.net/2020/03/28/sybeN7tziCJREgU.jpg" alt="1.jpg"></p><h4 id="Step3-安装hexo"><a href="#Step3-安装hexo" class="headerlink" title="Step3 安装hexo"></a>Step3 安装hexo</h4><p>命令就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>如果网速慢的话可以采取cnpm安装，这边推荐一个博客讲解cnpm源更改哈：<a href="https://blog.csdn.net/cungudafa/article/details/98739459" target="_blank" rel="noopener">https://blog.csdn.net/cungudafa/article/details/98739459</a></p><p><img src="https://i.loli.net/2020/03/28/FHAVas5SlvbK8XB.jpg" alt="2.jpg"></p><h4 id="Step4-初始化hexo模板"><a href="#Step4-初始化hexo模板" class="headerlink" title="Step4 初始化hexo模板"></a>Step4 初始化hexo模板</h4><p>命令是</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/03/28/FEs67nYOLIJpVTN.jpg" alt="3.jpg"></p><p>在这边你或许会遇到一个问题，初始化速度极慢，令人难以忍受，咳咳，仔细思考哈。这个是有npm安装的，那问题自然出在npm上面，咱们换个源就行了，刚刚上一步你换过了的话这里就不用换啦，这边可以换阿里或者淘宝的源，蛮好的，继续偷懒，放上链接：<a href="https://blog.csdn.net/cungudafa/article/details/98739459" target="_blank" rel="noopener">https://blog.csdn.net/cungudafa/article/details/98739459</a></p><h4 id="Step5-初始化后的文件树"><a href="#Step5-初始化后的文件树" class="headerlink" title="Step5 初始化后的文件树"></a>Step5 初始化后的文件树</h4><p><img src="https://i.loli.net/2020/03/28/xwJP2vzKDOsGWVo.png" alt="43.png"></p><p>其中source_posts里边存放的都是Markdown格式文件，也就是咱们日后的博客文件哟</p><p>注意了，上面这幅图呀，只是为了给大家对照一下本地hexo init之后的文件夹是否缺啥漏啥，不要过分纠结哦。</p><p>比如我这边打开我的“教程演示用博客”文件夹，可以看到里边的文件架构和图片上显示的简直一模一样呢！</p><h4 id="Step6-hexo使用教程"><a href="#Step6-hexo使用教程" class="headerlink" title="Step6 hexo使用教程"></a>Step6 hexo使用教程</h4><p>hexo日常三命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment"># 清空已有hexo网站文件</span></span><br><span class="line">hexo generate(<span class="keyword">or</span> g) <span class="comment"># 依据网页文本与新的CSS样式生成新网站文件</span></span><br><span class="line">hexo server(<span class="keyword">or</span> s) <span class="comment"># 启动本地服务器，可以在localhost:4000查看网站修改效果</span></span><br></pre></td></tr></table></figure><h5 id="hexo入门教学"><a href="#hexo入门教学" class="headerlink" title="hexo入门教学"></a>hexo入门教学</h5><ol><li>老规矩，在博客页面下git bash一下，直接上面三连，这里边的意思呢，是说把上面三个命令，依次输入到咱们的gitbash上面，然后我们在我们的浏览器中输入localhost:4000，即可看到网站效果</li><li>一般咱们都是默认的landscape主题，后期当提交新文章或者新的样式的时候，往往都是从本地看好结果，确认无误后再部署到服务器上的，当然我在本地记录了各个版本。其实git版本控制器就是有这一部分的命令的，不过我暂时没有完全掌握哈，只能用老办法复制粘贴备份本地的博客</li><li>这边要注意了hexo有很多 主题，各种主题都很好请自己选择，官网主题：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></li><li>主题配置，在博客文件夹下主目录找到_config.yml，打开后，修改theme:landscape为自己选择的主题就行了</li></ol><h5 id="部署服务器教学"><a href="#部署服务器教学" class="headerlink" title="部署服务器教学"></a>部署服务器教学</h5><p>部署服务器呢，这里有这三种方案</p><ol><li>部署到github上<br>好处：免费，且安全，而且受众度广，知名度高<br>缺点：由于服务器不在国内，所以访问速度会慢</li><li>部署到gitee上：<br>楼上说的全部反过来就行了<br>好处：访问速度快<br>缺点：绑定自己家的域名居然还要我花钱？？？？害白嫖党不理解，不安全，发生过事故，而且仓库里的代码居然是保存在人家的服务器（阿里云，腾讯云）上的 你敢信？！！！<br>不过还是挺好的，嗯呢，说心里话呢，鼓励他</li><li>既部署到GitHub上又部署到gitee上：<br>嘿嘿嘿，想不到吧，我还能白嫖，取两家之长处，助自己之力，哈哈哈，<br>自主研发，别人还真没有（网上找不到哦）</li></ol><h6 id="部署到github上"><a href="#部署到github上" class="headerlink" title="部署到github上"></a>部署到github上</h6><ol><li><p>首先申请github账号</p></li><li><p>然后开始建仓库，这个建仓库很有讲究</p><p>仓库名应该是账号名加.github.io<br>比方说我github账号为mr8god，我的仓库名就是mr8god.github.io<br>仓库地址就是Mr8god/Mr8god.github.io<br>然后选择public公开就行了其他就OK了</p></li><li><p><img src="https://i.loli.net/2020/03/28/d34ShBQy2JCUgp7.jpg" alt="5.jpg" style="zoom: 50%;" /></p></li><li><p>建完仓库后你会看到这个页面<br>复制http后边那个ssh的地址，待会用得到这边为了演示，我就创建了我的mr6god仓库哈<br>地址就是：git@github.com:Mr8god/mr6god.github.io.git</p></li><li><p>这边我需要插一句，本地上传到服务器的工具就是Git版本控制工具，如果你能够熟练掌握git的使用，那么做这个博客很简单，也就是复习一下git的使用方法而已，但是如果你不熟悉的话，就略微麻烦而已。</p></li><li><p>这边将本地博客推送到githubpage（就是我刚刚说的服务器）之前，需要用到一个命令，在命令行（gitbash）运行这行命令：$ npm install hexo-deployer-git —save</p></li><li><p>然后咱们就可以使用hexo deployer进行推送，在推送的时候会遇到要求输入账号密码，照着输入就行了。<br>但是我们日后推送的话总不能每一次都输入密码吧，这边推荐SSH key秘钥连接，这边就不赘述了哈，自行百度</p></li><li><p>来了来了，最重要的就是这一步修改文件，还是刚刚的_config.yml文件，在文件末尾修改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>注意了，上面仓库填ssh地址，不是HTTP地址，就是这样，这边可以写git@github.com:Mr8god/mr6god.github.io.git</p></li><li><p>然后返回我们的gitbash 输入下面两行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li><li><p>过一会访问域名：<br>https://<Github账号名称>.github.io<br>就可以咯，然后就会是你本地的博客页面了</p></li></ol><h6 id="部署到gitee上"><a href="#部署到gitee上" class="headerlink" title="部署到gitee上"></a>部署到gitee上</h6><ol><li><p>老规矩，申请码云账户，新建仓库</p></li><li><p>仓库名字必须和你注册githee的注册名相同，不然css路径会读错</p></li><li><p>得到咱们的仓库地址，复制下来</p></li><li><p>接下来就是和github不同的一点了，码云需要到它的服务页面打开page功能</p><p><img src="https://i.loli.net/2020/03/28/eiyDRVu9GHqQbB1.jpg" alt="6.jpg" style="zoom:50%;" /></p><p><img src="https://i.loli.net/2020/03/28/QsxBjbqgwpt6uI3.jpg" alt="7.jpg" style="zoom:50%;" /></p><p>启动部署即可</p></li><li><p>返回咱们的本地博客目录，修改主目录下的_config.yml文件，在文件末尾修改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>这边将本地博客推送到码云仓库之前（就是我刚刚说的服务器），需要用到一个命令，在命令行（gitbash）运行这行命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>然后返回我们的gitbash 输入下面两行代码：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li><li><p>然后输入<br> http://&lt;码云用户名&gt;.gitee.io/<br> 就可以 看到我们本地的博客样子了</p></li></ol><h6 id="既部署到GitHub上又部署到gitee上"><a href="#既部署到GitHub上又部署到gitee上" class="headerlink" title="既部署到GitHub上又部署到gitee上"></a>既部署到GitHub上又部署到gitee上</h6><p>在我们干完上面的两件事之后，其实很多都是重复工作，我们只需要修改一个配置文件就行了，就是咱们的网站配置文件_config.yml</p><p><img src="https://i.loli.net/2020/03/28/kqI9ngwjXp2531O.jpg" alt="8.jpg"></p><p>改成上面这个样子就可以了</p><p>我想讲一下为什么会有第三种方案的诞生哈，因为考虑到github的服务器搭在国外，所以我们日常访问上面的博客的时候它会很慢，于是我们可以靠这种方法去分流哈。分流的意思是，当我访问一个域名（这个域名同时解析了我两个博客page的地址）的时候，会自动根据我们离哪个服务器更近而自动去选择访问哪个服务器。</p><p>其实这种做法有专门的名词，叫做负载均衡。可以使用cdn服务来达到同样一个效果。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>emmmm，说一下之后的发展，已经在搭其他框架了，打算用回归老本行，重拾Django，用这个框架做更细致的博客哈。</p><p>然后gitee肯定是要淘汰掉的，因为他居然要付费才能让我选择自定义的域名，每年一百，啧啧啧，害。而且它也不安全嘛，思来想去，换掉它指日可待。</p><p>暂时就写这么多啦。然后呢，有啥问题要交流的，暂时我就放我的QQ啦：1803357141。因为还没做其他功能。害，就是这样。欢迎交流！</p><p>对了对了，最后感谢一位程序媛的博客对我的帮助，放上她的博客地址哈：<a href="https://cungudafa.gitee.io/" target="_blank" rel="noopener">https://cungudafa.gitee.io/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;环境概述&quot;&gt;&lt;a href=&quot;#环境概述&quot; class=&quot;headerlink&quot; title=&quot;环境概述&quot;&gt;&lt;/a&gt;环境概述&lt;/h2&gt;&lt;p&gt;我粗略估计了一下哈，大概需要以下东西&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;win10系统&lt;/li&gt;
&lt;li&gt;hexo运行环境：node
      
    
    </summary>
    
    
      <category term="建博客那些事儿" scheme="https://mr8god.cn/categories/%E5%BB%BA%E5%8D%9A%E5%AE%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    
    
      <category term="hexo_Next" scheme="https://mr8god.cn/tags/hexo-Next/"/>
    
  </entry>
  
  <entry>
    <title>第7章 函数——C++的编程模块（上）</title>
    <link href="https://mr8god.cn/2020/03/25/C++/%E7%AC%AC7%E7%AB%A0%20%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94C++%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97/"/>
    <id>https://mr8god.cn/2020/03/25/C++/%E7%AC%AC7%E7%AB%A0%20%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94C++%E7%9A%84%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9D%97/</id>
    <published>2020-03-25T08:48:52.497Z</published>
    <updated>2020-03-30T01:08:52.680Z</updated>
    
    <content type="html"><![CDATA[<p>C++自带一个包含函数的大型库（标准ANSI库加上多个C++类），但真正的编程乐趣在于编写自己的函数；另一方面，要提高编程效率，可以更深入地学习STL和BOOSTC++提供的功能。</p><h2 id="7-1-复习函数的基本知识"><a href="#7-1-复习函数的基本知识" class="headerlink" title="7.1    复习函数的基本知识"></a>7.1    复习函数的基本知识</h2><p>来复习一下介绍过的有关函数的知识。要使用C++函数，必须完成以下工作：</p><ul><li>提供函数的定义</li><li>提供函数原型</li><li>调用函数</li></ul><p>库函数是已经定义好和编译好的函数，同时可以使用标准库头文件提供其原型，因此只需正确地调用这种函数即可。比如说strlen()函数，可以用来确定字符串的长度。相关的标准头文件cstring包含了strlen()和其他一些与字符串相关的函数的原型。</p><p>然后还有一点要注意的是，咱们程序员在编写函数的时候，一定要注意三点——定义、提供原型、调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"main() will call the simple() function:\n"</span>;</span><br><span class="line">    simple();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"main() is finished with the simple() function.\n"</span>;</span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm but a simple function.\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是一个小例子。</p><h3 id="7-1-1-定义函数"><a href="#7-1-1-定义函数" class="headerlink" title="7.1.1    定义函数"></a>7.1.1    定义函数</h3><p>可以将函数分为两类：没有返回值的函数和有返回值的函数。没有返回值的函数被称为void函数，其通用格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionName</span><span class="params">(parameterList)</span></span>&#123;</span><br><span class="line">statement(s)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，paramterList指定了传递给函数的参数类型和数量，本章后面将更详细地介绍该列表。可选的返回语句标记了函数的结尾；否则，函数将在右花括号处结束。</p><p>对于返回值，需要注意的是，</p><ul><li>如果原函数的数据类型是double但是返回的是int，返回值将会被强制转化为double</li><li>C++对返回值的类型有一定的限制：不能是数组，但可以是其他任何类型——整数、浮点数、指针、甚至可以是结构和对象（不过我们可以将数组作为结构或对象组成部分来返回）</li><li>若函数包含多条返回语句（例如，它们位于不同的ifelse选项中）则函数在执行遇到的第一条返回语句后结束。</li></ul><p>干货分享：虽然作为一名程序员不需要知道函数是怎么返回值的，但是对这个问题有所了解有助于澄清概念。</p><p>通常函数通过将返回值复制到指定的CPU寄存器或内存单元中来将其返回。</p><p>随后，调用程序将查看该存储单元。</p><p>返回函数和调用函数必须就该内存单元中存储的数据的类型达成一致。</p><p>函数原型将返回值类型告知调用程序，而函数定义命令被调用函数应返回什么类型的数据。</p><p>在原型中提供与定义中相同的信息似乎有些多余，但这样做确实有道理。要让信差从办公室的办公桌上取走一些物品，则向信差和办公室中的同事交代自己的意图，将提高信差顺利完成这项工作的概率。</p><h3 id="7-1-2-函数原型和函数调用"><a href="#7-1-2-函数原型和函数调用" class="headerlink" title="7.1.2    函数原型和函数调用"></a>7.1.2    函数原型和函数调用</h3><p>咱们对函数调用这个知识点是很熟悉的，但是对函数原型并不清楚，函数原型通常隐藏在include文件中。</p><p>　<a href="https://www.baidu.com/s?wd=函数声明&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">函数声明</a>由函数返回类型、函数名和形参列表组成。形参列表必须包括形参类型,但是不必对形参命名。这三个元素被称为函数原型,函数原型描述了函数的接口。</p><h4 id="1-为什么需要原型"><a href="#1-为什么需要原型" class="headerlink" title="1.为什么需要原型"></a>1.为什么需要原型</h4><p>原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> volume = cube(side);</span><br></pre></td></tr></table></figure><p>首先，原型告诉编译器，cube()有一个double 参数。如果程序没有提供这样的参数，原型将让编译器能够捕获这种错误。其次，cube()函数完成计算后，将把返回值放置在指定的位置——可能是CPU寄存器，也可能是内存中。然后调用函数（这里为main()）将从这个位置取得返回值。由于原型指出了cube()的类型为double，因此编译器知道应检索多少个字节以及如何解释它们。如果没有这些信息，编译器将只能进行猜测，而编译器是不会这样做的。</p><p>编译器需要原型，因为这样将提高效率，让编译器在广大的文件里找有用的文件，是一件大海捞针的事儿，且编译器在搜索文件的时候将必须停止 对main()的编译。一个更严重的问题是，函数甚至可能并不在项目的文件中（C++允许将一个程序放在多个文件中，单独编译他们，然后再将它们组合起来），在这种情况下，可能导致编译器在编译main()时无权访问函数代码。如果函数位于库中，情况也将如此。</p><p>综上，避免使用函数原型的唯一办法就是，在首次使用函数之前定义它，但这并不总是可行的。</p><h4 id="2-原型的语法"><a href="#2-原型的语法" class="headerlink" title="2.原型的语法"></a>2.原型的语法</h4><p>函数原型是一条语句，因此必须以分号结束。获取原型的方法就是，复制函数定义中的函数头，并添加分号即可。</p><h4 id="3-原型的功能"><a href="#3-原型的功能" class="headerlink" title="3.原型的功能"></a>3.原型的功能</h4><p>可以极大地降低程序出错的几率。</p><p>原型应确保以下几点：</p><ul><li>编译器正确处理函数返回值</li><li>编译器检查使用的参数数目是否正确</li><li>编译器检查使用的参数类型是否正确。如果不正确，则转换为正确的类型（如果可能的话）。</li></ul><h4 id="讲一讲参数数目不对时将发生的情况"><a href="#讲一讲参数数目不对时将发生的情况" class="headerlink" title="讲一讲参数数目不对时将发生的情况"></a>讲一讲参数数目不对时将发生的情况</h4><p>例如，假设进行了如下调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> z = cube();</span><br></pre></td></tr></table></figure><p>如果没有函数原型，编译器将允许它通过。当函数被调用时，它将找到cube()调用存放值的位置，并使用这里的值。这个正式C语言从C++借鉴原型之前的工作方式。对于ANSI C（美国国家标准规定的C语言）来讲，原型是可选的，因此有些C语言程序正是这样工作的。但在C++中，原型是不可选。因此保证了不会发生这种错误。</p><p>接下来，我们假设提供了一个参数，但是它的类型不正确。在C语言中，这将造成奇怪的错误，例如，如果函数需要一个int值（假设占16位），而程序员传递了一个double值（假设占64位），则函数将只检查64位中的前16位，并试图将它们解释为一个int值。但是C++自动将传递的值转换为原型中指定的类型，条件是两者都是算数类型。</p><p>这个时候我来举个例子吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cheers</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cube</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    cheers(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Give me a number: "</span>;</span><br><span class="line">    <span class="keyword">double</span> side;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; side;</span><br><span class="line">    <span class="keyword">double</span> volume = cube(side);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span> &lt;&lt; side &lt;&lt; <span class="string">"-foot cube has a volume of "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; volume &lt;&lt; <span class="string">" cubic feet.\n"</span>;</span><br><span class="line">    cheers(cube(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cheers</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Cheers! "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cube</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是C++的代码</p><p>这个代码就能够应付下述语句中两次出现的类型不匹配的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cheers(cube(<span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>代码讲解：首先程序将int的值2传递给cube()，而后者期望的是double类型。编译器注意到，cube()原型指定了一个double类型参数，因此将2转化为2.0（一个double值）。接下来cube()返回一个double值(8.0)，这个值被用作cheer()的参数。编译器将再一次检查原型，并发现cheer()要求一个int参数，因此它将返回值转换为整数8.通常原型自动将被传递的参数强制转换为期望的类型</p><p>​    自动类型转换并不能避免所有可能的错误。例如，如果将8.33E27传递给期望一个int值的函数，则这样大的值将不能正确转换为int值。当较大的类型被自动转换为较小的类型时，有些编译器将发生警告，指出这可能丢失数据。</p><p>​    仅当有意义的时候，原型才会导致类型转换。正如原型不会将整数转换为结构或指针。</p><p>在编译阶段进行的原型化被称为静态类型检查(static type checking)。可以看出，静态类型检查可捕获许多在运行阶段非常难以捕获的错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C++自带一个包含函数的大型库（标准ANSI库加上多个C++类），但真正的编程乐趣在于编写自己的函数；另一方面，要提高编程效率，可以更深入地学习STL和BOOSTC++提供的功能。&lt;/p&gt;
&lt;h2 id=&quot;7-1-复习函数的基本知识&quot;&gt;&lt;a href=&quot;#7-1-复习函数的
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="C++" scheme="https://mr8god.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>URI URL统一资源标识符</title>
    <link href="https://mr8god.cn/2020/03/22/%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/URI%20URL%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E8%AF%86%E7%AC%A6/"/>
    <id>https://mr8god.cn/2020/03/22/%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/URI%20URL%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E8%AF%86%E7%AC%A6/</id>
    <published>2020-03-22T05:04:38.809Z</published>
    <updated>2020-03-29T14:25:41.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="URI（Uniform-Resource-Identifier"><a href="#URI（Uniform-Resource-Identifier" class="headerlink" title="URI（Uniform Resource Identifier)"></a>URI（Uniform Resource Identifier)</h2><p>采用一种特定语法标识一个资源的字符串</p><p><strong>格式：</strong></p><p>模式：模式特定部分（模式特定部分的语法取决于所用的模式）</p><p>模式包括：</p><p>由小写字母、数字和加号、点及连号符组成</p><p>data链接中直接包含的Base64编码数据</p><p>file本地磁盘的文件</p><p>ftp FTP服务器</p><p>HTTP使用超文本传输协议的国际互联网服务器</p><p>mailto电子邮件地址</p><p>magnet可以通过对等网络下载的资源</p><p>Telnet与基于Telnet的服务连接</p><p><strong>模式特定部分包扩：</strong></p><p><strong>//authority/path?query(//授权机构/路径？查询字符串)</strong></p><p>由ASCII字母数字符号组成，还可以使用标点符号-、_、·、!、~</p><p>定界符（/、？、&amp;、=）可以有其预定义用途</p><p>所有其他字符及内容中需用到的定界符也应用%转义（空格%20/%2F)</p><p><strong>authority</strong>:负责解析该URI其余部分的授权机构 授权机构是Internet主机，还可提供可选的用户名和端口 如：ftp://mp3:mp3@ci43198-a.ashvill.nc.home.com:33/VanHalen-Jump.mp3</p><p><strong>path</strong>:授权机构用来确定所标识资源的字符串</p><h2 id="URL最常见的URI"><a href="#URL最常见的URI" class="headerlink" title="URL最常见的URI"></a>URL最常见的URI</h2><p>两者区别：URI表示资源是什么，URL表示资源的具体位置，URI是URL的抽象。Java中URL对象对应网络获取的应用层协议的一个表示，而URI对象纯粹用于解析和处理字符串。</p><h3 id="绝对URL"><a href="#绝对URL" class="headerlink" title="绝对URL"></a>绝对URL</h3><p><strong>protocol://userInfo@host.port/path?query#fragment</strong></p><p>host 提供所需资源服务区的名字（主机/服务器ip地址）</p><p>userInfo 可选，服务器登录信息</p><p>port 可选，服务在其默认端口运行，无需此部分</p><p>path 指定服务器上的一个特定目录文件系统，路径相对于服务器的文档跟目录，向公众开放的服务器不会将其整个文件系统展示给客户端，而只是展示指定目录中的内容</p><p>query 向服务器提供附加参数，一般只在http URL中使用，其中包含表单数据，作为输入提供给服务端的运行程序</p><p>fragment 指向远程资源的某个特定部分 HTML 锚 XML XPointer  段  ref     片段标识符在HTML文档中用id属性创建 </p><p>包含片段标识符的是URL引用，不是URL</p><h3 id="相对URL继承了-父文档部分信息的URL"><a href="#相对URL继承了-父文档部分信息的URL" class="headerlink" title="相对URL继承了 父文档部分信息的URL"></a>相对URL继承了 父文档部分信息的URL</h3><p>在相对URL中，缺少的各部分都与所在文档的URL中对应的部分相同</p><p>例如浏览<a href="http://www.ibiblio.org/java/faq/javatutoial.html时" target="_blank" rel="noopener">http://www.ibiblio.org/java/faq/javatutoial.html时</a></p><p><strong>若无”/“开头</strong> 例如<a href="javafaq.html"></p><p>相当于<a href="http://www.ibiblio.org/java/faq/javafaq.html" target="_blank" rel="noopener">http://www.ibiblio.org/java/faq/javafaq.html</a></p><p><strong>若以”/“开头</strong> 如<a href="/projects/ipv61"></p><p>则相当于<a href="http://www.ibiblio.org/projects/ipv61" target="_blank" rel="noopener">http://www.ibiblio.org/projects/ipv61</a></p><p>相对URL允许用多种协议来提供一个文档树，且相对URL允许将整个文档树从一个网站移动或复制到另一个网站，而不会破坏所有的内部连接。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;URI（Uniform-Resource-Identifier&quot;&gt;&lt;a href=&quot;#URI（Uniform-Resource-Identifier&quot; class=&quot;headerlink&quot; title=&quot;URI（Uniform Resource Identifie
      
    
    </summary>
    
    
      <category term="网站开发" scheme="https://mr8god.cn/categories/%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端技术" scheme="https://mr8god.cn/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
