<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr8god&#39;s blog</title>
  
  <subtitle>coding,coding,always coding!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mr8god.cn/"/>
  <updated>2020-04-22T15:44:20.488Z</updated>
  <id>https://mr8god.cn/</id>
  
  <author>
    <name>Mr8god</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java日记——关于HashSet的源码剖析</title>
    <link href="https://mr8god.cn/2020/04/22/Java/Java%E6%97%A5%E8%AE%B0/Java%E6%97%A5%E8%AE%B0%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8EHashSet%E7%9A%84%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>https://mr8god.cn/2020/04/22/Java/Java%E6%97%A5%E8%AE%B0/Java%E6%97%A5%E8%AE%B0%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8EHashSet%E7%9A%84%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</id>
    <published>2020-04-22T14:32:52.000Z</published>
    <updated>2020-04-22T15:44:20.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java日记——关于HashSet的源码剖析"><a href="#Java日记——关于HashSet的源码剖析" class="headerlink" title="Java日记——关于HashSet的源码剖析"></a>Java日记——关于HashSet的源码剖析</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>这个我随手整到的一个知识点，确实很值得深挖，我在这其中得到的知识点也远大于其本身，这一点知识让我明白了任何小知识都得深挖源码，收获太大了。</p><p>首先感谢一下带给我思路的知乎答者：<a href="https://www.zhihu.com/question/28414001" target="_blank" rel="noopener">https://www.zhihu.com/question/28414001</a></p><p>下面正式开始我的表演</p><h2 id="首先（看结果）"><a href="#首先（看结果）" class="headerlink" title="首先（看结果）"></a>首先（看结果）</h2><p>以一段代码开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.kchaptereleven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 20:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetOfInteger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random rnd = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        Set&lt;Integer&gt; intset = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">            intset.add(rnd.nextInt(<span class="number">30</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(intset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一段平平无奇的，展示<strong>HashSet</strong>魅力的一段代码。代码的意思也很简单，就是让随机生成的0~29的数字存入我们的<strong>Set</strong>当中去。这里边随机了10000次，就意味着有很多很多重复的数字，当然我们大<strong>Set</strong>家族绝对不会包容两个一模一样的玩意儿，所以输出结果很是理想（单指这方面的理想），它就输出了这三十个数字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]</span><br></pre></td></tr></table></figure><p>但是呢，结果却好像有点违背了我们所讲的“<strong>无序</strong>”，这明明是有顺序的一个一个排着输出的呀，啷个嘞就给我说成“<strong>无序</strong>”了呢？顺便展示一下概念</p><blockquote><p>HashSet：一种没有重复元素的无序集合</p></blockquote><p>我先来回答这个问题：我们一般所说的<strong>HashSet</strong>是无序的，但是它既不能保证存储和取出顺序一致， 更不能保证自然顺序一致（按照a-z）</p><p>顺道一提，我《Thinking in Java》书本中的输出是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[15, 8, 23, 16, 7, 22, 9, 21, 6, 1 , 29 , 14, 24, 4, 19, 26, 11, 18, 3, 12, 27, 17, 2, 13, 28, 20, 25, 10, 5, 0]</span><br></pre></td></tr></table></figure><p>现在是不是就很奇妙了，为啥我同一段代码运行出来会是两个不同的结果，一个“<strong>有序</strong>”，一个“<strong>无序</strong>“。其实按照我江某人在C++中的经验来看，这很有可能就是语言版本的问题，这边很有可能就是<strong>JDK版本</strong>的问题，于是我们来分析源码验证我的思路</p><h2 id="然后（分析源码）"><a href="#然后（分析源码）" class="headerlink" title="然后（分析源码）"></a>然后（分析源码）</h2><p>我们首先从程序的第一步——集合元素的存储开始看起，先看<strong>HashSet</strong> 的 <strong>add</strong>方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashSet 源码节选-JKD8</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，<strong>HashSet</strong>直接调用的是<strong>HashMap</strong>的<strong>put</strong>方法，并且将元素<strong>e</strong>放到<strong>map</strong>的<strong>key</strong>位置（保证了唯一性）</p><p>顺着线索继续查看我们的<strong>HashMap</strong>的<strong>put</strong>方法源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap 源码节选-JDK8</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而我们的值在返回前需要经过<strong>HashMap</strong>中的<strong>hash</strong>方法</p><p>接着定位到<strong>hash</strong>方法的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>hash</strong>方法的返回结果中是一句三目运算符，键（<strong>key</strong>）为<strong>null</strong>即返回0，存在则返回后一句的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)</span><br></pre></td></tr></table></figure><p>重点来了，这个东西叫做“<strong>扰动函数</strong>”</p><h3 id="这个时候断一下我们再来分析一下"><a href="#这个时候断一下我们再来分析一下" class="headerlink" title="这个时候断一下我们再来分析一下"></a>这个时候断一下我们再来分析一下</h3><p><strong>hashCode</strong>是<strong>Object</strong>类中的一个方法，在子类中一般会被重写，而根据我们之前自己给出的程序，暂以<strong>Integer</strong>类型为例，我们来看一下<strong>Integer</strong>中<strong>hashCode</strong>方法的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a hash code for this &#123;<span class="doctag">@code</span> Integer&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  a hash code value for this object, equal to the</span></span><br><span class="line"><span class="comment"> *          primitive &#123;<span class="doctag">@code</span> int&#125; value represented by this</span></span><br><span class="line"><span class="comment"> *          &#123;<span class="doctag">@code</span> Integer&#125; object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.hashCode(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a hash code for a &#123;<span class="doctag">@code</span> int&#125; value; compatible with</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Integer.hashCode()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to hash</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a hash code value for a &#123;<span class="doctag">@code</span> int&#125; value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果然，不出所料，这边真的重写<strong>hashCode</strong>了，<strong>Integer</strong>中<strong>hasCode</strong>方法的返回值就是这个数本身</p><p>注释：其实整数的值因为与整数本身一样唯一，所以它也是一个足够好的散列值呢</p><p>这上面得出的结论就是，下面的<strong>A式</strong>和<strong>B式</strong>是等价的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A：(h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)</span><br><span class="line">B：key ^ (h &gt;&gt;&gt; <span class="number">16</span>)</span><br></pre></td></tr></table></figure><p>over，继续回归正途，接下来就是直接进行位运算层面了</p><h2 id="接着（转攻计算散列值——位运算开始了）"><a href="#接着（转攻计算散列值——位运算开始了）" class="headerlink" title="接着（转攻计算散列值——位运算开始了）"></a>接着（转攻计算散列值——位运算开始了）</h2><p>首先不急，先理清思路，这个时候</p><p><strong>HashSet</strong>因为底层使用了<strong>哈希表（链表结合数组）</strong>实现，存储<strong>key</strong>时可以通过一系列运算后得出自己在数组中所处的位置。</p><p>我们在<strong>hashCode</strong>方法中返回到了一个等同于本身值的散列值（证明过程如“然后（分析源码）”中的“这个时候断一下我们再来分析一下”可见）。</p><p>但是呢，考虑到<strong>int</strong>类型数据的范围：-2147483648~2147483647，很明显，这些散列值不能够直接使用，因为内存是没有办法放得下一个40亿长度的数组的。所以它使用了对数组长度进行<strong>取模运算</strong>的解决方法，得余后再作为其数组下标。</p><p>在<strong>JDK7</strong>中，这个被称为<strong>indexFor()</strong>的方法就是用来做这个的。<br>在<strong>JDK8</strong>中，就是一句代码，其实和<strong>JDK7</strong>的一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK8中</span></span><br><span class="line">(tab.length - <span class="number">1</span>) &amp; hash；</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK7中 </span></span><br><span class="line">bucketIndex = indexFor(hash, table.length);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> h &amp; (length - <span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>顺道加一句</strong>，为什么我们取模运算不用<strong>%</strong>而用<strong>&amp;</strong>呢？因为位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度会非常快，这样就导致了位运算<strong>&amp;</strong>效率要比取模运算<strong>%</strong>高很多。</p><p>看到这边我们就知道了，存储时<strong>key</strong>的下标位置是需要通过<strong>hash</strong>方法和<strong>indexFor()</strong>或<strong>JDK8的类indexFor()</strong>运算得来的。</p><h3 id="正式开始我们的位运算（-amp-）"><a href="#正式开始我们的位运算（-amp-）" class="headerlink" title="正式开始我们的位运算（&amp;）"></a>正式开始我们的位运算（&amp;）</h3><p>我们开始举个例子了</p><p>HashMap中初始长度为16，length - 1 = 15；其二进制表示为 00000000 00000000 00000000 00001111</p><p>而与运算计算方式为：遇0则0，我们随便举一个<strong>key</strong>值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1111 1111 1010 0101 1111 0000 0011 1100 </span><br><span class="line">&amp; 0000 0000 0000 0000 0000 0000 0000 1111 </span><br><span class="line">---------------------------------------------------- </span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 1100</span><br></pre></td></tr></table></figure><p>上面随便举的<strong>key</strong>值就是：1111 1111 1010 0101 1111 0000 0011 1100 </p><p>我们将这32位从中分开，左边16位称作高位，右边16位称作低位，可以看到经过&amp;运算后 结果就是高位全部归0，剩下了低位的最后四位。但是问题就来了，我们按照当前初始长度为默认的16，HashCode值为下图两个，可以看到，在不经过扰动计算时，只进行与(&amp;)运算后 Index值均为 12 这也就导致了哈希冲突</p><p><img src="https://i.loli.net/2020/04/22/HAvmCw7KOF6t3B1.jpg" alt="需要的.jpg"></p><blockquote><p>哈希冲突的简单理解：计划把一个对象插入到散列表（哈希表）中，但是发现这个位置已经被别人的对象给占据了</p></blockquote><p>例子中，两个不同的HashCode值却经过运算后，得到了相同的值，也就代表，他们都需要被放在下标为2的位置</p><p>一般来说，如果数据分布比较广泛，而且存储数据的数组长度比较大，那么哈希冲突就会比较少，否则很高。</p><p>但是，如果像上例中只取最后几位的时候，这可不是什么好事，即使我的数据分布很散乱，但是哈希冲突仍然会很严重。</p><p>别忘了，我们的扰动函数还在前面搁着呢，这个时候它就要发挥强大的作用了,还是使用上面两个发生了哈希冲突的数据，这一次我们加入扰动函数再进行与(&amp;)运算</p><p><img src="https://i.loli.net/2020/04/22/CPfnloXFEBtIJgA.jpg" alt="对哈希冲突的解决2.jpg"></p><blockquote><p>补充 ：&gt;&gt;&gt; 按位右移补零操作符，左操作数的值按右操作数指定的为主右移，移动得到的空位以零填充<br>^     位异或运算，相同则0，不同则1</p></blockquote><p>可以看到，本发生了哈希冲突的两组数据，经过扰动函数处理后，数值变得不再一样了，也就避免了冲突</p><p>其实在<strong>扰动函数</strong>中，将<strong>数据右位移16位</strong>，哈希码的<strong>高位和低位混合</strong>了起来，这也正解决了前面所讲 高位归0，计算只依赖低位最后几位的情况,  这使得高位的一些特征也<strong>对低位产生了影响</strong>，使得<strong>低位的随机性加强</strong>，能更好的<strong>避免冲突</strong></p><h2 id="再然后"><a href="#再然后" class="headerlink" title="再然后"></a>再然后</h2><p>到了这里，我们一步步研究到了这一些知识</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HashSet <span class="title">add</span><span class="params">()</span> → HashMap <span class="title">put</span><span class="params">()</span> → HashMap <span class="title">hash</span><span class="params">()</span> → <span class="title">HashMap</span> <span class="params">(tab.length - <span class="number">1</span>)</span> &amp; hash；</span></span><br></pre></td></tr></table></figure><p>有了这些知识的铺垫，我对于刚开始自己举的例子又产生了一些疑惑,我使用<strong>for循环</strong>添加一些整型元素进入集合，难道就没有任何一个发生哈希冲突吗，为什么遍历结果是有序输出的，经过简单计算 2 和18这两个值就都是2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;key &#x3D; 2,(length -1) &#x3D; 15 </span><br><span class="line"></span><br><span class="line">h &#x3D; key.hashCode() 0000 0000 0000 0000 0000 0000 0000 0010 </span><br><span class="line">h &gt;&gt;&gt; 16 0000 0000 0000 0000 0000 0000 0000 0000 </span><br><span class="line">hash &#x3D; h^(h &gt;&gt;&gt; 16) 0000 0000 0000 0000 0000 0000 0000 0010 </span><br><span class="line">(tab.length-1)&amp;hash 0000 0000 0000 0000 0000 0000 0000 1111 </span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0010 </span><br><span class="line">------------------------------------------------------------- </span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0010</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2的十进制结果：2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;key &#x3D; 18,(length -1) &#x3D; 15</span><br><span class="line"></span><br><span class="line">h &#x3D; key.hashCode() 0000 0000 0000 0000 0000 0000 0001 0010 </span><br><span class="line">h &gt;&gt;&gt; 16 0000 0000 0000 0000 0000 0000 0000 0000 </span><br><span class="line">hash &#x3D; h^(h &gt;&gt;&gt; 16) 0000 0000 0000 0000 0000 0000 0001 0010 </span><br><span class="line">(tab.length-1)&amp;hash 0000 0000 0000 0000 0000 0000 0000 1111 </span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0010 </span><br><span class="line">------------------------------------------------------------- </span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0010 </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;18的十进制结果：2</span><br></pre></td></tr></table></figure><p>按照我们上面的知识，按理应该输出 1 2 18 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 但却仍有序输出了</p><p>这就非常苦恼了，不过我发现了一个有趣的现象，当我的代码如下时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.kchaptereleven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 20:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetOfInteger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random rnd = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        Set&lt;Integer&gt; intset = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            intset.add(rnd.nextInt(<span class="number">30</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(intset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[5, 8, 13]</span><br></pre></td></tr></table></figure><p>于是我将问题的核心转为了<strong>数组长度问题</strong>，这个就是最终的大Boss了</p><h2 id="最后（大Boss——数组长度）"><a href="#最后（大Boss——数组长度）" class="headerlink" title="最后（大Boss——数组长度）"></a>最后（大Boss——数组长度）</h2><p>继续找到<strong>HashMap</strong>源码，我发现了一个有趣的东西</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><blockquote><p>&lt;&lt; ：按位左移运算符，做操作数按位左移右错作数指定的位数，即左边最高位丢弃，右边补齐0，计算的简便方法就是：把 &lt;&lt; 左面的数据乘以2的移动次幂<br>为什么初始长度为16：1 &lt;&lt; 4 即 1 * 2 ^4 =16; </p></blockquote><p>这里边有一个叫做<strong>加载因子</strong>的东西，他默认值为0.75f，这是什么意思呢，我们来补充一点它的知识：</p><blockquote><p>加载因子就是表示哈希表中元素填满的程度，当表中元素过多，超过加载因子的值时，哈希表会自动扩容，一般是一倍，这种行为可以称作rehashing(再哈希)。<br>加载因子的值设置的越大，添加的元素就会越多，确实空间利用率的到了很大的提升，但是毫无疑问，就面临着哈希冲突的可能性增大，反之，空间利用率造成了浪费，但哈希冲突也减少了，所以我们希望在空间利用率与哈希冲突之间找到一种我们所能接受的平衡，经过一些试验，定在了0.75f</p></blockquote><p>现在可以解决我们上面的疑惑了</p><p>数组初始的实际长度 = 16 * 0.75 = 12</p><p>这代表当我们元素数量增加到12以上时就会发生扩容，当我们上例中for循环添加0-18， 这19个元素时，先保存到前12个到第十三个元素时，超过加载因子，导致数组发生了一次扩容，而扩容以后对应与(&amp;)运算的(tab.length-1)就发生了变化,从16-1 变成了 32-1 即31</p><p>我们来算一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;key &#x3D; 2,(length -1) &#x3D; 31 </span><br><span class="line">h &#x3D; key.hashCode() 0000 0000 0000 0000 0000 0000 0001 0010 </span><br><span class="line">h &gt;&gt;&gt; 16 0000 0000 0000 0000 0000 0000 0000 0000 </span><br><span class="line">hash &#x3D; h^(h &gt;&gt;&gt; 16) 0000 0000 0000 0000 0000 0000 0001 0010 </span><br><span class="line">(tab.length-1)&amp;hash 0000 0000 0000 0000 0000 0000 0011 1111 </span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0010 </span><br><span class="line">------------------------------------------------------------- </span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0010 </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;十进制结果：2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;key &#x3D; 18,(length -1) &#x3D; 31 </span><br><span class="line">h &#x3D; key.hashCode() 0000 0000 0000 0000 0000 0000 0001 0010 </span><br><span class="line">h &gt;&gt;&gt; 16 0000 0000 0000 0000 0000 0000 0000 0000 </span><br><span class="line">hash &#x3D; h^(h &gt;&gt;&gt; 16) 0000 0000 0000 0000 0000 0000 0001 0010 </span><br><span class="line">(tab.length-1)&amp;hash 0000 0000 0000 0000 0000 0000 0011 1111 </span><br><span class="line">0000 0000 0000 0000 0000 0000 0000 0010 </span><br><span class="line">------------------------------------------------------------- </span><br><span class="line">0000 0000 0000 0000 0000 0000 0001 0010 </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;十进制结果：18</span><br></pre></td></tr></table></figure><p>当length -  1 的值发生改变的时候，18的值也变成了本身。</p><p>到这里，才意识到自己之前用2和18计算时 均使用了 length -1 的值为 15是错误的，当时并不清楚<strong>加载因子及它的扩容机制</strong>，这才是导致提出有问题疑惑的根本原因。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>JDK7</strong>到<strong>JDK8</strong>，其内部发生了一些变化，导致在不同版本<strong>JDK</strong>下运行结果不同，根据上面的分析，我们从<strong>HashSet</strong>追溯到<strong>HashMap</strong>的<strong>hash</strong>算法、加载因子和默认长度。</p><p>由于我们所创建的<strong>HashSet</strong>是<strong>Integer</strong>类型的，这也是最巧的一点，<strong>Integer</strong>类型<strong>hashCode()</strong>的返回值就是其<strong>int</strong>值本身，而存储的时候元素通过一些运算后会得出自己在数组中所处的位置。由于在这一步，其本身即下标(只考虑这一步)，其实已经实现了排序功能，由于<strong>int</strong>类型范围太广，内存放不下，所以对其进行取模运算，为了减少哈希冲突，又在取模前进行了，扰动函数的计算，得到的数作为元素下标，按照<strong>JDK8</strong>下的<strong>hash</strong>算法，以及<strong>load factor</strong>及扩容机制，这就导致数据在经过 <strong>HashMap.hash()</strong>运算后仍然是自己本身的值，且没有发生哈希冲突。</p><p><strong>补充</strong>：对于有序无序的理解</p><p>集合所说的序，是指元素存入集合的顺序，当元素存储顺序和取出顺序一致时就是有序，否则就是无序。 </p><p>并不是说存储数据的时候无序，没有规则，当我们不论使用<strong>for循环</strong>随机数添加元素的时候，还是<strong>for循环</strong>有序添加元素的时候，最后遍历输出的结果均为按照值的大小排序输出，随机添加元素，但结果仍有序输出，这就对照着上面那句，存储顺序和取出顺序是不一致的，所以我们说<strong>HashSet</strong>是无序的，虽然我们按照123的顺序添加元素，结果虽然仍为123，但这只是一种巧合而已。</p><p>所以<strong>HashSet</strong>只是<strong>不保证有序</strong>，并<strong>不是保证无序</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java日记——关于HashSet的源码剖析&quot;&gt;&lt;a href=&quot;#Java日记——关于HashSet的源码剖析&quot; class=&quot;headerlink&quot; title=&quot;Java日记——关于HashSet的源码剖析&quot;&gt;&lt;/a&gt;Java日记——关于HashSet的源码
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java日记" scheme="https://mr8god.cn/tags/Java%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java日记——持有对象（就是容器啦）</title>
    <link href="https://mr8god.cn/2020/04/20/Java/Java%E6%97%A5%E8%AE%B0/Java%E6%97%A5%E8%AE%B0%E2%80%94%E2%80%94%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%B0%B1%E6%98%AF%E5%AE%B9%E5%99%A8%E5%95%A6%EF%BC%89/"/>
    <id>https://mr8god.cn/2020/04/20/Java/Java%E6%97%A5%E8%AE%B0/Java%E6%97%A5%E8%AE%B0%E2%80%94%E2%80%94%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%B0%B1%E6%98%AF%E5%AE%B9%E5%99%A8%E5%95%A6%EF%BC%89/</id>
    <published>2020-04-20T13:18:39.000Z</published>
    <updated>2020-04-22T00:48:38.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java日记——持有对象（就是容器啦）"><a href="#Java日记——持有对象（就是容器啦）" class="headerlink" title="Java日记——持有对象（就是容器啦）"></a>Java日记——持有对象（就是容器啦）</h1><p>攒了两天，都在好好看容器类，Java的容器类还只是看了个大概哈，今天给大家带来我初学的Java容器中的<strong>迭代器</strong></p><h2 id="迭代器简介"><a href="#迭代器简介" class="headerlink" title="迭代器简介"></a>迭代器简介</h2><p>迭代器也是一种设计模式，广泛用于情景比如：不需要重写代码就可以应用于不同类型的容器，可能大家不太理解哈，我换句话简单来讲：比如我们原本使用<strong>List</strong>进行编码的，但是后来发现如果能够把相同的代码应用于<strong>Set</strong>，将会显得非常方便，此时我们应该怎么做呢？从头开始编写通用的代码？<strong>nonono</strong>，其实他们只是使用<strong>容器</strong>而已，并不会在乎容器的类型，那么如何才能不重写代码就可以应用于不同类型的容器呢？</p><p>在<strong>Java</strong>中迭代器就是<strong>Iterator</strong>这个东西。迭代器其实也是一个对象，它的工作就是遍历并选择序列中的对象，而客户端程序员不必知道或关心序列底层的结构，就可以使用序列了。</p><p>此外，迭代器通常被称为<strong>轻量级对象</strong>：创建它的代价小。因此，经常可见到对迭代器有些奇怪的限制，例如<strong>Java</strong>中的<strong>Iterator</strong>只能单向移动，这个<strong>Iterator</strong>只能用来：</p><ol><li>使用方法<strong>iterator()</strong>要求容器返回一个<strong>Iterator</strong>。<strong>Iterator</strong>将准备好返回序列的第一个元素。</li><li>使用<strong>next()</strong>获得序列中的下一个元素。</li><li>使用<strong>hasNext()</strong>检查序列中是否还有元素。</li><li>使用<strong>remove()</strong>将迭代器新近返回的元素删除。</li></ol><p>接下来会有代码展示</p><h3 id="代码展示（Iterator）"><a href="#代码展示（Iterator）" class="headerlink" title="代码展示（Iterator）"></a>代码展示（Iterator）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.kchaptereleven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.Pet;</span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.Pets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 9:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleIteration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Pet&gt; pets = Pets.arrayList(<span class="number">12</span>);</span><br><span class="line">        System.out.println(pets);</span><br><span class="line">        Iterator&lt;Pet&gt; it = pets.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            Pet p = it.next();</span><br><span class="line">            System.out.print(p.id() + <span class="string">":"</span> + p + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span> (Pet p :</span><br><span class="line">                pets) &#123;</span><br><span class="line">            System.out.print(p.id() + <span class="string">":"</span> + p + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        it = pets.iterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">            it.next();</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(pets);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很简单，就一个点是之前没有遇到过的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Pet&gt; it = pets.iterator();</span><br></pre></td></tr></table></figure><p>这个就是使用<strong>Iterator</strong>来遍历了<strong>pets</strong>了，</p><p>之后我们就可以使用<strong>hasNext()</strong>或<strong>next()</strong>了</p><p>如果你只是向前遍历<strong>List</strong>， 并不打算修改<strong>List</strong>对象本身，那么你可以看到<strong>foreach</strong>语法会显得更加的简洁。</p><p><strong>Iterator</strong>还可以移除由<strong>next()</strong>产生的最后一个元素，这意味着在调用<strong>remove()</strong>之前必须先调用<strong>next()</strong>。同理，我之后的<strong>previous</strong>也是这么个理</p><p>接收对象容器并传递它，从而在每个对象上都执行操作，这种思想就是<strong>Iterator</strong>了，当然我感觉这正是<strong>Java</strong>的精髓。</p><h3 id="代码展示二（不必知晓容器的确切类型）"><a href="#代码展示二（不必知晓容器的确切类型）" class="headerlink" title="代码展示二（不必知晓容器的确切类型）"></a>代码展示二（不必知晓容器的确切类型）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.kchaptereleven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.Pet;</span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.Pets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 10:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrossContainterIteration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Iterator&lt;Pet&gt; it)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            Pet p = it.next();</span><br><span class="line">            System.out.print(p.id() + <span class="string">":"</span> + p + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Pet&gt; pets = Pets.arrayList(<span class="number">8</span>);</span><br><span class="line">        LinkedList&lt;Pet&gt; petsLL = <span class="keyword">new</span> LinkedList&lt;Pet&gt;(pets);</span><br><span class="line">        HashSet&lt;Pet&gt; petsHs = <span class="keyword">new</span> HashSet&lt;Pet&gt;(pets);</span><br><span class="line">        TreeSet&lt;Pet&gt; petsTs = <span class="keyword">new</span> TreeSet&lt;Pet&gt;(pets);</span><br><span class="line">        display(pets.iterator());</span><br><span class="line">        display(petsLL.iterator());</span><br><span class="line">        display(petsHs.iterator());</span><br><span class="line">        display(petsTs.iterator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里边的<strong>display()</strong>方法不包含任何有关它所遍历的序列的类型信息，</p><p>这正展示了<strong>Iterator</strong> 的真正威力：能够将遍历序列的操作与序列底层的结构分离。</p><p>正由于此，我们有时会说：迭代器统一了对容器的访问方式。</p><h2 id="异军突起——ListIterator"><a href="#异军突起——ListIterator" class="headerlink" title="异军突起——ListIterator"></a>异军突起——ListIterator</h2><p><strong>ListIterator</strong>是一个更加强大的<strong>Iterator</strong> 的子类型，它只能用于各种<strong>List</strong>类的访问。尽管<strong>Iterator</strong>只能向前移动，但是<strong>ListIterator</strong>可以双向移动。</p><p><strong>ListIterator</strong>还可以产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引，并且可以使用<strong>set()</strong>方法替换它访问过的最后一个元素。</p><p>你可以通过调用<strong>listIterator(n)</strong>方法产生一个指向<strong>List</strong>开始处的<strong>ListIterator</strong>， 并且还可以通过调用<strong>listIterator(n)</strong>方法创建一个一开始就指向列表索引为<strong>n</strong>的元素处的<strong>ListIterator</strong>。</p><h3 id="代码展示（ListIterator）"><a href="#代码展示（ListIterator）" class="headerlink" title="代码展示（ListIterator）"></a>代码展示（ListIterator）</h3><p>下面举代码展示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.kchaptereleven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.Pet;</span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.Pets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 20:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIteration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Pet&gt; pets = Pets.arrayList(<span class="number">8</span>);</span><br><span class="line">        ListIterator&lt;Pet&gt; it = pets.listIterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            System.out.print(it.next() + <span class="string">", "</span> + it.nextIndex() + <span class="string">", "</span> + it.previousIndex() + <span class="string">"; "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">while</span> (it.hasPrevious())&#123;</span><br><span class="line">            System.out.print(it.previous().id() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(pets);</span><br><span class="line">        it = pets.listIterator(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            it.next();</span><br><span class="line">            it.set(Pets.randomPet());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(pets );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码展示（自个写的倒序）"><a href="#代码展示（自个写的倒序）" class="headerlink" title="代码展示（自个写的倒序）"></a>代码展示（自个写的倒序）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.kchaptereleven.self;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 21:51</span></span><br><span class="line"><span class="comment"> * 这个代码是《Java编程思想》第十一章持有对象的练习12（3）：</span></span><br><span class="line"><span class="comment"> * 创建并组装一个List,然后再创建第二个具有相同尺寸的List，</span></span><br><span class="line"><span class="comment"> * 将第一个List列表反序插入第二个列表中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这里边我的思路是首先用hasNext将LsIterator的指针滑到了容器的最后的位置</span></span><br><span class="line"><span class="comment"> * 然后我再使用previous，一步步，慢慢的往前滑，顺便赋值给int2</span></span><br><span class="line"><span class="comment"> * 其实我大可不必这么复杂，还调用previous，直接for倒序赋值就完事了</span></span><br><span class="line"><span class="comment"> * 但是这么一来我对previous的理解深入了，确实，这段代码中如果没有hasNext的话</span></span><br><span class="line"><span class="comment"> * previous是无法运行的，会报错，会爆越界，确实，我指针指在了第一个，</span></span><br><span class="line"><span class="comment"> * 我还要赋值，拿什么给他赋值呀，over，收获良多</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExerciseTwelve</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; int1 = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        List&lt;Integer&gt; int2 = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            int1.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(int1);</span></span><br><span class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        ListIterator&lt;Integer&gt; lulala = int1.listIterator();</span><br><span class="line">        <span class="keyword">while</span> (lulala.hasNext()) &#123;</span><br><span class="line">            System.out.print(lulala.next() + <span class="string">"("</span> + counter++ + <span class="string">") , "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            int2.add(lulala.previous());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(int2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网上的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.kchaptereleven.self;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 22:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExerciseTwelveTwolist</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(length);</span><br><span class="line">    List&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(length);</span><br><span class="line">    ListIterator&lt;Integer&gt; li;</span><br><span class="line">    <span class="comment">// 构造函数，给list1赋值，并且将li指向list1的最末尾的一个元素</span></span><br><span class="line">     ExerciseTwelveTwolist(<span class="keyword">int</span> length)&#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++)&#123;</span><br><span class="line">            list1.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        li = list1.listIterator(length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对list2进行初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">list2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (li.hasPrevious())&#123;</span><br><span class="line">            <span class="comment">// 当ListIterator li前面具有元素时，将当前的元素</span></span><br><span class="line">            <span class="comment">// 赋值给list2，并且向前移动（即li.previous的功能）</span></span><br><span class="line">            list2.add(li.previous());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">out1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">out2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(list2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            ExerciseTwelveTwolist ett = <span class="keyword">new</span> ExerciseTwelveTwolist(<span class="number">10</span>);</span><br><span class="line">            ett.list2();</span><br><span class="line">            ett.out1();</span><br><span class="line">            ett.out2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再附上作者的一些感悟，over</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">网上查询到其他解决办法，其中通过while(li.hasnext())&#123;li1.next（）;&#125;将li指向list1的末尾，并且对于list2列表的操作也使用了ListIterator（对于后者，我觉得没有必要，此题中对list2本身就应该是一个空的list，对于它的操作仅仅是通过add()方法就可以了，没必要再创建一个listIterator）。感想：最初想通过直接对list进行操作，发现并不可行，list列表只有add（），get（）等方法，事实上是很难做到对其进行类似指针移动的操作，所以日后对于每一个需要操作的list数组进行一些操作，可能都需要用到ListIterator，或者简单的Iterator。在这里也不难理解为什么在这道题中的其它解决方法里，有人会对list2也使用一个listIterator,毕竟对list2也要进行一些操作（尽管这里只需要添加元素就好了）。在编写代码的时候，我总是会想直接把ListIterator直接赋值给List列表，类似于list1&#x3D;li。事实上，这样是行不通的，List列表和迭代器ListIterator之间的关系不存在继承，仅仅是迭代器ListIterator 对Collection进行操作而已。实现赋值则是使用List的add（）方法，调用迭代器Iterator的next（）方法，传入list。（本题中使用的是list2.add(li.previous());）此外，listIterator比iterator更为强大，它可以实现双向移动，也可以直接指向某个具体的元素，而iterator则只能单向移动。最后：思考良久，决定还是不将我的博客设置为私密好了，有人能看必定是好事，发现其中错误更是可喜可贺，本人也是大三学生一枚，想记录一些自己学习过程中的问题，解决方法等，同时也想着，或许能被大神看到？对我一些遗漏之类的进行补充？那自然也能学习到不少</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「qq_41791653」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_41791653&#x2F;article&#x2F;details&#x2F;80004740</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java日记——持有对象（就是容器啦）&quot;&gt;&lt;a href=&quot;#Java日记——持有对象（就是容器啦）&quot; class=&quot;headerlink&quot; title=&quot;Java日记——持有对象（就是容器啦）&quot;&gt;&lt;/a&gt;Java日记——持有对象（就是容器啦）&lt;/h1&gt;&lt;p&gt;攒了
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java日记" scheme="https://mr8god.cn/tags/Java%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java日记——接口</title>
    <link href="https://mr8god.cn/2020/04/18/Java/Java%E6%97%A5%E8%AE%B0/Java%E6%97%A5%E8%AE%B0%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3/"/>
    <id>https://mr8god.cn/2020/04/18/Java/Java%E6%97%A5%E8%AE%B0/Java%E6%97%A5%E8%AE%B0%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-04-17T16:29:18.000Z</published>
    <updated>2020-04-17T16:56:39.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="9-3-完全解耦"><a href="#9-3-完全解耦" class="headerlink" title="9.3 完全解耦"></a>9.3 完全解耦</h2><p>假设我们有一组电子滤波器，它们适用于<strong>Apply.process()</strong>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply.process()方法</span></span><br><span class="line"><span class="keyword">package</span> cn.mr8god.chapternine.interfaceprocessor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apply</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Processor p, Object s)</span> </span>&#123;</span><br><span class="line">        print(<span class="string">"Using Processor "</span> + p.name() );</span><br><span class="line">        print(p.process(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="电子滤波器代码包在下边"><a href="#电子滤波器代码包在下边" class="headerlink" title="电子滤波器代码包在下边"></a>电子滤波器代码包在下边</h3><h4 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Waveform</span></span><br><span class="line"><span class="keyword">package</span> cn.mr8god.chapternine.filters;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 23:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Waveform</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Waveform&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Filter</span></span><br><span class="line"><span class="keyword">package</span> cn.mr8god.chapternine.filters;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 23:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span><span class="params">(Waveform input)</span></span>&#123; <span class="keyword">return</span> input; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LowPass</span></span><br><span class="line"><span class="keyword">package</span> cn.mr8god.chapternine.filters;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 23:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LowPass</span> <span class="keyword">extends</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> cutoff;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LowPass</span><span class="params">(<span class="keyword">double</span> cutoff)</span></span>&#123; <span class="keyword">this</span>.cutoff = cutoff; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span><span class="params">(Waveform input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HighPass</span></span><br><span class="line"><span class="keyword">package</span> cn.mr8god.chapternine.filters;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 23:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighPass</span> <span class="keyword">extends</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> cutoff;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HighPass</span><span class="params">(<span class="keyword">double</span> cutoff)</span></span>&#123; <span class="keyword">this</span>.cutoff = cutoff; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span> <span class="params">(Waveform input)</span></span>&#123; <span class="keyword">return</span> input; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BandPass</span></span><br><span class="line"><span class="keyword">package</span> cn.mr8god.chapternine.filters;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 23:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BandPass</span> <span class="keyword">extends</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> lowCutoff, highCutoff;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BandPass</span><span class="params">(<span class="keyword">double</span> lowCut, <span class="keyword">double</span> highCut)</span></span>&#123;</span><br><span class="line">        lowCutoff = lowCut;</span><br><span class="line">        highCutoff = highCut;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span><span class="params">(Waveform input)</span> </span>&#123; <span class="keyword">return</span> input; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然<strong>Filter</strong>和<strong>Processor</strong>（代码我贴在这段话下面）具有相同的接口元素（且它们俩输出都是<strong>Waveform</strong>），但是因为<strong>Filter</strong>并非继承自<strong>Processor</strong>因此咱不能将<strong>Filter</strong>用于<strong>Apply.process()</strong>方法，即便这样做可以正常运行。</p><p>出现这个问题就是因为<strong>Apply.process()</strong>方法和<strong>Processor</strong>之间的耦合度太高了，已经超出所需要的程度了，这就使得应该复用<strong>Apply.process()</strong>的代码的时候，复用却被禁止了。</p><h4 id="第二段改良版本"><a href="#第二段改良版本" class="headerlink" title="第二段改良版本"></a>第二段改良版本</h4><p><u>但是如果<strong>Processor</strong>是一个接口，那么这些限制就谈不上限制了，使得你可以复用<strong>Apply.process()</strong>的代码了。</u></p><p>上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这就是被写成接口的Processor</span></span><br><span class="line"><span class="keyword">package</span> cn.mr8god.chapternine.interfaceprocessor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 23:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">process</span><span class="params">(Object input)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply</span></span><br><span class="line"><span class="keyword">package</span> cn.mr8god.chapternine.interfaceprocessor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apply</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Processor p, Object s)</span> </span>&#123;</span><br><span class="line">        print(<span class="string">"Using Processor "</span> + p.name() );</span><br><span class="line">        print(p.process(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复用代码的<strong>第一种方式</strong>是客户端程序员遵循制定好的接口来编写自己的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.chapternine.interfaceprocessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 23:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StringProcessor</span> <span class="keyword">implements</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">process</span><span class="params">(Object input)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String s = <span class="string">"If she weighs the same as a duck, she's made of wood"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apply.process(<span class="keyword">new</span> Upcase(), s);</span><br><span class="line">        Apply.process(<span class="keyword">new</span> Downcase(), s);</span><br><span class="line">        Apply.process(<span class="keyword">new</span> Splitter(), s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Upcase</span> <span class="keyword">extends</span> <span class="title">StringProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((String) input).toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Downcase</span> <span class="keyword">extends</span> <span class="title">StringProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((String) input).toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Splitter</span> <span class="keyword">extends</span> <span class="title">StringProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(((String)input).split(<span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第三段改良版本"><a href="#第三段改良版本" class="headerlink" title="第三段改良版本"></a>第三段改良版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// processor的接口</span></span><br><span class="line"><span class="keyword">package</span> cn.mr8god.chapternine.interfaceprocessor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 23:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">process</span><span class="params">(Object input)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply的类</span></span><br><span class="line"><span class="keyword">package</span> cn.mr8god.chapternine.interfaceprocessor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apply</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Processor p, Object s)</span> </span>&#123;</span><br><span class="line">        print(<span class="string">"Using Processor "</span> + p.name() );</span><br><span class="line">        print(p.process(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.chapternine.interfaceprocessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.mr8god.chapternine.filters.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterAdapter</span> <span class="keyword">implements</span> <span class="title">Processor</span> </span>&#123;</span><br><span class="line">    Filter filter;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FilterAdapter</span><span class="params">(Filter filter)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filter = filter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> filter.name();&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Waveform <span class="title">process</span><span class="params">(Object input)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> filter.process((Waveform)input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 23:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterProcessor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Waveform w = <span class="keyword">new</span> Waveform();</span><br><span class="line">        Apply.process(<span class="keyword">new</span> FilterAdapter(<span class="keyword">new</span> LowPass(<span class="number">1.0</span>)), w);</span><br><span class="line">        Apply.process(<span class="keyword">new</span> FilterAdapter(<span class="keyword">new</span> HighPass(<span class="number">2.0</span>)), w);</span><br><span class="line">        Apply.process(<span class="keyword">new</span> FilterAdapter(<span class="keyword">new</span> BandPass(<span class="number">3.0</span>, <span class="number">4.0</span>)), w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说一下这一次改良的目的为何，在电子滤波器这个例子中，类库是被发现而非被创建的。在这些情况下，可以使用<strong>适配器设计模式</strong>。适配器中的代码将接受你所拥有的接口，并产生你所需要的接口。相当于做了一个二道贩子。</p><p>此外这种方法，<strong>FilterAdapter</strong>的构造器接受你所拥有的接口<strong>Filter</strong>，然后生成具有你所需要的<strong>Processor</strong>接口的对象。</p><p>哦对了，这里边的<strong>FilterAdapter</strong>还用到了<strong>代理</strong>（第七章复用类里边的，是一种介于继承和组合之间的思想）</p><p>将接口从具体实现中<strong>解耦</strong>使得接口可以应用于多种不同的具体实现，因此代码也就更具可复用性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;接口&quot;&gt;&lt;a href=&quot;#接口&quot; class=&quot;headerlink&quot; title=&quot;接口&quot;&gt;&lt;/a&gt;接口&lt;/h1&gt;&lt;h2 id=&quot;9-3-完全解耦&quot;&gt;&lt;a href=&quot;#9-3-完全解耦&quot; class=&quot;headerlink&quot; title=&quot;9.3 完全解耦&quot;
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java日记——多态</title>
    <link href="https://mr8god.cn/2020/04/16/Java/Java%E6%97%A5%E8%AE%B0/Java%E6%97%A5%E8%AE%B0%E2%80%94%E2%80%94%E5%A4%9A%E6%80%81/"/>
    <id>https://mr8god.cn/2020/04/16/Java/Java%E6%97%A5%E8%AE%B0/Java%E6%97%A5%E8%AE%B0%E2%80%94%E2%80%94%E5%A4%9A%E6%80%81/</id>
    <published>2020-04-16T14:14:05.000Z</published>
    <updated>2020-04-17T07:02:52.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="8-3-1-构造器与多态之构造器的创建顺序"><a href="#8-3-1-构造器与多态之构造器的创建顺序" class="headerlink" title="8.3.1 构造器与多态之构造器的创建顺序"></a>8.3.1 构造器与多态之构造器的创建顺序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.chaptereight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.print;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 20:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meal</span></span>&#123;</span><br><span class="line">    Meal()&#123; print(<span class="string">"Meal()"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bread</span></span>&#123;</span><br><span class="line">    Bread()&#123; print(<span class="string">"Bread()"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cheese</span></span>&#123;</span><br><span class="line">    Cheese()&#123; print(<span class="string">"Cheese()"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lettuce</span></span>&#123;</span><br><span class="line">    Lettuce()&#123; print(<span class="string">"Lettuce()"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lunch</span> <span class="keyword">extends</span> <span class="title">Meal</span></span>&#123;</span><br><span class="line">    Lunch()&#123; print(<span class="string">"Lunch()"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PortableLunch</span> <span class="keyword">extends</span> <span class="title">Lunch</span></span>&#123;</span><br><span class="line">    PortableLunch()&#123; print(<span class="string">"PortableLunch()"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sandwich</span> <span class="keyword">extends</span> <span class="title">PortableLunch</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Bread b = <span class="keyword">new</span> Bread();</span><br><span class="line">    <span class="keyword">private</span> Cheese c = <span class="keyword">new</span> Cheese();</span><br><span class="line">    <span class="keyword">private</span> Lettuce l = <span class="keyword">new</span> Lettuce();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sandwich</span><span class="params">()</span></span>&#123; print(<span class="string">"Sandwich()"</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Sandwich();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 输出结果</span><br><span class="line">Meal()</span><br><span class="line">Lunch()</span><br><span class="line">PortableLunch()</span><br><span class="line">Bread()</span><br><span class="line">Cheese()</span><br><span class="line">Lettuce()</span><br><span class="line">Sandwich()</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/04/16/MsXKb6vqhkrA2ax.png" alt="理解组合继承的构建顺序.png"></p><p>快速做了个图来理解这个东西哈！这里边每个类都有自己的<strong>构造方法</strong>，</p><p>其中最值得关注的就是<strong>Sandwich</strong>类，三个继承关系，（若将<strong>Object</strong>的根继承算上的话，那就是四层继承了）。其中还包括了三个成员对象。当我们在<strong>main()</strong>里边创建好一个<strong>Sandwich</strong>对象后，就可以看到输出结果了</p><h3 id="三条规则"><a href="#三条规则" class="headerlink" title="三条规则"></a>三条规则</h3><p>我先说一下复杂对象调用构造器要遵循的<strong>三条规则</strong>吧</p><ol><li>调用基类构造器。这个步骤会不断地反复递归下去，首先是构造这种层次结构的根，然后是下一层导出类，etc，直到最低层的导出类。</li><li>按声明顺序调用成员的初始化方法。</li><li>调用导出类构造器的主体。</li></ol><p>根据输出结果我们可以看到，它首先输出的就是Meal了，为什么会这样呢？因为根据我<strong>main()</strong>函数里定义的四个东西（三个成员对象和一个成员构造函数）来看我的输出应该是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 输出结果</span><br><span class="line">Bread()</span><br><span class="line">Cheese()</span><br><span class="line">Lettuce()</span><br><span class="line">Sandwich()</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>才对呀。很正常的思维，哈哈哈。不过呢，出现前两个，其实是为了表明，<strong>Meal</strong>类和<strong>Lunch</strong>类在之前先执行了自己的构造函数，而且又因为<strong>Meal</strong>类是<strong>Lunch</strong>类的基类（父类），所以<strong>Meal</strong>类的构造函数在更前面进行了构造了，这正好说明了我之前所说的<strong>三条规则</strong>中的第一条。</p><p>接下来我们输出的就是三小只了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bread()</span><br><span class="line">Cheese()</span><br><span class="line">Lettuce()</span><br></pre></td></tr></table></figure><p>这符合我们之前说的，按照声明调用<strong>成员**</strong>成员**的初始化方法进行输出了</p><p>最后就是我们的导出类构造器的主体，与之对应的就是我们<strong>输出结果</strong>中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sandwich()</span><br></pre></td></tr></table></figure><h3 id="说说心里话"><a href="#说说心里话" class="headerlink" title="说说心里话"></a>说说心里话</h3><p>为什么我们的构造器调用顺序很重要，以至于我专门做了个笔记来讲它呢？</p><p>我们知道当我们导出类（子类）在进行继承的时候，我们是<strong>已经知道了基类（父类）的一切</strong>了，知道它的底细是怎样的呢！不然我们谈何继承呀，只要基类中标注为<strong>protected</strong>和<strong>public</strong>的，都是知道的，这就意味着我们在导出类中，必须假定所有成员<strong>都是有效的</strong>。</p><p>综上所述，我们要确保所有的成员都是有效的，就得从根基做好，先打牢根基，才能走得更远（很像咱们的编程语言学习哦！）。于是我们先启动基类的构造器，确保基类是完好无损的。然后依次向下。</p><p>此外，知道构造器中的所有成员有效也是因为成员对象在类内进行定义的时候，只要有可能，就应该对它们进行初始化。</p><h2 id="8-3-2-继承与清理"><a href="#8-3-2-继承与清理" class="headerlink" title="8.3.2 继承与清理"></a>8.3.2 继承与清理</h2><p>平常我们都是不需要注意清理的问题的，因为毕竟有我们的垃圾处理机制嘛。如果确实遇到了清理的问题，那么就得有心创建<strong>清理方法</strong>了。并且由于是继承的缘故。如果我们有其他作为垃圾回收一部分的特殊清理动作，就必须在导出类中覆盖该<strong>清理方法</strong>。<u>当覆盖被继承类的<strong>清理方法</strong>的时候，务必调用基类版本的<strong>清理方法</strong>，否则，基类的清理就不会发生。</u></p><p>上示范代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.chaptereight;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.print;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Characteristic</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    Characteristic(String s)&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        print(<span class="string">"Creating Characteristic "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span></span>&#123;</span><br><span class="line">        print(<span class="string">"disposing Characteristic "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Description</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    Description(String s)&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        print(<span class="string">"Creating Description "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span></span>&#123;</span><br><span class="line">        print(<span class="string">"disposing Description "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LivingCreature</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Characteristic p =</span><br><span class="line">            <span class="keyword">new</span> Characteristic(<span class="string">"is alive"</span>);</span><br><span class="line">    <span class="keyword">private</span> Description t =</span><br><span class="line">            <span class="keyword">new</span> Description(<span class="string">"Basic Living Creature"</span>);</span><br><span class="line">    LivingCreature()&#123;</span><br><span class="line">        print(<span class="string">"LivingCreature()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span></span>&#123;</span><br><span class="line">        print(<span class="string">"LivingCreature dispose"</span>);</span><br><span class="line">        t.dispose();</span><br><span class="line">        p.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">extends</span> <span class="title">LivingCreature</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Characteristic p =</span><br><span class="line">            <span class="keyword">new</span> Characteristic(<span class="string">"has heart"</span>);</span><br><span class="line">    <span class="keyword">private</span> Description t =</span><br><span class="line">            <span class="keyword">new</span> Description(<span class="string">"Animal not Vegetable"</span>);</span><br><span class="line">    Animal()&#123; print(<span class="string">"Animal()"</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        print(<span class="string">"Animal dispose"</span>);</span><br><span class="line">        t.dispose();</span><br><span class="line">        p.dispose();</span><br><span class="line">        <span class="keyword">super</span>.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Amphibian</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Characteristic p =</span><br><span class="line">            <span class="keyword">new</span> Characteristic(<span class="string">"can live in water"</span>);</span><br><span class="line">    <span class="keyword">private</span>  Description t =</span><br><span class="line">            <span class="keyword">new</span> Description(<span class="string">"Both water and land"</span>);</span><br><span class="line">    Amphibian()&#123;</span><br><span class="line">        print(<span class="string">"Amphibian"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        print(<span class="string">"Amphibian dispose"</span>);</span><br><span class="line">        t.dispose();</span><br><span class="line">        p.dispose();</span><br><span class="line">        <span class="keyword">super</span>.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 11:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Frog</span> <span class="keyword">extends</span> <span class="title">Amphibian</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Characteristic p = <span class="keyword">new</span> Characteristic(<span class="string">"Croaks"</span>);</span><br><span class="line">    <span class="keyword">private</span> Description t = <span class="keyword">new</span> Description(<span class="string">"Eats Bugs"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Frog</span><span class="params">()</span> </span>&#123; print(<span class="string">"Frog()"</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        print(<span class="string">"Frog dispose"</span>);</span><br><span class="line">        t.dispose();</span><br><span class="line">        p.dispose();</span><br><span class="line">        <span class="keyword">super</span>.dispose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Frog frog = <span class="keyword">new</span> Frog();</span><br><span class="line">        print(<span class="string">"Bye!"</span>);</span><br><span class="line">        frog.dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 输出结果</span><br><span class="line">Creating Characteristic is alive</span><br><span class="line">Creating Description Basic Living Creature</span><br><span class="line">LivingCreature()</span><br><span class="line">Creating Characteristic has heart</span><br><span class="line">Creating Description Animal not Vegetable</span><br><span class="line">Animal()</span><br><span class="line">Creating Characteristic can live in water</span><br><span class="line">Creating Description Both water and land</span><br><span class="line">Amphibian</span><br><span class="line">Creating Characteristic Croaks</span><br><span class="line">Creating Description Eats Bugs</span><br><span class="line">Frog()</span><br><span class="line">Bye!</span><br><span class="line">Frog dispose</span><br><span class="line">disposing Description Eats Bugs</span><br><span class="line">disposing Characteristic Croaks</span><br><span class="line">Amphibian dispose</span><br><span class="line">disposing Description Both water and land</span><br><span class="line">disposing Characteristic can live in water</span><br><span class="line">Animal dispose</span><br><span class="line">disposing Description Animal not Vegetable</span><br><span class="line">disposing Characteristic has heart</span><br><span class="line">LivingCreature dispose</span><br><span class="line">disposing Description Basic Living Creature</span><br><span class="line">disposing Characteristic is alive</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/04/16/QzUjJZ2p9VoBC5L.png" alt="理解继承与清理.png"></p><p>代码太长，给大家整理了一个<strong>UML类图</strong>，其中<strong>dispose()</strong>就是我用来清理的方法。</p><p>然后呢，我们每个类都包括了<strong>Characteristic</strong>和<strong>Description</strong>这两种类型的成员对象，并且它们必须最终被<strong>销毁</strong>。</p><h3 id="什么是销毁顺序"><a href="#什么是销毁顺序" class="headerlink" title="什么是销毁顺序"></a>什么是销毁顺序</h3><p>谈到<strong>销毁</strong>呀，这里边还得涉及到一个<strong>销毁顺序</strong>，</p><ul><li><p>如果我们遇到某个子对象要依赖于其他对象，那么<strong>销毁的顺序</strong>应该和初始化顺序相反。</p></li><li><p>而对于<strong>字段</strong>，则意味着与声明的顺序相反（因为<strong>字段</strong>的初始化是按照声明的顺序进行的）。</p></li><li>对于基类，首先应该对其导出类进行清理，然后再是基类。</li></ul><p>上面的知识点很简单啦，就是很明白浅显的道理——<strong>先进先出</strong>嘛！</p><p>对于代码的哈，我再来个图解</p><p><img src="https://i.loli.net/2020/04/17/rmxS71Oe8UsAPTR.jpg" alt="清理代码图解.jpg"></p><p>帮助大家理解这是怎样一个过程哈</p><h3 id="代码理解"><a href="#代码理解" class="headerlink" title="代码理解"></a>代码理解</h3><h4 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h4><p>我主函数代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Frog frog = <span class="keyword">new</span> Frog();</span><br></pre></td></tr></table></figure><p>意味着我们开始<strong>Create</strong> <strong>Create</strong> <strong>Create</strong> 了，首先<strong>Frog</strong>中初始化了两个<strong>Characteristic</strong>和<strong>Description</strong>类对象，同时这也是正式开始<strong>Create</strong> <strong>Create</strong> <strong>Create</strong> 了。</p><p>具体我们是会先指向最基本的那个基类<strong>LivingCreature</strong>开始<strong>Create</strong>，然后依次往下，最后到<strong>Frog</strong>结束<strong>Create</strong>。</p><p>输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Creating Characteristic is alive</span><br><span class="line">Creating Description Basic Living Creature</span><br><span class="line">LivingCreature()</span><br><span class="line">Creating Characteristic has heart</span><br><span class="line">Creating Description Animal not Vegetable</span><br><span class="line">Animal()</span><br><span class="line">Creating Characteristic can live in water</span><br><span class="line">Creating Description Both water and land</span><br><span class="line">Amphibian</span><br><span class="line">Creating Characteristic Croaks</span><br><span class="line">Creating Description Eats Bugs</span><br><span class="line">Frog()</span><br></pre></td></tr></table></figure><h4 id="然后"><a href="#然后" class="headerlink" title="然后"></a>然后</h4><p>我主函数代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"Bye!"</span>);</span><br></pre></td></tr></table></figure><p>暂时小结一下哈！</p><p>输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bye!</span><br></pre></td></tr></table></figure><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>我主函数代码是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frog.dispose();</span><br></pre></td></tr></table></figure><p>这是调用了我<strong>Frog</strong>类中的<strong>dispose()</strong>方法，正式开始<strong>dispose</strong> <strong>dispose</strong> <strong>dispose</strong>了。</p><p><strong>dispose</strong>的顺序与之前<strong>Create</strong>的相反。它是先把底层的，最新的那个导出类（子类）先给<strong>dispose</strong>了，依次向上，最后把最终大Boss <strong>LivingCreature</strong>给<strong>dispose</strong>了，很是简单呢！！！只要花点时间看看就能懂的代码呢，以后我就不打算花时间看书看代码了，直接看我的日记不就得了，哈哈哈！</p><h2 id="8-3-2-继承与清理-为之前扫扫盲"><a href="#8-3-2-继承与清理-为之前扫扫盲" class="headerlink" title="8.3.2 继承与清理+为之前扫扫盲"></a>8.3.2 继承与清理+为之前扫扫盲</h2><p>为什么说是扫扫盲呢，难道是说我江某人在之前的学习没有努力？不不不，不是这样子的。在编程语言的学习中，我们其实不能够学完所有，得分一步步，慢慢来才能学习完整个语言，但是呢，我们在学习基础的时候，如果要写一些例子，光靠基础知识是不能够的呀，所以我们就会将后边”较<strong>高级</strong>的知识先拿来用，就好比我们的C++中漂漂亮亮的前三行，刚开始不也是想都不想先输上去为敬嘛。</p><p>好了，还是赶紧上我们的正餐，上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.chaptereight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.print;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shared</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> refcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shared</span><span class="params">()</span></span>&#123;</span><br><span class="line">        print(<span class="string">"Creating "</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRef</span><span class="params">()</span></span>&#123; refcount++; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (--refcount == <span class="number">0</span>)&#123;</span><br><span class="line">            print(<span class="string">"Disposing "</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Shared&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composing</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Shared shared;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Composing</span><span class="params">(Shared shared)</span></span>&#123;</span><br><span class="line">        print(<span class="string">"Creating "</span> + <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.shared = shared;</span><br><span class="line">        <span class="keyword">this</span>.shared.addRef();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span></span>&#123;</span><br><span class="line">        print(<span class="string">"disposing "</span> + <span class="keyword">this</span>);</span><br><span class="line">        shared.dispose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Composing&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 21:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCounting</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shared shared = <span class="keyword">new</span> Shared();</span><br><span class="line">        Composing[] composing = &#123; </span><br><span class="line">                <span class="keyword">new</span> Composing(shared),</span><br><span class="line">                <span class="keyword">new</span> Composing(shared),</span><br><span class="line">                <span class="keyword">new</span> Composing(shared),</span><br><span class="line">                <span class="keyword">new</span> Composing(shared),</span><br><span class="line">                <span class="keyword">new</span> Composing(shared)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (Composing c :</span><br><span class="line">                composing) &#123;</span><br><span class="line">            c.dispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这还是一个关于<strong>继承与清理</strong> 的例子，但是它和上一个不同的地方在于<u>这次的代码中<strong>成员对象</strong>存在<strong>与其他一个或多个对象共享</strong>的情况</u>，问题变得复杂起来了。这次就不能简单地调用<strong>dispose()</strong>就能解决了，必须使用<strong>引用计数</strong>来跟踪仍旧访问着共享对象的对象数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Creating Shared&#123;id&#x3D;0&#125;</span><br><span class="line">Creating Composing&#123;id&#x3D;0&#125;</span><br><span class="line">Creating Composing&#123;id&#x3D;1&#125;</span><br><span class="line">Creating Composing&#123;id&#x3D;2&#125;</span><br><span class="line">Creating Composing&#123;id&#x3D;3&#125;</span><br><span class="line">Creating Composing&#123;id&#x3D;4&#125;</span><br><span class="line">disposing Composing&#123;id&#x3D;0&#125;</span><br><span class="line">disposing Composing&#123;id&#x3D;1&#125;</span><br><span class="line">disposing Composing&#123;id&#x3D;2&#125;</span><br><span class="line">disposing Composing&#123;id&#x3D;3&#125;</span><br><span class="line">disposing Composing&#123;id&#x3D;4&#125;</span><br><span class="line">Disposing Shared&#123;id&#x3D;0&#125;</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>这段代码我分三段来讲</p><h3 id="第一段"><a href="#第一段" class="headerlink" title="第一段"></a>第一段</h3><p>在看任何代码之前，我们都要注意<strong>static</strong>这个关键字，因为它总是在任何代码执行之前而被执行。这里就有这么一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>主代码中是这一段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shared shared = <span class="keyword">new</span> Shared();</span><br></pre></td></tr></table></figure><p>这小小的一段代码直接指向了<strong>Shared</strong>这个类，我们先来看看这个类的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shared</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> refcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shared</span><span class="params">()</span></span>&#123;</span><br><span class="line">        print(<span class="string">"Creating "</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRef</span><span class="params">()</span></span>&#123; refcount++; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (--refcount == <span class="number">0</span>)&#123;</span><br><span class="line">            print(<span class="string">"Disposing "</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Shared&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始执行代码了首先它先做了两个变量的初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> refcount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = counter++;</span><br></pre></td></tr></table></figure><p>这边的变量<strong>refcount</strong>是我们在第三段调用<strong>dispose()</strong>时需要用到的，暂时不看。<br>这里的变量<strong>counter</strong>是我们在第二段正式调用<strong>Create()</strong>时需要用到的，暂时不看。</p><p>接下来，就是第一段的正事了，代码先跑到了<strong>Shared()</strong>方法里，使用<strong>print</strong>方法（过后真正用到该方法，我会贴源码的），方法里的东西有一个是有趣，就是我们在第四章的老朋友<strong>this</strong>了，这边的<strong>this</strong>指的是我们调用它的对象——主函数中的<strong>shared</strong>，哦了，解释完毕。</p><p>看<strong>print</strong>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printnb</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        System.out.print(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PrintStream <span class="title">printf</span><span class="params">(String format, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.out.printf(format, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，接下来<strong>print(this)</strong>会干什么呢？<strong>this</strong>相当于一种低级的类，或者说是一种子类。我们可以看到我们的<strong>this</strong>低级类被强转了，或者叫做<strong>向上转型</strong>。成功的称为上流社会<strong>Object</strong>类了。然后理所应当地调用<strong>toString</strong>方法，只不过我们这边重写了这个方法，于是它就按照我们重写的方法执行了，来到了本地的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Shared&#123;"</span> +</span><br><span class="line">            <span class="string">"id="</span> + id +</span><br><span class="line">            <span class="string">'&#125;'</span>;</span><br></pre></td></tr></table></figure><p>中去，最终实现了输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating Shared&#123;id&#x3D;0&#125;</span><br></pre></td></tr></table></figure><p>光荣使命！！！没想到以前的一个小小的输出就要涉及这么多东西呀，害，太难了。理解上面的内容，你还需要在心中明确这样一点<strong>system.out.println()都是直接调用toString打印的</strong>。</p><h3 id="第二段"><a href="#第二段" class="headerlink" title="第二段"></a>第二段</h3><p>代码的第二段就是持续的执行我主函数中的<strong>Composing</strong>数组了，里边的五个成员，依次进行初始化。输出结果的原理和第一段一样，</p><p>说一下我们先前没有讲的<strong>counter</strong>变量，这个变量的用途就是计数，然后赋值给<strong>id</strong>然后进行输出的时候变得好看一点的操作，over。<strong>counter</strong>会从1变到5，然后赋值给<strong>id</strong>并进行输出</p><p>但是我们在此基础上增加了一个<strong>“心眼”</strong>，我们还使用<strong>addRef()</strong>方法。该方法的作用就是使咱们的<strong>refcount</strong>凑效，使其开始赋值，从0到5，然后以备我们第三段代码中被用到。</p><p>关于<strong>addRef()</strong>方法，我这边还有点话要说。<br><strong>Composing</strong>类的构造函数和<strong>Shared</strong>类的构造函数出现了一丢丢区别。我们看代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Composing</span><span class="params">(Shared shared)</span></span>&#123;</span><br><span class="line">    print(<span class="string">"Creating "</span> + <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.shared = shared;</span><br><span class="line">    <span class="keyword">this</span>.shared.addRef();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边涉及到我们的<strong>this</strong>知识，是关于我<strong>this</strong>的第二种用法，<strong>在构造器中调用构造器</strong>。方法的具体实现是这样子的，<br>首先，由于没有继承关系，我们在<strong>Composing</strong>中设了一个<strong>Shared</strong>的对象。然后该对象就到了我们的构造方法中了<br>然后，我们可以看到我们在构造方法中，是这样调用<strong>Shared</strong>的<strong>addRef</strong>方法的。我们先把传进来的<strong>Shared</strong>赋值给我们的<strong>this.shared</strong>于是把传进来的<strong>Shared</strong>与之前特意设立的<strong>Shared</strong>通过<strong>this</strong>联系在一起。<br>接下来，我们就这样的使用<strong>引用的引用</strong>最终用我们在主函数中的<strong>shared</strong>对象使用了远在天边近在眼前的<strong>Shared</strong>类中的<strong>addRef()</strong>方法，对，你没有听错，就是这样，这就很<strong>Java</strong>——一步一步调用类中的对象，再用对象调用方法，如果中间有一步因为某些原因断掉了，那就很抱歉，就无法实现目标（调用方法）了。</p><p>好啦好啦，当我们运行完所有的第二段代码后，我们会得到一个计数为5的<strong>refcount</strong>变量，以及下面的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Creating Composing&#123;id&#x3D;0&#125;</span><br><span class="line">Creating Composing&#123;id&#x3D;1&#125;</span><br><span class="line">Creating Composing&#123;id&#x3D;2&#125;</span><br><span class="line">Creating Composing&#123;id&#x3D;3&#125;</span><br><span class="line">Creating Composing&#123;id&#x3D;4&#125;</span><br></pre></td></tr></table></figure><h3 id="第三段"><a href="#第三段" class="headerlink" title="第三段"></a>第三段</h3><p>第三段就没啥讲的了，重要的概念理解前两段都讲完了，这边就是单独又引用了一个<strong>dispose</strong>方法。然后输出了，平平无奇！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对了，对了，在将一个共享对象附着到类上时，必须记得调用<strong>addRef()</strong>但是<strong>disposing()</strong>将跟踪引用数<strong>refcount</strong>，并决定何时执行清理。使用这种技巧需要加倍地细心，但是如果你正在共享需要清理的对象，那么你就会陷入很麻烦的境地，就更要细心了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;多态&quot;&gt;&lt;a href=&quot;#多态&quot; class=&quot;headerlink&quot; title=&quot;多态&quot;&gt;&lt;/a&gt;多态&lt;/h1&gt;&lt;h2 id=&quot;8-3-1-构造器与多态之构造器的创建顺序&quot;&gt;&lt;a href=&quot;#8-3-1-构造器与多态之构造器的创建顺序&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java日记" scheme="https://mr8god.cn/tags/Java%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java深耕——自动装箱拆箱机制</title>
    <link href="https://mr8god.cn/2020/04/15/Java/Java%E6%B7%B1%E8%80%95/Java%E6%B7%B1%E8%80%95%E2%80%94%E2%80%94%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1%E6%9C%BA%E5%88%B6/"/>
    <id>https://mr8god.cn/2020/04/15/Java/Java%E6%B7%B1%E8%80%95/Java%E6%B7%B1%E8%80%95%E2%80%94%E2%80%94%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1%E6%9C%BA%E5%88%B6/</id>
    <published>2020-04-15T13:33:29.000Z</published>
    <updated>2020-04-16T14:09:39.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java深耕——在深入理解Java自动装箱拆箱机制"><a href="#Java深耕——在深入理解Java自动装箱拆箱机制" class="headerlink" title="Java深耕——在深入理解Java自动装箱拆箱机制"></a>Java深耕——在深入理解Java自动装箱拆箱机制</h1><h2 id="自动装箱与拆箱的定义"><a href="#自动装箱与拆箱的定义" class="headerlink" title="自动装箱与拆箱的定义"></a>自动装箱与拆箱的定义</h2><p>装箱就是自动将基本数据类型转换为包装器类型；拆箱就是，自动将包装器类型转换为基本数据类型</p><p>Java中的数据类型分为两类：一类是基本数据类型，另一类是引用数据类型</p><p><img src="https://i.loli.net/2020/04/15/FseJUGTZ628OwoV.jpg" alt="基本数据类型的分类.jpg"></p><div class="table-container"><table><thead><tr><th style="text-align:center">简单类型</th><th style="text-align:center">二进制位数</th><th style="text-align:center">封装器类</th></tr></thead><tbody><tr><td style="text-align:center">int</td><td style="text-align:center">32</td><td style="text-align:center">Integer</td></tr><tr><td style="text-align:center">byte</td><td style="text-align:center">8</td><td style="text-align:center">Byte</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">64</td><td style="text-align:center">Long</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">32</td><td style="text-align:center">Float</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">64</td><td style="text-align:center">double</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">16</td><td style="text-align:center">Character</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">1</td><td style="text-align:center">Boolean</td></tr></tbody></table></div><h2 id="上自动装箱代码"><a href="#上自动装箱代码" class="headerlink" title="上自动装箱代码"></a>上自动装箱代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">3</span>;</span><br><span class="line">        <span class="comment">//定义一个基本数据类型的变量a赋值3</span></span><br><span class="line">        Integer b=a;</span><br><span class="line">        <span class="comment">//b是Integer 类定义的对象，直接用int 类型的a赋值    </span></span><br><span class="line">        System.out.println(b);</span><br><span class="line">        <span class="comment">//打印结果为3</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面代码中的Integer b = a;就是我们所说的自动装箱的过程，上面代码在执行的时候调用了Integer.valueOf(int i)方法简化后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;       </span><br><span class="line">        <span class="keyword">if</span> (i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= <span class="number">127</span>)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + <span class="number">127</span>];</span><br><span class="line">            <span class="comment">//如果i的值大于-128小于127则返回一个缓冲区中的一个Integer对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">        <span class="comment">//否则返回 new 一个Integer 对象</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到Integer.valueOf(a)其实是返回了一个Integer的对象。因此由于自动装箱的存在Integer b = a这段代码是没有问题的，并且我们可以简化的来这样写：Integer b = 3;</p><p>同样也等价于这样写：Integer b = Integer.valueOf(3)。</p><h2 id="上自动拆箱代码"><a href="#上自动拆箱代码" class="headerlink" title="上自动拆箱代码"></a>上自动拆箱代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        Integer b=<span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//b为Integer的对象</span></span><br><span class="line">        <span class="keyword">int</span> a=b;</span><br><span class="line">        <span class="comment">//a为一个int的基本数据类型</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">        <span class="comment">//打印输出3。</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面有一个：int a = b;  代码中把一个对象赋给了基本类型。其实这就等于int a = b.intValue()。</p><p>根据源码中可知道intValue是什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法就是返回了value值嘛，但是这里的value又是怎么一回事呢？继续找源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>原来这里的value就是，Integer后边括号里的值呀，于是我们的拆箱代码其实本质上是这样写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        Integer b=<span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//b为Integer的对象</span></span><br><span class="line">        <span class="keyword">int</span> a=b.intValue();</span><br><span class="line">        <span class="comment">//其中b.intValue()返回实例化b时构造函数new Integer(3);赋的值3。</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">        <span class="comment">//打印输出3。</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="范围概念"><a href="#范围概念" class="headerlink" title="范围概念"></a>范围概念</h2><p>这里边是一个挺重要的知识点，至少我之前看的疯狂Java视频资料，以及我看的《Java编程思想》这本书，都有这方面的介绍。先看一个代码哈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1000</span>,b=<span class="number">1000</span>;</span><br><span class="line">Integer c=<span class="number">100</span>,d=<span class="number">100</span>;</span><br><span class="line">System.out.println(a==b);</span><br><span class="line">System.out.println(c==d);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>原本我会以为是输出的是：true    true啦，但是实际上不对，正确答案是false    true。为甚呢？细细道来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">        <span class="comment">//1</span></span><br><span class="line">        Integer a=<span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">        Integer b=<span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">        System.out.println(a==b);<span class="comment">//输出 false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2 </span></span><br><span class="line">        Integer c=<span class="number">123</span>;</span><br><span class="line">        Integer d=<span class="number">123</span>;  </span><br><span class="line">        System.out.println(c==d);<span class="comment">//输出 true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3</span></span><br><span class="line">        Integer e=<span class="number">129</span>;</span><br><span class="line">        Integer f=<span class="number">129</span>;</span><br><span class="line">        System.out.println(e==f);<span class="comment">//输出 false</span></span><br><span class="line">        <span class="comment">//4</span></span><br><span class="line">        <span class="keyword">int</span> g=<span class="number">59</span>;</span><br><span class="line">        Integer h=<span class="keyword">new</span> Integer(<span class="number">59</span>);</span><br><span class="line">        System.out.println(g==h);<span class="comment">//输出 true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/04/15/JAFCoyUKmtDWNn4.jpg" alt="常量池.jpg"></p><p>第一部分输出false，很好理解，因为比较的是堆中指向的对象是不是同一个嘛，a,b是栈中对象的引用分别指向堆中的两个不同的对象。而a==b这条语句就是判断a、b在堆中指向的对象是不是统一个，因此输出为false。</p><p>第二部分输出true也很好理解，正是用了我们的自动装箱技术</p><p>我带大家这次仔细的看自动装箱的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;       </span><br><span class="line">        <span class="keyword">if</span> (i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= <span class="number">127</span>)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + <span class="number">127</span>];</span><br><span class="line">            <span class="comment">//如果i的值大于-128小于127则返回一个缓冲区中的一个Integer对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">        <span class="comment">//否则返回 new 一个Integer 对象</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的代码中：IntegerCache.cache[i + 127];   表示狠眼生，继续看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">        <span class="comment">//定义一个Integer类型的数组且数组不可变</span></span><br><span class="line">        <span class="keyword">static</span> &#123;  </span><br><span class="line">        <span class="comment">//利用静态代码块对数组进行初始化。                     </span></span><br><span class="line">            cache = <span class="keyword">new</span> Integer[<span class="number">256</span>];</span><br><span class="line">            <span class="keyword">int</span> j = -<span class="number">128</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//cache[]原来是一个Integer 类型的数组（也可以称为常量池），value 从-128到127，</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">if</span> (i &gt;=-<span class="number">128</span> &amp;&amp; i &lt;= <span class="number">127</span>)        </span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">            <span class="comment">//如果装箱时值在-128到127之间，之间返回常量池中的已经初始化后的Integer对象。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">        <span class="comment">//否则返回一个新的对象。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来IntegerCache类在初始化的时候，生成了一个大小为256的integer类型的常量池，并且integer.val的值从-128~127，当我们运行Integer c = a（临时做的一个小栗子哈）的时候，如果-128 &lt;= a &lt;= 127，就不会再生成新的integer对象。于是我们第二部分的c和d指向的是同一个对象，所以比较的时候是相等的，所以我们输出true。</p><p>第三部分，理解如第二部分</p><p>第四部分：代码中g指向的是栈中的变量，h指向的是堆中的对象，但是我们的g == h为什么还是true呢？这就是<strong>自动插箱</strong>干的好事，g == h这代码执行的时候就是：g == h.IntValue()，而h.IntValue()=59，所以两边其实是两个int在比较而已。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单一句话：</p><p><strong>装箱</strong>就是自动将基本数据类型转换为包装器类型；</p><p><strong>拆箱</strong>就是自动将包装器类型转换为基本数据类型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java深耕——在深入理解Java自动装箱拆箱机制&quot;&gt;&lt;a href=&quot;#Java深耕——在深入理解Java自动装箱拆箱机制&quot; class=&quot;headerlink&quot; title=&quot;Java深耕——在深入理解Java自动装箱拆箱机制&quot;&gt;&lt;/a&gt;Java深耕——在深入
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java深耕" scheme="https://mr8god.cn/tags/Java%E6%B7%B1%E8%80%95/"/>
    
  </entry>
  
  <entry>
    <title>Java深耕——第四章之this关键字</title>
    <link href="https://mr8god.cn/2020/04/14/Java/Java%E6%B7%B1%E8%80%95/Java%E6%B7%B1%E8%80%95%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E7%AB%A0%E4%B9%8Bthis%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://mr8god.cn/2020/04/14/Java/Java%E6%B7%B1%E8%80%95/Java%E6%B7%B1%E8%80%95%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E7%AB%A0%E4%B9%8Bthis%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2020-04-14T07:49:15.000Z</published>
    <updated>2020-04-14T15:15:53.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java深耕——第四章之this关键字"><a href="#Java深耕——第四章之this关键字" class="headerlink" title="Java深耕——第四章之this关键字"></a>Java深耕——第四章之this关键字</h1><p>本文灵感来源于知乎文章（<a href="https://zhuanlan.zhihu.com/p/62779357）" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/62779357）</a><br>以及《Java编程思想》P85页</p><h2 id="使用this关键字之前"><a href="#使用this关键字之前" class="headerlink" title="使用this关键字之前"></a>使用this关键字之前</h2><p>Java提供了一个叫做<strong>this</strong>关键字，<strong>this</strong>关键字总是指向调用该方法的对象。根据this出现的位置不同，this作为对象的默认引用有两种情况。</p><ol><li>构造器中引用该构造器正在初始化的对象</li><li>在方法中引用调用该方法的对象</li></ol><h2 id="在方法中引用调用该方法的对象"><a href="#在方法中引用调用该方法的对象" class="headerlink" title="在方法中引用调用该方法的对象"></a>在方法中引用调用该方法的对象</h2><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>那我们直接上了概念，肯定是不能够被大家理解的哈，我们转念换个角度来想一想，我们如果没有<strong>this</strong>关键字，会面临一个什么样子的情况呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个move()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在执行move()方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个eat()方法，eat()方法需要借助move()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.move();</span><br><span class="line">        System.out.println(<span class="string">"正在执行eat()方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Person对象</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">//调用Person的eat()方法</span></span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代码来源于：https://zhuanlan.zhihu.com/p/62779357</span></span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正在执行move()方法</span><br><span class="line">正在执行eat()方法</span><br></pre></td></tr></table></figure><h3 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h3><p>上述的方式确实能够做到eat()方法里调用move()方法，但是我们在main()方法里可以看到我们总共创建了两个对象：main()方法里创建了一个对象；eat()方法里创建了一个对象。但是实际上我们是不需要两个对象的，因为在程序调用第一个eat()方法时一定会提供一个Person对象，而不需要重新创建一个Person了。</p><p>因此我们可以通过<strong>this</strong>关键字在eat()方法中获得调用该方法的对象。<strong>this</strong>关键字只能在方法内部使用，表示对”调用方法的那个对象“的引用。</p><p>于是上面的代码Person类中的eat()方法改为下面这种方式较为合适：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个eat()方法，eat()方法需要借助move()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用this引用调用eat()方法的对象</span></span><br><span class="line">    <span class="keyword">this</span>.move();</span><br><span class="line">    System.out.println(<span class="string">"正在执行eat()方法"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过呢，虽然接下来要说的，可能会让读者同学感觉我是在耍你哈。但是可不是哦，上面这么多我只是做个引子而已，用来引导大家的。我先说我要说的知识点吧</p><p><strong>this</strong>关键字的用法和其他对象引用并无不同。但是如果要在方法内部调用同一个类的另一个方法，就不必使用this，直接调用即可。当前方法的this引用会自动应用用途同一类中的其他方法。所以上述代码也可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个eat()方法，eat()方法需要借助move()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    move();</span><br><span class="line">    System.out.println(<span class="string">"正在执行eat()方法"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体代码可以如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.example;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 16:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在执行move()方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        move();</span><br><span class="line">        System.out.println(<span class="string">"正在执行eat()方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>暂时的小总结</strong>：</p><p>​        在eat()方法内部，你可以写this.move()，但无此必要。编译器能够帮你自动添加。只有当明确指出对当前对象的引用时，才需要使用<strong>this</strong>关键字。例如，当需要返回对当前对象的引用的时候，就常常在return语句里这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.chapterfive;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 11:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Leaf <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"i = "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Leaf x = <span class="keyword">new</span> Leaf();</span><br><span class="line">        x.increment().increment().increment().print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中，由于increment()通过<strong>this</strong>关键字返回了对当前对象的引用，所以很容易就可以在一条语句里对同一个对象执行多次操作。</p><p><strong>this</strong>关键字对于将当前对象传递给其他方法也很有用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.chapterfive;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 11:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Apple apple)</span></span>&#123;</span><br><span class="line">        Apple peeled = apple.getPeeled();</span><br><span class="line">        System.out.println(<span class="string">"Yummy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Peeler</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Apple <span class="title">peel</span><span class="params">(Apple apple)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apple;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>&#123;</span><br><span class="line">    <span class="function">Apple <span class="title">getPeeled</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> Peeler.peel(<span class="keyword">this</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassingThis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Person().eat(<span class="keyword">new</span> Apple());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Apple</strong>需要调用<strong>Peeler.peel()</strong>方法，这个方法是一个外部的工具方法，将执行由于某种原因而必须放在<strong>Apple</strong>外部的操作。为了将其自身传递给外部方法，<strong>Apple</strong>必须使用<strong>this</strong>关键字。</p><h2 id="在构造器中调用构造器"><a href="#在构造器中调用构造器" class="headerlink" title="在构造器中调用构造器"></a>在构造器中调用构造器</h2><p>另一种情形是：<strong>this</strong>关键字可以用于构造器中作为默认引用，由于构造器是直接使用<strong>new</strong>关键字来调用的，而不是使用对象来调用的，所以<strong>this</strong>在构造器中代表该构造器正在初始化的对象。</p><h3 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.example;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 17:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Person().age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与普通方法类似，大部分时候，我们在构造器中访问其他成员变量和方法时都可以省略<strong>this</strong>前缀，但是如果构造器中有一个与成员变量同名的局部变量，又必须在构造器中访问这个被覆盖的成员变量，则必须使用<strong>this</strong>前缀。正如上面的程序所示。</p><p>当<strong>this</strong>作为对象的默认引用使用时，程序可以像访问普通引用变量一样来访问这个<strong>this</strong>引用，甚至可以把<strong>this</strong>当成普通方法的返回值。如下面的程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">grow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        age ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">//可以连续调用同一个方法</span></span><br><span class="line">        p.grow().grow().grow();</span><br><span class="line">        System.out.println(<span class="string">"p对象的age的值是："</span>+p.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p对象的age的值是：3</span><br></pre></td></tr></table></figure><p>上面的代码中可以看到，如果在某个方法中把this作为返回值，则可以多次连续调用同一个方法，从而使得代码变得更加的简洁。</p><h3 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h3><p>有时候为一个类写了多个构造器，我们可能想在一个构造器中调用另一个构造器，以避免重复代码。可以使用<strong>this</strong>关键字做到这一点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.chapterfive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.print;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 11:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Flower</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> petalCount = <span class="number">0</span>;</span><br><span class="line">    String s = <span class="string">"initial value"</span>;</span><br><span class="line">    Flower(<span class="keyword">int</span> petals)&#123;</span><br><span class="line">        petalCount = petals;</span><br><span class="line">        print(<span class="string">"Constructor w/ int arg only, petalCount= "</span></span><br><span class="line">        + petalCount);</span><br><span class="line">    &#125;</span><br><span class="line">    Flower(String ss)&#123;</span><br><span class="line">        print(<span class="string">"Constructor w/ String arg only, s = "</span> + ss);</span><br><span class="line">        s = ss;</span><br><span class="line">    &#125;</span><br><span class="line">    Flower(String s, <span class="keyword">int</span> petals)&#123;</span><br><span class="line">        <span class="keyword">this</span>(petals);</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        print(<span class="string">"String &amp; int args"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Flower()&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">"hi"</span>, <span class="number">47</span>);</span><br><span class="line">        print(<span class="string">"default constructor (no args)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printPetalCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        print(<span class="string">"petalCount = "</span> + petalCount + <span class="string">" s = "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Flower x = <span class="keyword">new</span> Flower(<span class="string">"江晨玥"</span>,<span class="number">222</span>);</span><br><span class="line"><span class="comment">//        Flower x = new Flower();</span></span><br><span class="line">        x.printPetalCount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这串代码如果给初学者看的话，会有一点不明确的地方，毕竟代码太长了嘛，这边给个建议，就只看我们的this指针部分哦！</p><p>然后代码中，我选择初始化了一个Flower(“江晨玥”, 222)的方法，首先这行代码会被用到上面的Flower(String s, int petals)里边，很好的实现了方法的重载嘛。然后我们就可以直观地看到这边，我讲解几个可能会有疑问的地方哈</p><h4 id="可能会有疑问一"><a href="#可能会有疑问一" class="headerlink" title="可能会有疑问一"></a>可能会有疑问一</h4><p>这边</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flower(String s, <span class="keyword">int</span> petals)&#123;</span><br><span class="line">        <span class="keyword">this</span>(petals);</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        print(<span class="string">"String &amp; int args"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码中的this(petals)到底是怎么一回事，其实有这个疑问还是要算你的<strong>this</strong>关键字没有理解到家，this其实在这里指的是Flower，相当于我在这个Flower(String s, int petals)里引用了Flower(int petals)方法。</p><h4 id="可能会有疑问二"><a href="#可能会有疑问二" class="headerlink" title="可能会有疑问二"></a>可能会有疑问二</h4><p>这边的this.s = s，可能也会有疑问，其实这个也展示了this的另外一种用法。由于参数s的名称和数据成员s的名字相同，所以会很容易产生歧义。使用<strong>this.s</strong>就可以来代表数据成员解决这个问题。Java日常编程经常会这样的哦</p><h4 id="讲解一"><a href="#讲解一" class="headerlink" title="讲解一"></a>讲解一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printPetalCount()</span><br></pre></td></tr></table></figure><p>方法表明，除构造器之外，编译器禁止在其他任何方法中调用构造器，不信？你可以试试！</p><h2 id="Over！"><a href="#Over！" class="headerlink" title="Over！"></a>Over！</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java深耕——第四章之this关键字&quot;&gt;&lt;a href=&quot;#Java深耕——第四章之this关键字&quot; class=&quot;headerlink&quot; title=&quot;Java深耕——第四章之this关键字&quot;&gt;&lt;/a&gt;Java深耕——第四章之this关键字&lt;/h1&gt;&lt;p&gt;本文
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>博客文章组织结构图解</title>
    <link href="https://mr8god.cn/2020/04/12/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E5%9B%BE%E8%A7%A3/"/>
    <id>https://mr8god.cn/2020/04/12/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E5%9B%BE%E8%A7%A3/</id>
    <published>2020-04-12T05:21:45.000Z</published>
    <updated>2020-04-12T05:43:17.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本博客文章组织结构图（分类篇）"><a href="#本博客文章组织结构图（分类篇）" class="headerlink" title="本博客文章组织结构图（分类篇）"></a>本博客文章组织结构图（分类篇）</h2><p><img src="https://i.loli.net/2020/04/12/acgHqINPdTx298w.png" alt="Mr8god博客文章组织结构图（分类篇）.png"></p><h2 id="本博客文章组织结构图（标签篇）"><a href="#本博客文章组织结构图（标签篇）" class="headerlink" title="本博客文章组织结构图（标签篇）"></a>本博客文章组织结构图（标签篇）</h2><p><img src="https://i.loli.net/2020/04/12/OPf6VKuyH5DLwFU.png" alt="Mr8god博客文章组织结构图（标签篇）.png"></p><h2 id="2020年4月12日13-42发布"><a href="#2020年4月12日13-42发布" class="headerlink" title="2020年4月12日13:42发布"></a>2020年4月12日13:42发布</h2><h2 id="未完待续……"><a href="#未完待续……" class="headerlink" title="未完待续……"></a>未完待续……</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;本博客文章组织结构图（分类篇）&quot;&gt;&lt;a href=&quot;#本博客文章组织结构图（分类篇）&quot; class=&quot;headerlink&quot; title=&quot;本博客文章组织结构图（分类篇）&quot;&gt;&lt;/a&gt;本博客文章组织结构图（分类篇）&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://
      
    
    </summary>
    
    
      <category term="建站那些事儿" scheme="https://mr8god.cn/categories/%E5%BB%BA%E7%AB%99%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    
    
      <category term="hexo_Next" scheme="https://mr8god.cn/tags/hexo-Next/"/>
    
  </entry>
  
  <entry>
    <title>可持续集成（CI）</title>
    <link href="https://mr8god.cn/2020/04/11/%E5%BB%BA%E7%AB%99%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/%E5%8F%AF%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%EF%BC%88CI%EF%BC%89/"/>
    <id>https://mr8god.cn/2020/04/11/%E5%BB%BA%E7%AB%99%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/%E5%8F%AF%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%EF%BC%88CI%EF%BC%89/</id>
    <published>2020-04-11T07:49:15.000Z</published>
    <updated>2020-04-14T15:51:09.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="可持续集成（CI）的学习"><a href="#可持续集成（CI）的学习" class="headerlink" title="可持续集成（CI）的学习"></a>可持续集成（CI）的学习</h1><p>这是一种基于github托管平台的工具类系统，我们以Travis CI来讲这一项技术的实现。</p><h2 id="什么是Continuous-Integration-CI-呢？"><a href="#什么是Continuous-Integration-CI-呢？" class="headerlink" title="什么是Continuous Integration(CI)呢？"></a>什么是Continuous Integration(CI)呢？</h2><p>这是一种在小周期内寻求经常合并代码的一种模式。<br>与此相对的就是，在一个大的开发周期结束后进行合并的另一种模式。</p><p>CI的目标就是以较小的增量开发，一点点的增加自己的代码和经常性的测试，从而构建更加稳定和优秀的软件开发。</p><p>​        Travis CI通过自动化生成并且测试代码的改变来实现对我们开发进程的一种帮助。而且如果成功实现了改变，它还能够提供实时的反馈。</p><p>​        Travis CI也能在你的程序开发中的其他部分提供帮助，通过<strong>管理部署</strong>和<strong>通知</strong></p><h2 id="CI的构建以及自动化：Building，Testing，Deploying"><a href="#CI的构建以及自动化：Building，Testing，Deploying" class="headerlink" title="CI的构建以及自动化：Building，Testing，Deploying"></a>CI的构建以及自动化：Building，Testing，Deploying</h2><p>​        当你使用了Build的功能后，Travis CI将会从你的github仓库拉下你的代码，并把它放在一个全新的虚拟环境中。然后执行一系列的build命令进而test你的代码。</p><p>​        如果你的代码test没通过，那么build将会被认为是失败了的；相反如果通过了，build就是成功的，系统便会将代码部署到你想让它部署的地方去。</p><p>​        CI build可以自动化你的动作流的其他部分。这就意味着你可以使你的任务和其它的一些部分相互依赖起来，通过Build Stages，设置notifications，准备deployments在你build之后或者更多其他的任务之后的方法。</p><h2 id="Builds，Jobs，Stages-and-Phases"><a href="#Builds，Jobs，Stages-and-Phases" class="headerlink" title="Builds，Jobs，Stages and Phases"></a>Builds，Jobs，Stages and Phases</h2><p>这里是对上面几个名词的解释</p><ul><li>phase - 这是指一种继往开来的工作模式。举个例子，我们首先要做好deploy部署好阶段，然后我们才关注script阶段，最后我们才能够实现install阶段。</li><li>job - 一种自动化的进程就是一个job，我举一个例子哈，我们从我们的远程仓库将代码clone下来，clone到一个虚拟环境中去，接下来我们开始执行一系列的阶段比如说编译代码、跑代码测试等等。当然如果我们的job中有一个步骤出现了错误，那么我们的script阶段就会向我们返回一个值来报错。</li><li>build - 一组jobs。举个例子，一个build命令下可能会有2个jobs，每个jobs都会用各自适合的编程语言来进行测试项目。一个build的完成，也就意味着它的jobs都被成功完成了。</li><li>stage - 由多个阶段组成的顺序生成过程的一部分并行运行，就称为一组作业</li></ul><h2 id="Breaking-the-Build"><a href="#Breaking-the-Build" class="headerlink" title="Breaking the Build"></a>Breaking the Build</h2><p>当满足一下条件的时候，我们就认为build已经损坏了。（比如说一个或多个作业完成且状态未通过时：</p><ul><li>errored - 我们在before_install，install， before_script阶段输错了命令导致返回了一串错误代码。这个job就会立刻停止。</li><li>failed - 在script阶段的一个命令导致返回了错误代码。这个job会继续跑知道它完成了它的工作。</li><li>canceled - 管理员取消了job</li></ul><h2 id="Infrastructure-and-Environment-Notes"><a href="#Infrastructure-and-Environment-Notes" class="headerlink" title="Infrastructure and Environment Notes"></a>Infrastructure and Environment Notes</h2><p>对于不同的操作系统，有不同的要求</p><ul><li>Linux - 以后有用再去官方文档查</li><li>macos - 同上</li><li>Windows - 系统版本在1803以上。</li></ul><p>Travis CI是在软件开发领域中的一个在线的、分布式的持续集成服务，用来测试在github托管的代码的。好吧上面所有的build可以替换成构建。</p><h2 id="开始讲解Travis-CI和github-page运行机制原理"><a href="#开始讲解Travis-CI和github-page运行机制原理" class="headerlink" title="开始讲解Travis CI和github page运行机制原理"></a>开始讲解Travis CI和github page运行机制原理</h2><p>宝贝们，上面都是我对官方文档的翻译哦，我觉得不是特别妥<br>现在才是最重要的部分，是精髓哦！我花了（让我算算哈，从早上8:15到现在22:53）14个小时38分钟。是真的“有意思哦”！</p><p>闲话少说，开始了</p><p>首先得感谢我桃大佬的概念输出，大概是上上周吧，建议我为了我博客的安全着想，将本地的博客配置文件保存到云端，如果本地的硬盘出了啥问题的话，我们也可以从云端恢复数据，完美的主意！桃大佬给了我可持续集成这一概念的输出。</p><h3 id="概念输出：什么是可持续集成（CI）呢？"><a href="#概念输出：什么是可持续集成（CI）呢？" class="headerlink" title="概念输出：什么是可持续集成（CI）呢？"></a>概念输出：什么是可持续集成（CI）呢？</h3><p>这个网上都能给出正确的解释，这是一种在线托管的持续集成服务，与github是好哥们，当我们用github账号登录了Travis CI（CI的一种）之后，我们就可以看到介家伙上面有所有我们github仓库中的项目。是的呢，就是和github穿一条裤子的呢！我先放图哈！</p><p><img src="https://i.loli.net/2020/04/11/fadAh6GMnswYxkr.jpg" alt="Travis介绍_一_.jpg"></p><p>大家可以从图中很容易的看到，我Mr8god在GitHub上的仓库这边都有。概念我也说了，大致样子也给大家看了，我们开始下一步。</p><h3 id="Travis-CI和GitHub的机制原理"><a href="#Travis-CI和GitHub的机制原理" class="headerlink" title="Travis CI和GitHub的机制原理"></a>Travis CI和GitHub的机制原理</h3><p>先放图，这是我自己做的图解</p><p><img src="https://i.loli.net/2020/04/11/iMrYfkWB2vAwLzh.jpg" alt="Travis CI和GitHub的机制原理.jpg"></p><p>这一张图可以很好的解释哈，我这边也懒得加水印啥的，想拿就拿。</p><p>不管是啥机制，首先的前提是你的思路一定要明确，这也就是为什么网上教程有很多，但是很少有人能够做得出来的原因。大多数人只喜欢找现成的就满足了。但是那些都是治标不治本的玩意儿，真东西还是得往细了研究，以前都觉得那些花里胡哨的东西真好玩，可真等到我玩过了之后才发现，基础才是最重要的东西！！！不禁想到了很多人很早学习了框架……咳咳，不扯远了不扯远不扯远了哈</p><p>我先说一下我的<strong>持续集成思路</strong>哈</p><ul><li>我想到这个的背景：上面也说过了，是我桃大佬提供的（他超棒）。主要是为了解决hexo博客平台无法备份代码源码的问题，因为我如果没有备份的源码，万一我本地的存储系统崩盘了之后，我不就蛋糕了吗？！！！所以现在搭建好这一系统后，如果遇到了本地存储系统崩盘的情况，我们可以从云端（GitHub）上下载代码，实现本地重建。</li><li>我的持续集成思路：我的博客源码存储在GitHub上的一个独立的仓库（上图中的GitHubSource）中，博客hexo自动生成的静态文件又是在另外一个独立的仓库（GitHubgitpage）中，每次我在本地把代码推到我的GitHub仓库之后，Travis就会立刻监听到我仓库发生了变动，这个时候Travis就会采取反制措施，具体我后面再细讲。反制措施会生成原本本地就可以生成的博客网站静态文件，并把文件部署到GitHubPage上面。</li></ul><h4 id="图解："><a href="#图解：" class="headerlink" title="图解："></a>图解：</h4><p>Step1：这一步骤，我是将本地的代码推到GitHub上的GitHubSource仓库中去。<br>Step2：这一步骤得细讲，我们GitHub的好兄弟——Travis在第一时间发现了我存储在GitHubSource仓库里的代码发生了变动（此处就是我Step1中的推代码行为导致的变动，实际生活中也可能是删掉代码之类的其他操作导致的仓库变动），于是它做的第一件事情就是将变动后的代码拉到它自己的虚拟机上，我更愿意将它理解为虚拟机（实际上不是虚拟机哦！）。<br>Step3：虚拟机接下来会检查拉到本地的源码中是否会存在.travis.yml文件，该文件里边就有指示Travis CI本地虚拟机的命令，下面我详解一下该文件哈！现在我们只要知道该命令可以像本地hexo那样将博客源代码进行编译，生成静态文件。<br>Step4：接下来我就要向大家补充或者说巩固一个知识点了：hexo博客平台每一次的hexo三连（hexo c &amp;&amp; hexo g &amp;&amp; hexo d)，最后都只是将博客中的public文件部署（上传）到GitHubPage而已。于是咱们的第四步就是将在Travis CI虚拟机中生成的静态文件上传到我的GitHubPage仓库中去。至此，大功告成！</p><h4 id="travis-yml文件详解"><a href="#travis-yml文件详解" class="headerlink" title=".travis.yml文件详解"></a>.travis.yml文件详解</h4><p>先放上我的文件，可以信赖哦！</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span> <span class="comment"># 要安装的node版本为稳定版</span></span><br><span class="line"></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">node_modules</span> <span class="comment"># 要缓存的文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">./public</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">init</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">"mr8god"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.mail</span> <span class="string">"17696748602@163.com"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">"代码使用Travis CI自动部署的哈"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">push</span> <span class="string">--force</span> <span class="string">--quiet</span> <span class="string">"https://$&#123;blogsource&#125;@$&#123;GH_REF&#125;"</span> <span class="string">master:master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span> <span class="comment"># 触发持续集成的分支。现在我们源码在哪里，这边就填哪一个分支，如果该分支发生变化，那么就会启动travisCI</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">GH_REF:</span> <span class="string">github.com/Mr8god/Mr8god.github.io.git</span></span><br></pre></td></tr></table></figure><p>参数讲解：</p><p>-language：指定Travis CI的基本环境语言，我这边选择的是hexo的基本环境原因——nodejs<br>-node_js：选择安装的node版本，对咯对咯，每一次使用Travis CI的虚拟机都会是一幅全新的模样，该虚拟机每一次的操作都需要安装对应的环境。<br>-cache：缓存文件存储的位置<br>-install：这里边我选择了 npm install命令，安装hexo博客平台需要的一些依赖包。<br>-script：脚本行为开始，可以看到我这边是本地很正常的hexo clean和hexo g命令，不做解释哈。执行完这两个行为后，我们会在虚拟机的public文件夹中生成我们需要的静态网页文件。<br>-after_script：如其名，执行完脚本后该干什么呢？这边的一串命令是为了将虚拟机的public文件夹中的静态文件上传到GitHubPage仓库中去，实现部署。<br>-branches：里边填上我们Travis CI所监督的GitHub仓库的分支，只要这个分支出现了代码变动，就会有接下来一波反制措施。<br>-env：介里边是变量。</p><p>综上介绍完了，如果你要用我的配置文件的话，你需要把- git config user.name “mr8god”、 - git config user.mail “17696748602@163.com”、-GH_REF: github.com/Mr8god/Mr8god.github.io.git或者再加上那个分支的内容改一改，改成自己的东西就行了。</p><h4 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h4><p>这个也是挺重要的！</p><p>首先我们在我们的GitHub上建好我用于存放源码的仓库哦！接下来就需要打开GitHub的setting进行GitHub与它好兄弟Travis CI的故事了</p><h5 id="GitHub与Travis-CI进行token绑定"><a href="#GitHub与Travis-CI进行token绑定" class="headerlink" title="GitHub与Travis CI进行token绑定"></a>GitHub与Travis CI进行token绑定</h5><p>首先我们打开我们的GitHub主页面，进入我们的setting里，发现了deployer setting<br><img src="https://i.loli.net/2020/04/11/PjFb6sQqTZG9oil.jpg" alt="实操（一）.jpg"></p><p>我们点进去，接下来会看到下图<br><img src="https://i.loli.net/2020/04/11/jhAyTCIuaJWkFz9.jpg" alt="实操（二）.jpg"></p><p>然后继续点我的红圈<br><img src="https://i.loli.net/2020/04/11/oIJi1XZESlymvGd.jpg" alt="实操（三）.jpg"></p><p>然后继续点我的红圈，我们开始创建token了<br><img src="https://i.loli.net/2020/04/11/S9kTX7opWxKEm6N.jpg" alt="实操（四）.jpg"></p><p>这边我们要记住我们的note，因为接下来在Travis CI页面我们用得上。</p><p><img src="https://i.loli.net/2020/04/11/wDY2qQN63s4Iory.jpg" alt="实操（五）.jpg"></p><p>然后这边的这个值也一定要记住！！！这个时候就该把它复制下来了，因为这个页面只会显示一次，如果你错过了，你就得重来亿遍！</p><p><img src="https://i.loli.net/2020/04/11/DIflmz6WnR78QEq.jpg" alt="实操（六）.jpg"></p><p>接下来，在前一个name的红圈内填上我们的note，后边的value中填上我们刚刚复制的码。就OK了，就实现了这个仓库和我们GitHub仓库的绑定。</p><p>【一个常见的错误】：我们在观测代码变动时，在Travis CI的Build History中可能会遇到不管怎么push，依旧 纹丝不动的情况，这个时候就要注意看看自己的.travis.yml文件是否是完整无缺，没有错误的。</p><h5 id="在博客文件上我们要做些什么呢？"><a href="#在博客文件上我们要做些什么呢？" class="headerlink" title="在博客文件上我们要做些什么呢？"></a>在博客文件上我们要做些什么呢？</h5><p>我们需要在博客文件的根目录下添加我们上面详解的.travis.yml文件，就行了。接下来就是一个容易出错的<strong>重点</strong>了，而且比较难免描述清楚，我尽力用我的语言描述清楚哈。</p><h5 id="如何将本地的hexo博客源码push到GitHub上的source仓库中去"><a href="#如何将本地的hexo博客源码push到GitHub上的source仓库中去" class="headerlink" title="如何将本地的hexo博客源码push到GitHub上的source仓库中去"></a>如何将本地的hexo博客源码push到GitHub上的source仓库中去</h5><p>这个地方是困扰我很久的地方，如果这个地方没有做好的话，我们会面临一个直观的问题，我们部署好之后的网站是一片空白，</p><p>为什么呢？<br>因为我们的渲染文件没有部署上去呀！</p><p>为什么我们的渲染文件没有部署上去呢？<br>因为我们源码中的next主题（hexo的一种博客主题）没有push到我们的云端GitHub的source仓库呀！</p><p>为什么我们的next主题文件会没有push到我们的云端GitHub上的source仓库中去呢？<br>这个就要说到我们当初创建本地博客文件的时候了，那个时候我没有注意一个问题，我直接主题源码仓库把代码pull到本地了，这导致了我们的theme——next文件中本身就有一个初始化过、指向原仓库的git了，这构成了git的一种叫做submodule（子模块，就是git文件中还有一个git文件），</p><p>这会导致什么结果呢？<br>会导致本地的next文件夹无法上传到我们的GitHub源代码仓库中去，<br>进而无法被我们的Travis CI拉到它的虚拟机中去，<br>进而无法生成CSS、js等网站渲染文件，<br>进而出现了我们开头所讲到的一片空白现象。</p><p>这一点提醒了我，日后在pull别人代码的时候，要做分离处理！！！</p><p>那我们该怎么解决呢？</p><p>【解决方法】</p><ol><li>首先我们来到我们的next文件夹（博客目录/themes/next)下，删掉.git和.gitnore文件</li><li>然后cd到我们的themes文件夹目录下，清除缓存。命令是：git rm -r —cached next</li><li>然后就是Git三连了（git add .  、 git commit -m “想说啥说啥”  、 git push)</li><li>完美解决问题，别看这么简单，我花了三小时……</li></ol><h2 id="大功告成，睡了睡了"><a href="#大功告成，睡了睡了" class="headerlink" title="大功告成，睡了睡了"></a>大功告成，睡了睡了</h2><p>有问题联系我江某人哈</p><p>QQ：1803357141</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;可持续集成（CI）的学习&quot;&gt;&lt;a href=&quot;#可持续集成（CI）的学习&quot; class=&quot;headerlink&quot; title=&quot;可持续集成（CI）的学习&quot;&gt;&lt;/a&gt;可持续集成（CI）的学习&lt;/h1&gt;&lt;p&gt;这是一种基于github托管平台的工具类系统，我们以Trav
      
    
    </summary>
    
    
      <category term="建博客那些事儿" scheme="https://mr8god.cn/categories/%E5%BB%BA%E5%8D%9A%E5%AE%A2%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    
    
      <category term="hexo_Next" scheme="https://mr8god.cn/tags/hexo-Next/"/>
    
  </entry>
  
  <entry>
    <title>重构笔记</title>
    <link href="https://mr8god.cn/2020/04/11/%E9%87%8D%E6%9E%84%E7%AC%94%E8%AE%B0/"/>
    <id>https://mr8god.cn/2020/04/11/%E9%87%8D%E6%9E%84%E7%AC%94%E8%AE%B0/</id>
    <published>2020-04-11T07:49:15.000Z</published>
    <updated>2020-04-14T16:19:26.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重构笔记"><a href="#重构笔记" class="headerlink" title="重构笔记"></a>重构笔记</h1><h2 id="重构前"><a href="#重构前" class="headerlink" title="重构前"></a>重构前</h2><h3 id="代码一（Customer）"><a href="#代码一（Customer）" class="headerlink" title="代码一（Customer）"></a>代码一（Customer）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.refactoring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 00:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String _name;</span><br><span class="line">    <span class="keyword">private</span> Vector _rentals = <span class="keyword">new</span> Vector();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        _name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRental</span><span class="params">(Rental arg)</span></span>&#123;</span><br><span class="line">        _rentals.addElement(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">statement</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> totalAmount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> frequentRenterPoints = <span class="number">0</span>;</span><br><span class="line">        Enumeration rentals = _rentals.elements();</span><br><span class="line">        String result = <span class="string">"Rental Record for "</span> + getName() + <span class="string">"\n"</span>;</span><br><span class="line">        <span class="keyword">while</span> (rentals.hasMoreElements())&#123;</span><br><span class="line">            <span class="keyword">double</span> thisAmount = <span class="number">0</span>;</span><br><span class="line">            Rental each = (Rental) rentals.nextElement();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (each.getMovie().getPriceCode())&#123;</span><br><span class="line">                <span class="keyword">case</span> Movie.REGULAR:</span><br><span class="line">                    thisAmount += <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (each.getDaysRented() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                        thisAmount += (each.getDaysRented() -<span class="number">2</span>) * <span class="number">1.5</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> Movie.NEW_RELEASE:</span><br><span class="line">                    thisAmount += each.getDaysRented() * <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Movie.CHILDRENS:</span><br><span class="line">                    thisAmount += <span class="number">1.5</span>;</span><br><span class="line">                    <span class="keyword">if</span> (each.getDaysRented() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                        thisAmount += (each.getDaysRented() - <span class="number">3</span>) * <span class="number">1.5</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            frequentRenterPoints ++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((each.getMovie().getPriceCode() == Movie.NEW_RELEASE) &amp;&amp; each.getDaysRented() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                frequentRenterPoints ++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result += <span class="string">"\t"</span> + each.getMovie().getTitle() + <span class="string">"\t"</span> + String.valueOf(thisAmount) + <span class="string">"\n"</span>;</span><br><span class="line">            totalAmount += thisAmount;</span><br><span class="line">        &#125;</span><br><span class="line">        result += <span class="string">"Amount owed is "</span> + String.valueOf(totalAmount) + <span class="string">"\n"</span>;</span><br><span class="line">        result += <span class="string">"You earned "</span> + String.valueOf(frequentRenterPoints) + <span class="string">" frequent renter points"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码二（Rental）"><a href="#代码二（Rental）" class="headerlink" title="代码二（Rental）"></a>代码二（Rental）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.refactoring;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 00:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rental</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Movie _movie;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> _daysRented;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rental</span><span class="params">(Movie movie, <span class="keyword">int</span> daysRented)</span></span>&#123;</span><br><span class="line">        _movie = movie;</span><br><span class="line">        _daysRented = daysRented;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDaysRented</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _daysRented;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Movie <span class="title">getMovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _movie;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码三（Movie）"><a href="#代码三（Movie）" class="headerlink" title="代码三（Movie）"></a>代码三（Movie）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.refactoring;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 00:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHILDRENS = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REGULAR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW_RELEASE = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String _title;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> _priceCode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Movie</span><span class="params">(String title, <span class="keyword">int</span> priceCode)</span></span>&#123;</span><br><span class="line">        _title = title;</span><br><span class="line">        _priceCode = priceCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPriceCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _priceCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPriceCode</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">        _priceCode = arg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第一次重构后"><a href="#第一次重构后" class="headerlink" title="第一次重构后"></a>第一次重构后</h2><h3 id="代码一（Customer）-1"><a href="#代码一（Customer）-1" class="headerlink" title="代码一（Customer）"></a>代码一（Customer）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.refactoring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 00:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String _name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector _rentals = <span class="keyword">new</span> Vector();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        _name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRental</span><span class="params">(Rental arg)</span></span>&#123;</span><br><span class="line">        _rentals.addElement(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">statement</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Enumeration rentals = _rentals.elements();</span><br><span class="line">        String result = <span class="string">"Rental Record for "</span> + getName() + <span class="string">"\n"</span>;</span><br><span class="line">        <span class="keyword">while</span> (rentals.hasMoreElements())&#123;</span><br><span class="line">            Rental each = (Rental) rentals.nextElement();</span><br><span class="line"></span><br><span class="line">            result += <span class="string">"\t"</span> + each.getMovie().getTitle() + <span class="string">"\t"</span> + String.valueOf(each.getCharge()) + <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result += <span class="string">"Amount owed is "</span> + String.valueOf(getTotalCharge()) + <span class="string">"\n"</span>;</span><br><span class="line">        result += <span class="string">"You earned "</span> + String.valueOf(getTotalFrequentRenterPoints()) + <span class="string">" frequent renter points"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">amountFor</span><span class="params">(Rental aRental)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aRental.getCharge();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getTotalCharge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">0</span>;</span><br><span class="line">        Enumeration rentals = _rentals.elements();</span><br><span class="line">        <span class="keyword">while</span> (rentals.hasMoreElements())&#123;</span><br><span class="line">            Rental each = (Rental)rentals.nextElement();</span><br><span class="line">            result += each.getCharge();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTotalFrequentRenterPoints</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        Enumeration rentals = _rentals.elements();</span><br><span class="line">        <span class="keyword">while</span> (rentals.hasMoreElements())&#123;</span><br><span class="line">            Rental each = (Rental) rentals.nextElement();</span><br><span class="line">            result += each.getFrequentRenterPoints();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码二（Rental）-1"><a href="#代码二（Rental）-1" class="headerlink" title="代码二（Rental）"></a>代码二（Rental）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.refactoring;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 00:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rental</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Movie _movie;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> _daysRented;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rental</span><span class="params">(Movie movie, <span class="keyword">int</span> daysRented)</span></span>&#123;</span><br><span class="line">        _movie = movie;</span><br><span class="line">        _daysRented = daysRented;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDaysRented</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _daysRented;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Movie <span class="title">getMovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _movie;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getCharge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (getMovie().getPriceCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> Movie.REGULAR:</span><br><span class="line">                result += <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (getDaysRented() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                    result += (getDaysRented() - <span class="number">2</span>) * <span class="number">1.5</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> Movie.NEW_RELEASE:</span><br><span class="line">                result += getDaysRented() * <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Movie.CHILDRENS:</span><br><span class="line">                result += <span class="number">1.5</span>;</span><br><span class="line">                <span class="keyword">if</span> (getDaysRented() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                    result += (getDaysRented() - <span class="number">3</span>) * <span class="number">1.5</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected value: "</span> + getMovie().getPriceCode());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getFrequentRenterPoints</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((getMovie().getPriceCode() == Movie.NEW_RELEASE) &amp;&amp; getDaysRented() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码三（Movie）-1"><a href="#代码三（Movie）-1" class="headerlink" title="代码三（Movie）"></a>代码三（Movie）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.refactoring;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 00:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHILDRENS = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REGULAR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW_RELEASE = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String _title;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> _priceCode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Movie</span><span class="params">(String title, <span class="keyword">int</span> priceCode)</span></span>&#123;</span><br><span class="line">        _title = title;</span><br><span class="line">        _priceCode = priceCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPriceCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _priceCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPriceCode</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">        _priceCode = arg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第一次重构心得"><a href="#第一次重构心得" class="headerlink" title="第一次重构心得"></a>第一次重构心得</h3><p>大多数重构都会减少代码量，但这次我们的重构却增加了代码量。</p><p>主要原因 这边使用的Java设置了大量语句来实现了一个累加循环。哪怕只是一个简单的累加循环，每个元素只需要一行代码，外围的支持代码也需要六行！虽然这是每个Java程序员都熟悉的写法，但是代码量还是太多了。</p><p>与其如此还不如不做这么多操作呢。再来说一下代码性能问题。原本代码只需要执行while循环一次就行了，经过我第一次重构后，代码居然要执行三次。进而代码的耗时可能就会很多，就可能大大降低了程序的性能。但是呢，这些本应不是我重构需要关心的问题，因为我其实本不知道我的代码经过一次重构后的性能会如何（害，说到这个我就想起了我的JProfiler，我现在还没能掌握它，难受），这需要专业的代码性能工具来进行测试。再说了，关于代码的性能，我们可以到后期进行性能优化时再考虑嘛。所以还没到最后呢！我们没有必要过早作出判决呀！</p><p>那么现在我们说一下优点哈。Now，Customer类内的所有代码都可以调用这些查询函数（就是我之前将临时变量浓缩成的那几个函数）。如果系统其它部分需要这部分信息，也可以轻松地将查询函数加入Customer类接口中。如果没有这些查询函数，其他函数就必须了解Rental类，并自行建立循环，这势必会增大程序的编写难度和维护难度。从而提高代码出错的概率。</p><p>好了好了，我们不能仅限于此哈，现在假设我们的产品经理又要跟我们提需求了，他们想让我们增加一个修改影片分类规则的功能。但是呢有没有具体告诉我们这究竟是一个怎样的分类规则。我们尚未清楚他们想怎么做，只知道新的分类法很快就要引入了。现有的分类法马上就要变了。与之相应的部分就是我们的计算方式和常客积分计算。我们现在必须要进入我们的计算方法和常客积分中，把因条件而异的代码替换掉，这样才能为将来的改变换上一层保护膜。我们开始新一轮的重构了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;重构笔记&quot;&gt;&lt;a href=&quot;#重构笔记&quot; class=&quot;headerlink&quot; title=&quot;重构笔记&quot;&gt;&lt;/a&gt;重构笔记&lt;/h1&gt;&lt;h2 id=&quot;重构前&quot;&gt;&lt;a href=&quot;#重构前&quot; class=&quot;headerlink&quot; title=&quot;重构前&quot;&gt;&lt;/a&gt;重构
      
    
    </summary>
    
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>从第一个Java代码我学习到了什么呢？</title>
    <link href="https://mr8god.cn/2020/04/10/Java/%E4%BB%8E%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E4%BB%A3%E7%A0%81%E6%88%91%E5%AD%A6%E4%B9%A0%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F/"/>
    <id>https://mr8god.cn/2020/04/10/Java/%E4%BB%8E%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E4%BB%A3%E7%A0%81%E6%88%91%E5%AD%A6%E4%B9%A0%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F/</id>
    <published>2020-04-10T07:49:15.000Z</published>
    <updated>2020-04-14T16:20:45.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从第一个Java代码我学习到了什么呢？"><a href="#从第一个Java代码我学习到了什么呢？" class="headerlink" title="从第一个Java代码我学习到了什么呢？"></a>从第一个Java代码我学习到了什么呢？</h1><p>emmmmmm，我先上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.experiment1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/816:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberIsPalindrome40</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">100000</span>;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">1</span>;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(max)%(max - min + <span class="number">1</span>) + min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = x;</span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>) &#123;</span><br><span class="line">            cur = cur * <span class="number">10</span> + num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur == x;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = getNum();</span><br><span class="line">        out.println(a);</span><br><span class="line">        out.println(<span class="string">"是"</span> + ((a+<span class="string">""</span>).length()) + <span class="string">"位数"</span> );</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">new</span> NumberIsPalindrome40().isPalindrome(a))&#123;</span><br><span class="line">            out.println(<span class="string">"咱们随机生成的数字："</span> + a + <span class="string">"是一个回文数呢！"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            out.println(<span class="string">"咱们随机生成的数字："</span> + a + <span class="string">"不是一个回文数哦！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从第一个Java代码我学习到了什么呢？&quot;&gt;&lt;a href=&quot;#从第一个Java代码我学习到了什么呢？&quot; class=&quot;headerlink&quot; title=&quot;从第一个Java代码我学习到了什么呢？&quot;&gt;&lt;/a&gt;从第一个Java代码我学习到了什么呢？&lt;/h1&gt;&lt;p&gt;em
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java速记——变量详解</title>
    <link href="https://mr8god.cn/2020/04/09/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E5%8F%98%E9%87%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>https://mr8god.cn/2020/04/09/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E5%8F%98%E9%87%8F%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-04-09T07:49:15.000Z</published>
    <updated>2020-04-14T15:52:51.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java速记——变量详解"><a href="#Java速记——变量详解" class="headerlink" title="Java速记——变量详解"></a>Java速记——变量详解</h1><p>Java没有全局变量的概念！！！</p><p>Java变量</p><ul><li>成员变量：<ul><li>位置：类中定义成员变量<ul><li>类变量 ： 有static</li><li>实例变量 ： 无static</li></ul></li></ul></li><li>局部变量<ul><li>位置：方法中定义局部变量<ul><li>形参</li><li>普通局部变量</li><li>代码块的局部变量</li></ul></li></ul></li></ul><p>判断变量：</p><ol><li>首先看位置</li><li>然后看修饰符</li></ol><h2 id="成员变量："><a href="#成员变量：" class="headerlink" title="成员变量："></a>成员变量：</h2><p>可以不需要显式指定初始值，系统可以自动分配初始值；</p><p>初始值规则与数组元素的初始值规则完全能相同。</p><p><strong>观点</strong>：程序中，类本身只有一个；程序一定先有类，再有对象（实例）！！！</p><h3 id="类变量："><a href="#类变量：" class="headerlink" title="类变量："></a>类变量：</h3><p>类变量属于类本身，当系统初始化类时，就会为类分别分配空间，并执行初始化。</p><h3 id="实例变量："><a href="#实例变量：" class="headerlink" title="实例变量："></a>实例变量：</h3><p>类变量属于对象本身，系统每次创建对象时，都需要为该对象的实例变量分配空间，并执行初始化。</p><ul><li>严格来说：类变量，应该由类本身进行访问。<pre><code>                实例变量，应该由对象进行访问。</code></pre>Java的一种不知道有啥用的语法（或许可以出题？）：允许通过对象类访问类变量</li></ul><p>比如说static int test这种设立类变量的方法，但是我们在实际访问的时候，举个情景例子哈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Computer c1 = <span class="keyword">new</span> Computer();</span><br><span class="line">        </span><br><span class="line">        Computer c2 = <span class="keyword">new</span> Computer();</span><br><span class="line">       </span><br><span class="line">        System.out.println(c1.test);</span><br><span class="line">        System.out.println(c2.test);<span class="comment">// Java允许通过对象类访问类变量</span></span><br><span class="line">        c2.test = <span class="number">20</span>;</span><br><span class="line">        System.out.println(c2.test);</span><br><span class="line">        System.out.println(c1.test);</span><br><span class="line"><span class="comment">//        System.out.println(test);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边看起来c1，c2看起来是很不错，引用的是咱们的test类变量，其实Java中根本就没有这个玩意儿。这玩意儿开辟出来就是在堆内存中占了个位置，然后谁用它，它就变成谁，说实话目前我还没有找到正确使用这个东西的姿势，over。这边看起来用的c1，c2，其实全是Computer类引用的，效果和下面的代码一样！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Computer c1 = <span class="keyword">new</span> Computer();</span><br><span class="line"></span><br><span class="line">        Computer c2 = <span class="keyword">new</span> Computer();</span><br><span class="line"></span><br><span class="line">        System.out.println(Computer.test);</span><br><span class="line">        System.out.println(Computer.test);<span class="comment">// Java允许通过对象类访问类变量</span></span><br><span class="line">        c2.test = <span class="number">20</span>;</span><br><span class="line">        System.out.println(Computer.test);</span><br><span class="line">        System.out.println(Computer.test);</span><br><span class="line"><span class="comment">//        System.out.println(test);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以我建议</strong>：暂时我们就使用类调用类变量、类方法。</p><p>如果考试的时候，遇到用对象调用类变量、类方法的情况，第一步先把对象换成类。</p><h2 id="局部变量："><a href="#局部变量：" class="headerlink" title="局部变量："></a>局部变量：</h2><p>必须由程序员显式指定初始值，然后才能使用——否则编译报错；</p><p>局部变量的作用域很小，只在方法里有效；</p><p>离开了方法，局部变量就会失效</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java速记——变量详解&quot;&gt;&lt;a href=&quot;#Java速记——变量详解&quot; class=&quot;headerlink&quot; title=&quot;Java速记——变量详解&quot;&gt;&lt;/a&gt;Java速记——变量详解&lt;/h1&gt;&lt;p&gt;Java没有全局变量的概念！！！&lt;/p&gt;
&lt;p&gt;Java变量
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java速记——数组</title>
    <link href="https://mr8god.cn/2020/04/09/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/"/>
    <id>https://mr8god.cn/2020/04/09/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/</id>
    <published>2020-04-09T07:49:15.000Z</published>
    <updated>2020-04-14T16:04:34.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java——数组"><a href="#Java——数组" class="headerlink" title="Java——数组"></a>Java——数组</h1><p>数组：可以一次定义，就可以得到多个类型相同、功能相似的变量，本质还是变量</p><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>java类型可以分成基本类型、应用类型</p><ol><li>基本类型：8个<ol><li>引用类型：数组、类、接口、枚举</li></ol></li></ol><p><strong>数组其实就是一种引用类型。</strong></p><p>任何已有的类型，添加一组方括号就可以变成数组类型</p><p>int ：属于基本类型</p><p>int[]：属于引用类型</p><p>int[]（是一个整体，得连在一起写，一定要注意哈！）</p><p>long         -&gt; long[]</p><p>String       -&gt; String[]</p><p>double     -&gt; double[]</p><p>int []         -&gt; int $[][]$</p><p>数组元素的类型：是数组类型去掉一组方括号</p><p> 比如说int[]数组元素的类型，就是int</p><h3 id="创建数组对象（数组初始化）"><a href="#创建数组对象（数组初始化）" class="headerlink" title="创建数组对象（数组初始化）"></a>创建数组对象（数组初始化）</h3><ol><li><p>静态初始化</p><p>new 类型[] {元素1, 元素2,  ……}<br>不指定长度，只指定每个元素。<br><del>静态初始化的简化语法，省略掉in[]，但是这种方法只能在定义数组变量初始值的时候进行使用</del>，只能在定义数组变量，并赋初始值时使用。</p></li><li><p>动态初始化<br>new 类型[] {元素1, 元素2,  ……}<br>只指定长度，不指定每个元素。<br>系统会自动为每个元素分配初始值，其分配规则是：</p><ul><li>所有数组元素为数值类型时，数组元素的初始值为0；</li><li>所有数组元素为boolean类型时，数组元素的初始值为false</li><li>所有数组元素为引用类型时，数组元素的初始值为null</li></ul></li></ol><h3 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h3><ol><li><p>数组都有一个length属性，该属性返回数组的长度</p><p>数组一旦创建，其长度是固定的，他在内存中位置也是固定的。</p></li><li><p>每个数组元素，就相当于一个变量。数组元素的类型，就是数组类型去掉一组方括号<br>访问数组元素：<br>数组元素[索引] ——索引从0开始。最后一个元素的索引是length-1<br>使用的元素超出数组长度，就会导致ArrayIndexOutOfBoundsException: 4（数组索引越界异常）</p></li><li><p>遍历数组 - 依次使用每个元素</p></li><li><p>使用for each循环遍历数组<br>for(元素类型 变量名：数组名){</p><p>​        // 可通过变量名访问每个元素、</p><p>}<br>数组有几个元素，该循环就执行几次，变量会自动、依次等于每个元素。<br>foreach遍历只能访问数组元素的值，不能修改数组元素的值。<br><strong>建议</strong>：永远不要在foreach循环中修改计数器的值！</p></li></ol><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="深入理解数组"><a href="#深入理解数组" class="headerlink" title="深入理解数组"></a>深入理解数组</h3><p>数组是一种引用类型，<strong>引用类型和基本类型的区别在哪里？</strong></p><p>java程序的内存可以分成两种：</p><h4 id="堆-heap-内存："><a href="#堆-heap-内存：" class="headerlink" title="-堆(heap)内存："></a>-堆(heap)内存：</h4><p>java虚拟机启动时分配的一块永久的、很大的内存区。堆内存只有一块。</p><p><strong>java程序必须要使用虚拟机才能运行！</strong>。内存区我们是看不到的。java-Xms可以设置初始java堆大小。比如手 java -Xmx256 内存只有245兆。很容易就会爆内存。 </p><p>Error occurred during initialization of VM<br>Too small initial heap</p><p>上面两行就是爆内存的报错</p><h4 id="栈-stack-内存："><a href="#栈-stack-内存：" class="headerlink" title="-栈(stack)内存："></a>-栈(stack)内存：</h4><p>每次方法运行分配一块临时、很小的内存区。</p><p>每个方法都有自己相应的栈区，方法结束时，对应的栈区就会被回收。</p><p>几个方法就有几个栈区</p><h4 id="在方法中定义的、局部变量（不管是什么类型），都会放入相应的方法栈中去。"><a href="#在方法中定义的、局部变量（不管是什么类型），都会放入相应的方法栈中去。" class="headerlink" title="-在方法中定义的、局部变量（不管是什么类型），都会放入相应的方法栈中去。"></a>-在方法中定义的、局部变量（不管是什么类型），都会放入相应的方法栈中去。</h4><h4 id="new出来的东西，都在堆内存"><a href="#new出来的东西，都在堆内存" class="headerlink" title="-new出来的东西，都在堆内存"></a>-new出来的东西，都在堆内存</h4><p>堆内存中的对象，如果没有引用变量指向它，那它就变成了trash，等待vm的垃圾回收机制回收它。</p><p>计算机的每个内存单元（Byte、字节)在操作系统中都有一个编号，就像是一栋大楼的每个房间号</p><p>【变量赋值的区别：】</p><p>-基本类型的赋值：直接将该值存入变量所在内存</p><p>-引用类型的赋值：将该对象所在第一个内存单元的编号（内存地址）存入变量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java——数组&quot;&gt;&lt;a href=&quot;#Java——数组&quot; class=&quot;headerlink&quot; title=&quot;Java——数组&quot;&gt;&lt;/a&gt;Java——数组&lt;/h1&gt;&lt;p&gt;数组：可以一次定义，就可以得到多个类型相同、功能相似的变量，本质还是变量&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java速记——类与对象</title>
    <link href="https://mr8god.cn/2020/04/09/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>https://mr8god.cn/2020/04/09/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-04-09T07:49:15.000Z</published>
    <updated>2020-04-14T15:52:17.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java速记——类与对象"><a href="#Java速记——类与对象" class="headerlink" title="Java速记——类与对象"></a>Java速记——类与对象</h1><p>面向对象：Java是一门面向对象的语言</p><p>类：某一类对象的统称。相当于是一个概念性的（不是具体存在的东西）</p><p>对象：现实中所能接触到的各种“东西”。</p><p>三句总决：定义类、创建对象、调用方法</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>[修饰符] class 类名</p><p>{</p><p>​        // 成员变量</p><p>​        // 方法</p><p>​        // 构造器</p><p>​        // 内部类</p><p>​        // 初始化块</p><p>}————类体</p><p>类中的五大成员</p><ol><li>修饰符：public、final|abstract。其他的都不能出现，顺序是无所谓的，但是void返回类型一定要在修饰符后边</li><li>类名：语法要求——只要是标识符即可<br>从专业角度来看：多个单词连缀而成。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>[修饰符] 类型 变量名 [ = 初始值];</p><p>修饰符： private| protected|public、final|abstract、static、（transient：序列化相关）</p><p>类型：任意基本类型或引用类型</p><p>变量名：驼峰写法，首字母小写，后面每个单词首字母大写。。。 成员变量，用于描述该类或对象的状态，因此通常建议用名词。项目中，只定义项目感兴趣的状态</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>[修饰符] 返回值类型 方法名(形参列表)</p><p>{</p><p>​        // 代码，之前所有的东西，各种流程控制，定义变量（数组），都是在这个里边写的</p><p>如果声明了返回值类型，必须有return语句。</p><p>}————-方法体</p><ol><li><p>修饰符： private| protected|public、final|abstract、static</p></li><li><p>返回值类型：任意基本类型或引用类型，可使用void</p></li><li><p>方法名：</p><ol><li>语法要求：只要是标识符即可</li><li>专业角度：驼峰写法，首字母小写，后面每个单词首字母大写。。。 成员变量，</li><li>方法：用于描述该类或对象的状态，因此通常建议用<strong>动词</strong>。</li><li>项目中，只定义项目感兴趣的状态</li></ol></li><li><p>形参列表：形参类型1 形参名, 形参类型2 形参名2，……</p><p>每个形参都满足“形参类型 形参名”的格式；多个形参之间用逗号隔开。<br>代表调用方法时要传入的参数。</p></li></ol><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>作用：new调用构造器来创建对象</p><p>如果你没有为类写构造器，系统会默认为该类提供一个无参数的构造器！！！！只能隐藏构造器，但是每个类都会是有构造器的</p><p>[修饰符] 构造器名(形参列表)</p><p>{</p><p>​        // 代码：定义变量（包括数组）、变量赋值、流程控制、数据语</p><p>如果声明了返回值类型，必须有return语句。</p><p>}————-构造器体</p><ol><li>修饰符：private|protected|public</li><li>构造器名必须与类名相同</li></ol><p>判断一个类是不是构造器，要看两点：构造器名是否与类名相同、是否有返回值</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类可以用来干什么呢？</p><ol><li>定义变量<br>所有类，都是引用类型。所有类，都可用于声明变量</li><li>调用static修饰方法或static修饰的变量</li><li>创建对象</li><li>派生子类 </li></ol><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>对象可以用来做什么</p><ol><li>调用无static修饰的成员变量</li><li>调用无static修饰的方法</li></ol><h4 id="类是引用类型"><a href="#类是引用类型" class="headerlink" title="类是引用类型"></a>类是引用类型</h4><p>数组，也是引用类型</p><p>java中的引用类型有很多，只要你定义了一个类，就多了一个引用类型</p><p>引用类型变量的赋值，只是将对象的首地址存入变量中</p><h3 id="this引用："><a href="#this引用：" class="headerlink" title="this引用："></a>this引用：</h3><p>this可以出现非static的方法、构造器中。作用如下：</p><ol><li>出现非static方法中，this代表了该方法的调用者。<br>“谁调用该方法，this就代表谁”</li><li>出现在构造器中，this就代表该构造器正在初始化的对象。</li></ol><p>this.     的很重要作用就是：用于区分方法或构造器的局部变量。</p><p>尤其是与成员变量同名时——更需要使用this进行区分。</p><h2 id="方法详解："><a href="#方法详解：" class="headerlink" title="方法详解："></a>方法详解：</h2><h3 id="方法的所属性："><a href="#方法的所属性：" class="headerlink" title="方法的所属性："></a>方法的所属性：</h3><ol><li>方法类似于函数。但与函数不同的是，方法不能存在，方法必须定义在类里面。</li><li>定义在类中的方法。从逻辑上来看：<br>如果该方法有static修饰，该方法属于类本身，应该用类调用。<br>如果该方法无static修饰，该方法属于对象本身。</li><li>方法不能独立执行。<br>方法一定要有调用者<br>【规则】如果你调用同一个类中方法，可以省略调用者，此时系统会添加默认的调用者。<pre><code>           如果该方法是无static的方法，添加this作为默认的调用者。</code></pre></li></ol><h3 id="形参个数可变的方法："><a href="#形参个数可变的方法：" class="headerlink" title="形参个数可变的方法："></a>形参个数可变的方法：</h3><p>类型… 形参名 ：这就是形参个数可变的方法</p><ul><li>本质就是数组。上面写法等同于：<br>类型[] 形参名</li><li>类型…<br>写法的好处是：调用方法时更加方便。即可直接传入多个元素，系统会自动将它们封装成数组。也可用数组。<br>写法的缺点是：类型…  这种写法只能作为形参列表的最后一个形参。<pre><code>                       【暗示】：一个方法最多只能有一个“个数可变”的形参</code></pre></li></ul><h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><p>方法里调用本身——递归带来了隐式循环。</p><p>递归要避免无限递归。一定要在某些情况下，不再调用方法自身，</p><p>这个时候可能就要说了，这些循环用for之类的循环分支语句不都是可以实现的吗？</p><p>对对对，你说的都对，但是有一种情况只能用递归哦    </p><p>假如我们有：</p><p>f(1) = 2;</p><p>f(2) = 5;</p><p>…</p><p>f(n) = f(n+2) - 2 *  f(n+1)</p><p>要计算：f(10)是多少//代码在40/Recursive   </p><p>【难点】：    要保证递归一定能出现递归结束的条件。</p><h3 id="方法重载："><a href="#方法重载：" class="headerlink" title="方法重载："></a>方法重载：</h3><p>在同一个类中有多个同名的方法，但这多个方法的形参列表不同</p><p>口诀：两同一不同</p><ul><li>修饰符不同不算重载；返回值类型不同也不算重载</li><li>当你要确定一个方法的时候，仅有方法名是不够的的，必须还要结合参数才能确定。</li></ul><h3 id="方法的传参机制："><a href="#方法的传参机制：" class="headerlink" title="方法的传参机制："></a>方法的传参机制：</h3><p>如果定义方法时声明了形参，调用方法时必须传入对应的方法</p><p><strong>Java的参数传递机制：值传递 ，传入的只是参数的副本，并不是参数本身！！！</strong></p><ul><li>如果传递的参数是基本参数，方法中对参数所做的修改 ，完全不会影响参数本身！</li><li>如果传递的参数是引用类型，参数的副本与参数本身指向同一个对象。<br>因此方法通过参数副本修改对象时，会影响参数本身所指向的对象</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java速记——类与对象&quot;&gt;&lt;a href=&quot;#Java速记——类与对象&quot; class=&quot;headerlink&quot; title=&quot;Java速记——类与对象&quot;&gt;&lt;/a&gt;Java速记——类与对象&lt;/h1&gt;&lt;p&gt;面向对象：Java是一门面向对象的语言&lt;/p&gt;
&lt;p&gt;类：某
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java速记——类型转换</title>
    <link href="https://mr8god.cn/2020/04/09/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>https://mr8god.cn/2020/04/09/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-04-09T07:49:15.000Z</published>
    <updated>2020-04-14T16:04:42.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java速记——类型转换"><a href="#Java速记——类型转换" class="headerlink" title="Java速记——类型转换"></a>Java速记——类型转换</h1><p>整形的注意点，</p><ol><li>直接给出一个整形整数值，该整数值默认为int型，但如果该整数位于byte、short的取值范围内，Java也可以直接把整数值当做byte、short处理，</li><li>如果你希望一个整数被当成long处理，必须在整数后添加L或者l。</li><li>整数有4种表达形式：<ol><li>十进制：常用。</li><li>八进制：以0开头，数值不超过7。</li><li>16进制：以0x或0X开头，数值不能超过F、a代表10、b代表11……f代表15。</li><li>二进制：以0b或0B开头，数值不能超过1。</li></ol></li></ol><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="自动转化：取值范围小的，自动转化为取值范围大的"><a href="#自动转化：取值范围小的，自动转化为取值范围大的" class="headerlink" title="自动转化：取值范围小的，自动转化为取值范围大的"></a>自动转化：取值范围小的，自动转化为取值范围大的</h3><p>byte&gt;short&gt;int &gt; long&gt; float&gt;double</p><p>​            char可以转化为int</p><p>每个字符都是有一个编号，计算机只存编号</p><p>short：-32768~+32768</p><p>char:0-65535</p><p>声明变量：</p><p>​            类型 变量[ = 初始值 ]；</p><p>类型 byte，</p><p>自动转化几条规则：</p><ol><li>所有整型都可以自动转成浮点型</li><li>所有整型都可以自动转化为long型</li><li>所有数值型，都可以自动转成double型</li></ol><p>记一下常识性的东西</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\r  <span class="number">13</span></span><br><span class="line"></span><br><span class="line">\n  <span class="number">10</span></span><br><span class="line"></span><br><span class="line">\t<span class="number">9</span></span><br><span class="line"></span><br><span class="line">\<span class="string">'39</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">\''</span><span class="number">34</span></span><br></pre></td></tr></table></figure><h3 id="强制转化："><a href="#强制转化：" class="headerlink" title="强制转化："></a>强制转化：</h3><p>上图上反过来转换，就需要强制转换</p><ol><li>浮点数转整数，砍掉小数部分</li><li>强制转换可能发生“溢出”</li></ol><h3 id="表达式类型的自动提升"><a href="#表达式类型的自动提升" class="headerlink" title="表达式类型的自动提升"></a>表达式类型的自动提升</h3><p>整个表达式的类型，与该表达式中最高等级的操作数的类型相同</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>算术运算符（7个）</p><p>+、-、*、/、%</p><p>++ ：将单个变量的值+1</p><p>​        放在变量之后，表示先用变量的值，再自加</p><p>​        放在变量之前，表示先自加，在用变量的值</p><p>—：将单个变量的值-1</p><p>​        放在变量之后</p><p>对于一些复杂运算需要使用math </p><h4 id="赋值运算符："><a href="#赋值运算符：" class="headerlink" title="赋值运算符：="></a>赋值运算符：=</h4><p>将=右边的值装入左边的容器（变量）</p><p>=左边只能是变量</p><p>=右边可以是任何复杂的表达式</p><p>大部分时候= 右边往往都是复杂的表达式</p><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>$&gt;$</p><p>$&gt;=$</p><p>$&lt;$</p><p>$&lt;=$</p><p>$==$</p><p>$~=$</p><p>比较运算符，用于比较两个变量或两个值，如果符合预期得到true，否则得到false</p><h4 id="逻辑运算符："><a href="#逻辑运算符：" class="headerlink" title="逻辑运算符："></a>逻辑运算符：</h4><p>只能对boolean值进行运算。</p><p>&amp;&amp;        与</p><p> &amp;</p><p>||        或</p><p>|</p><p>！        非</p><p>^            </p><p>两个条件相同则为false；不同则为true</p><p>富 美</p><p>既富，也美 - and</p><p>富或美  </p><p>短路与和与的区别：如果第一个操作数已经是false，&amp;&amp;运算符不会算第二个操作数，称之为短路。</p><p>​                                    如果第一个操作数已经是false，&amp;运算符依然会计算第二个操作数，称之为不短路</p><p>||和|的区别：同理如短路与！</p><p>一般来说，编程时都用短路与和短路或</p><h4 id="位运算符："><a href="#位运算符：" class="headerlink" title="位运算符："></a>位运算符：</h4><p>它只能对整型（byte、short、int、long、char（0~65535））运算</p><p>负数的进制码：保存的是它的补码</p><p>原码：数，直接算出来叫原码。最高位，又叫做符号位，0代表正数；1代表负数</p><p>反码：除符号位之外，其他位都按位取反</p><p>补码：反码+1。</p><ol><li><p>&amp;：按位与。上下两位都是1时，得到的结果才是1。</p></li><li><p>|：按位或。上下两位有一个1时，得到的结果就是1。</p><p>与位运算符相当常用，当表示状态时，会用特定的数代表开关。文本状态：粗体（1）、斜体（2）、下划线（4）、中划线（8）。就可以靠位与运算符进行控制。</p><p>所有涉及到开关的设计都会用到位于运算符</p></li><li><p>~：按位取反，正数变成负的（绝对值+1），负数变为正的（绝对值-1）。可以通过数学定理证明</p></li><li><p>^：按位异或。上下两位相同时，得到的结果是1.不同的时候，得到的结果为0.</p></li><li><p>&lt;&lt;：左移。左移N位相当于乘以2的N次方</p><p>2乘以8，最快的算法：2&lt;&lt;3</p></li><li><p>$&gt;&gt;$：右移N位，就是除以2的N次方，会砍掉小数，所以在除不尽的情况下，结果会比实际结果略小</p></li><li><p>$&gt;&gt;&gt;$：无符号右移。不太常用<br>如果被移的数是正数，那么该运算符与$&gt;&gt;$运算符效果一样<br>如果被移的数是负数，被空出来的数高位高位总是补0——这个数就会变成正数。</p></li></ol><h4 id="扩展的赋值运算符："><a href="#扩展的赋值运算符：" class="headerlink" title="扩展的赋值运算符："></a>扩展的赋值运算符：</h4><p>a  += b;        a = (类型)（a + b),这种更加好用，因为他可以自动强制转换为原先的类型。</p><p>所以推崇这种写法。</p><p>a -= b             a = (类型)（a - b)</p><p>……………………</p><p>基本上，前面介绍的所有双目运算符都可以和=结合，形成扩展的赋值运算符</p><h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><p>逻辑表达式？ 值1：值2</p><p><strong>常用的是三目运算符的嵌套</strong>！！！</p><p>嵌套后的三目运算符可能返回3个，甚至于更多值的其中之一</p><h4 id="运算符的结合性和优先级"><a href="#运算符的结合性和优先级" class="headerlink" title="运算符的结合性和优先级"></a>运算符的结合性和优先级</h4><p>结合性：控制运算符的运算方向：从左到右？还是从右到左？</p><p>大部分运算符都是从左到右。=运算符是从右到左的</p><p>推荐，记不清的时候，用括号来保证优先级</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol><li>变量定义、复制（简单值、表达式）</li><li>8个基本类型：byte、short、int、long、float、double、char、boolean</li></ol><p>运算符</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ol><li>顺序结构：从上到下、逐行执行</li><li>分支结构：根据具体情况，做出判断</li><li>循环结构：根据条件，让一个或多个步骤<strong>重复</strong>执行很多次</li></ol><p>目前可能存在的问题：</p><ol><li>语法掌握其实并不熟练</li><li>缺乏正确的程序员思维</li></ol><h3 id="顺序结构："><a href="#顺序结构：" class="headerlink" title="顺序结构："></a><strong>顺序结构</strong>：</h3><p>不加什么控制，程序代码都是从上到下，依次执行</p><h3 id="分支结构："><a href="#分支结构：" class="headerlink" title="分支结构："></a><strong>分支结构</strong>：</h3><p>不加什么控制，程序代码都是从上到下，依次执</p><h4 id="if分支："><a href="#if分支：" class="headerlink" title="if分支："></a>if分支：</h4><h5 id="两个注意点："><a href="#两个注意点：" class="headerlink" title="两个注意点："></a>两个注意点：</h5><ol><li>如果条件执行体只有一条语句，条件执行体的花括号可以省略。<br>如果省略了花括号，<strong>if条件只控制到紧跟if条件的第一个分号。</strong></li><li>else。否则，就是对前面条件取反<br>建议：如果if语句中有多个else if块，一定要先处理范围小的条件</li></ol><h4 id="switch分支："><a href="#switch分支：" class="headerlink" title="switch分支："></a>switch分支：</h4><p>switch(表达式){</p><p>​    case 值1：</p><p>​                    执行体</p><p>​                    break；</p><p>​    case 值2：</p><p>​                    执行体</p><p>​                    break;</p><p>…………………………</p><p>​    default:</p><p>​                    执行体</p><p>​                    brake;</p><p>}</p><p>程序会计算switch表达式的值，表达式的值等于哪个case块，就执行哪个case块。</p><p>如果都不等于，就执行default块</p><p>Java的switch不能处理范围！</p><h5 id="两个注意点：-1"><a href="#两个注意点：-1" class="headerlink" title="两个注意点："></a>两个注意点：</h5><ol><li>switch分支的表达式之鞥是byte、char、short、int、枚举、Strin（从java7开始才可以）这六个类型。</li><li>如果不写break，会发生贯穿，<br>贯穿：java会从第一个匹配的case块开始执行，在遇到break之前，直接忽略case值执行每个case块的代码</li></ol><h3 id="循环分支"><a href="#循环分支" class="headerlink" title="循环分支"></a>循环分支</h3><h4 id="while循环："><a href="#while循环：" class="headerlink" title="while循环："></a>while循环：</h4><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><p>while(条件){</p><p>​        // 循环体</p><p>}</p><p>程序首先判断循环条件，如果循环条件为true，执行循环体；</p><p>循环体执行完后，再次判断循环条件，如果循环条件Wietrue，执行循环体；</p><p>直到最后一次判断，循环条件为false，结束循环。</p><p>循环条件执行次数 == 循环体执行次数 + 1</p><p>死循环：无限循环，永远不会停止的循环。</p><h5 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h5><ol><li><p>如果循环体只有一条语句，那么循环体 的花括号可以省略</p><p>如果省略了花括号，while条件只控制到紧跟while条件的第一个分号。</p></li></ol><h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h4><h5 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h5><p>do{</p><p>​    // 循环体</p><p>}while (条件)</p><p>程序先执行一次循环体。</p><p>循环体执行完之后，再次判断循环条件，如果循环条件为true，执行循环体；</p><p>知道最后一次判断，循环条件为false，结束循环。</p><p>循环条件执行次数 == 循环体执行次数</p><h5 id="特征：即使循环条件开始就是false，循环体也会执行一次。"><a href="#特征：即使循环条件开始就是false，循环体也会执行一次。" class="headerlink" title="特征：即使循环条件开始就是false，循环体也会执行一次。"></a>特征：即使循环条件开始就是false，循环体也会执行一次。</h5><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><p>语法：</p><p>for([初始化语句]; [循环条件] ; [迭代语句]){</p><p>​        // 循环体</p><p>}</p><p>所有循环开始前，先执行初始化语句，只执行一次。</p><p>程序判断循环条件，如果循环条件为true，执行循环体；</p><p>循环体执行完后，执行迭代语句，然后再次判断循环条件 ，如果循环条件为true，执行循环体</p><h5 id="for循环的几个用法："><a href="#for循环的几个用法：" class="headerlink" title="for循环的几个用法："></a>for循环的几个用法：</h5><ol><li><p>for循环中，只有两个分号是必须的，其他都是可以省略的。</p><p>如果省略循环条件，循环条件永远都是true。</p><p>一定要写条件语句，不写的话就是死循环了。</p></li><li><p>尽量不要在循环体内改变循环计数器的值</p></li><li><p>初始化语句也可以初始化多个变量，只要它们的数据类型相同即可。<br>迭代语句也可以有多条，多条迭代语句之间用逗号隔开即可。</p></li></ol><h4 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h4><p>循环里再次放置循环，此时里层循环相当于外层循环的一条语句</p><h4 id="break终止结束"><a href="#break终止结束" class="headerlink" title="break终止结束"></a>break终止结束</h4><p>结束循环，跳出循环，break可以带标签，用于结束标签所代表的循环</p><h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p>忽略本次循环continue后面的语句，重新开始执行下一次循环</p><p>所以：不带标签的continue语句，如果是循环体的最后一行，那是没有任何意义的</p><p>continue可以带标签，用于忽略标签所代表的循环，重新开始下一次标签所代表的循环</p><h4 id="return"><a href="#return" class="headerlink" title="return"></a>return</h4><p>结束方法</p><p>循环总是位于方法中的，return既然可以结束方法，无论他在多深的循环里，他可以直接结束</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java速记——类型转换&quot;&gt;&lt;a href=&quot;#Java速记——类型转换&quot; class=&quot;headerlink&quot; title=&quot;Java速记——类型转换&quot;&gt;&lt;/a&gt;Java速记——类型转换&lt;/h1&gt;&lt;p&gt;整形的注意点，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直接给出一个整形整
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java深耕——初章</title>
    <link href="https://mr8god.cn/2020/04/09/Java/Java%E6%B7%B1%E8%80%95/Java%E6%B7%B1%E8%80%95%E2%80%94%E2%80%94%E5%88%9D%E7%AB%A0/"/>
    <id>https://mr8god.cn/2020/04/09/Java/Java%E6%B7%B1%E8%80%95/Java%E6%B7%B1%E8%80%95%E2%80%94%E2%80%94%E5%88%9D%E7%AB%A0/</id>
    <published>2020-04-09T07:49:15.000Z</published>
    <updated>2020-04-14T15:51:25.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java——初章"><a href="#Java——初章" class="headerlink" title="Java——初章"></a>Java——初章</h1><p>Java是一种面向对象编程(OOP)的语言。<br>掌握Java需要付出的代价就是，思考对象的时候，需要采用 形象思维（一种抽象思维），而不是程序化的思维。<br>特别是在尝试创建可重复使用（可再生） 的对象的时候，我们都会面临着一项痛苦的抉择。<br>事实上，正是由于这样的特性，很难有人能够设计出完美的东西，只有一些Java的编程专家才能编写出可以让大多数人使用的代码，而我江某人学习编程的目的就在于此，成为编程专家。</p><p>初章主要是描述了Java的多项设计思想，并从概念上解释面向对象的程序设计。</p><h2 id="抽象概念的由来"><a href="#抽象概念的由来" class="headerlink" title="抽象概念的由来"></a>抽象概念的由来</h2><h3 id="抽象方法是怎么出现的呢？"><a href="#抽象方法是怎么出现的呢？" class="headerlink" title="抽象方法是怎么出现的呢？"></a>抽象方法是怎么出现的呢？</h3><p>​        起因是我们在解决实际问题的时候发现每一类问题都有其自己的特征。而我们在C或一切其他语言中学到的都只是根据一类问题设计一套方法来解决它。以至于当超出这个问题的时候，方法就会显得特别笨拙。<br>​        面向对象的程序设计就是在以上基础跨出一大步。我们利用一些概念去描述表达实际问题中的元素。我们利用“<strong>对象</strong>”这个概念建立起实际问题和方法之间的联系。如果一些问题在后期出现了更多的问题，我们就可以相应的在代码中加入其它对象<br>通过添加新的对象类型，程序可以灵活的进行调整。与特定的问题打配合。从而达到解决问题的目的。<br>​        毫无疑问，<strong>面向对象程序设计语言</strong>是一门灵活、强大的语言抽象方法。它允许我们<strong>根据问题来描述问题，而不是单纯地根据方案。</strong></p><h4 id="OOP面向对象程序设计的特征"><a href="#OOP面向对象程序设计的特征" class="headerlink" title="OOP面向对象程序设计的特征"></a>OOP面向对象程序设计的特征</h4><p>通过上面讲述的这些特征，我们可以理解“纯粹”的面向对象程序设计方法是什么样子的：<br>(1)    所有东西都是对象。可以将对象想象成一种新型变量；它保存着数据，但可要求它对它自身进行一些操作，比如说增加点方法，增加点变量。理论上来讲，我们可以从问题中找出所有概念性的东西，然后在我们的程序中将其表达为一个对象。</p><p>(2)    程序将会是一大堆对象的组合；通过对象与对象之间的消息传递（传参），各个对象都知道自己该干什么，不该干什么。为了向另外一个对象发出请求，就需要向那个对象发送消息。<strong>具体来讲</strong>，我们可以将消息想象为一个调用请求，它调用的是从属于目标对象的一个子例程或函数。</p><p>(3)    每个对象都有自己的存储空间，可以容纳其他对象。或者是通过封装现有对象，进而制造出新的对象。所以尽管先前我们讲的对象看起来很简单，其实在每一个程序中，这些概念都能上升到一个任意高的复杂程度。</p><p>(4)    每个对象都有一种类型。根据Java的基本语法，每个对象都是某一个“类”的一个“实例”。而不同类与类之间的区别是什么呢？我抽象地讲，是“<strong>能将什么消息发给它？</strong>”</p><p>(5)    <strong>同一类的所有对象都能接收相同的消息。</strong>举例子举例子，这边有圆（Circle）、形状（Shape）两个类。由于圆其实也是形状嘛，我可以这样说，圆（Circle）的一个对象也属于类型为形状（Shape）的一个对象，所以一个圆能够完全接收来自形状（Shape）的任意消息。这就意味着我们可以让程序代码统一指挥形状（Shape），令其自动控制所有符合形状（Shape）描述的对象，其中自然包括圆（Circle）类的那个对象。这一特性叫做对象的”可替换性“，是OOP最重要的概念之一。</p><h2 id="对象的接口"><a href="#对象的接口" class="headerlink" title="对象的接口"></a>对象的接口</h2><p>上头我已经为大家引入了类与对象的概念，其实很好理解。类就相当于一样东西，比如说程序员就是一类。而对象呢，按照程序员类来说，这边的对象就是具体的一个程序员，比如说我江某人，就是一个程序员类的对象。</p><p>​        每一个对象都隶属于一个特定的“类”，那个类具有自己的通用特征与行为。</p><p>​        我们该如何让对象完成真正有用的工作呢？比如说让我江某人程序员对象完成一个C++的代码工作。我们可以在类中定义“<strong>接口</strong>”，对象的“类”就规定了它的接口形式。“类”和“接口”的等价或对应关系就是面向对象程序设计的基础。</p><p>​        下面来一个图解</p><p><img src="https://i.loli.net/2020/04/11/MvF6VlU21SKIfdh.jpg" alt="接口的讲解.jpg"></p><p>在上面这个图解中，，类的名字叫做Light，我们可以向Light对象发出的请求包括有打开（on）、关闭（off）、变得更明亮（brighten）、变得更黯淡（dim）。我们可以简单地声明一个名字（lt），我们为Light对象创建了一个“句柄”（就是名字，咱们对象的名字，在这边名字就叫做lt），这里边lt，也就是咱们的句柄，指向了刚刚新建的对象。然后我们用new关键字新建类型为Light的一个对象。再用等号将其赋值给句柄。</p><p>​        为了向对象发送一条消息，我们使用下面的格式来将句柄名、句点符号、和消息名称（on、off之类的）连接起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lt.on();</span><br></pre></td></tr></table></figure><h2 id="实现方案的隐藏"><a href="#实现方案的隐藏" class="headerlink" title="实现方案的隐藏"></a>实现方案的隐藏</h2><p>这部分我将谈谈我们为什么要隐藏我们的类成员，类中的方法</p><p>​        首先我想就程序员的分类来讲，目前使用面向对象程序设计语言的程序员主要是分为两类的，一类是类的创建者，一类是类的使用者。前者制造出了包含各种使用的类包，后者会用前者的类包，解决各种问题。</p><p>​        这个时候，我们就需要考虑一个问题了，类创建者创建的类包里不能所有东西都能被使用者调用呀。如果任何人都能使用一个类的所有成员，那么使用者就可以对那个类做出任何事情。即使是一些不能够给使用者使用的类内包含的一些成员。如若不能进行控制的话，就没有办法组织这一情况的发生。</p><h3 id="为啥要控制类中成员的访问权限呢？"><a href="#为啥要控制类中成员的访问权限呢？" class="headerlink" title="为啥要控制类中成员的访问权限呢？"></a>为啥要控制类中成员的访问权限呢？</h3><p>综上，我们有两方面的原因促使我们需要对类中成员的访问权限进行控制。<br>原因一：防止使用者程序员接触他们不该接触的东西——通常是一些内部数据类型的设计思想。若只是为了使用类包解决问题，用户只需要操作接口就行了，不需要明白这些信息。我们向用户提供的实际是一种服务。<br>原因二：允许类包设计人员修改内部结构，不用担心它对使用者程序员造成影响。假如我们（类设计程序员）最开始写了一个简单的类包，以便简化开发。以后又决定进行改写，使其更快地运行。若接口与实现方法早已经隔离开了，并分别受到保护，就可以放心做到这一点。</p><h3 id="Java如何实现控制呢？"><a href="#Java如何实现控制呢？" class="headerlink" title="Java如何实现控制呢？"></a>Java如何实现控制呢？</h3><p>Java采用三个显式（明确）关键字以及一个隐式（暗示）关键字来设置类边界：public、private、protected 以及暗示性的friendly。若未明确指定其他关键字，则默认为后者。</p><p>解释这些关键字：</p><p>public（公共）：意味着后续的定义，任何人均可使用。<br>private（私有）：意味着除您自己、类型的创建者以及那个类型的内部函数成员之外，其他任何人都不能访问后续的定义信息。private在类创建者和类使用者之间竖起了一堵墙。若有人试图调用，便会在编译期报错。<br>friendly（友好的）涉及“包装”或“封装”（Package）的概念——即Java用来构建库的方法。若某样东西是“友好的”，意味着它只能在这个包装的范围内使用（所以这一访问级别有时也叫做“包装访问”）<br>protected（受保护的）：与“private”相似，只是一个继承的类就可以访问咱们的受保护成员，但是依旧不能访问私有成员。</p><h2 id="方案的重复使用"><a href="#方案的重复使用" class="headerlink" title="方案的重复使用"></a>方案的重复使用</h2><p>创建并测试好一个类后，这个好不容易创建好的类其实往往有很多缺点。只有较多经验以及洞察力的人才能 设计出一个好的方案。</p><p>​        为了重复使用一个类，最简单的方法就是仅直接使用那个类的对象。同时也将那个类的一个对象植入一个新类中。我们把这叫做“创建一个成员对象”。新类可以由任意数量和类型的其他对象构成。这个概念叫做“组织”——在现有类的基础上组织一个新类。有时组织也称为“包含”关系，比如“一辆车包含了一个变速箱”</p><p>​        对象的组织具有极大的灵活性。新类的“成员对象”通常设为“私有”，使用这个类的使用者程序员不能访问它们。</p><h2 id="继承：重新使用接口"><a href="#继承：重新使用接口" class="headerlink" title="继承：重新使用接口"></a>继承：重新使用接口</h2><p>当我们费尽心思做出一种数据类型之后，加入不得不又新建一种类型，令其实现大致相同的功能，那会是一件很麻烦的事情。但是若能利用已有的数据类型，对其进行“克隆模仿”，再根据实际情况进行添加或修改，那情况就会好多了。“继承”正是针对这个目标而设计的。但是继承并不完全等价于克隆。在继承的过程中，如果父类发生了变化，子类（继承后产生的新类）也会反映出这种变化。</p><p>在Java中继承是通过extends关键字实现的。使用继承时，相当于创建了一个新类。这个新类不仅包含了现有类型的所有成员（除了不能被访问的private成员）。其中最最重要的是它还复制了父类的接口。也就是说，能向父类发送的消息，亦可原样发给子类的对象。</p><p>由于父类和子类拥有相同的接口了，但是我们的子类不能一模一样呀，那样还跟父类有什么区别？为了做出区分，所以那个接口也必须进行特殊的设计。下面讲一下两种区分父类和子类的方法：</p><h3 id="区分父类子类的方法"><a href="#区分父类子类的方法" class="headerlink" title="区分父类子类的方法"></a>区分父类子类的方法</h3><p><strong>方法一</strong>：为子类添加新函数（功能）。这些新函数并非父类接口的一部分。为什么会有这种方法的出现呢？一般是因为我们发现父类原有的功能已经不能满足我们的需求了，于是我们就要添加更多的函数。这是一种最简单最基本的继承用法。</p><p><strong>方法二</strong>：近看extends关键字看上去是让我们要为接口“扩展”新功能，但实情并非肯定得照办。为了区分我们的新类，第二个办法就是改变父类，“改善”父类。</p><h3 id="改善父类"><a href="#改善父类" class="headerlink" title="改善父类"></a>改善父类</h3><p>为了改善一个父类，我们无非就是改善父类中的函数（或者叫方法），那么我们相应的只需要在子类中的函数中建立一个新的定义就可以了。我们的目标是：”尽管使用的函数接口未变，但他的新版本具有不同的表现“，但是万物没有这么绝对，我们还有另外情况，这边引用两个概念：<strong>等价关系</strong>和<strong>类似关系</strong></p><p>等价关系：子类完全照搬父类的所有的东西<br>类似关系：我们在子类中新加入了新的东西，那是原来父类中没有的东西。新的子类依旧拥有旧的父类的接口，但也包含了其他一些新的东西。所以就变成了不是上面所说的那种“等价关系”。</p><p>举一个例子：假定我有一个房间，房间连好了用于制冷的各种控制装置，用程序员思维来看，就是说我们已经拥有了必要的“接口”来控制制冷。现在假设我们的制冷机坏掉了，于是我将它换成了一台新型的冷、热两用空调，冬天制热、夏天制冷嘛。冷热空调“<strong>类似</strong>“制冷机，但是能做更多的事情。但是呢，由于我们的房间只安装了控制制冷的设备”<strong>接口</strong>“，所以”<strong>接口</strong>“们只能同新机器的制冷部分打交道。新机器的接口已得到扩展，但现有的系统并不知情，也不能够接触除了原始接口以外的任何东西。</p><p>当我们明确了等价和类似两种概念之后，以后在面对情况的时候就可以合理选择了。</p><h2 id="多形对象的互换使用"><a href="#多形对象的互换使用" class="headerlink" title="多形对象的互换使用"></a>多形对象的互换使用</h2><p>继承的结果往往会是创造了一系列的类，而这所有的类都是建立在统一的接口基础上的。如图</p><p><img src="https://i.loli.net/2020/04/11/DlvLfm5qPKnFzpX.jpg" alt="向上转型的形象描述.jpg"></p><p>这边要讲一个很重要的概念了哈，我们一定要把子类的对象当做父类的对象来对待。这一点是非常重要的。这就意味着我们只需编写代码就行了，不需要注意类的特定细节，只与父类打交道。</p><p>根据图例我们可以看到通过集成，这边有三个子类。那么我们为三个子类新编写的代码也会像在父类中那样良好工作。所以说程序具备了“扩展能力”，具有扩展性。</p><p>假设我们新加了一个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doStuff</span><span class="params">(Shape s)</span>&#125;</span>&#123;</span><br><span class="line">s.erase();</span><br><span class="line"><span class="comment">// 等等等等等</span></span><br><span class="line">s.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一个函数可以用途任何“几何形状”（Shape）通信，例如我这边又安排了一个代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Circle c = <span class="keyword">new</span> Circle();</span><br><span class="line">Triangle t = <span class="keyword">new</span> Triangle();</span><br><span class="line">Line l = <span class="keyword">new</span> Line();</span><br><span class="line">doStuff(c);</span><br><span class="line">doStuff(t);</span><br><span class="line">doStuff(l);</span><br></pre></td></tr></table></figure><p>这边我就分析一下doStuff(c)这串代码的意思（事实就是：我确实后边安排了这个代码）<br>此时，一个Circle句柄传递给了一个本来期待Shape句柄的函数。但是由于咱们的圆也是一种几何形状，所以doStuff()能够正确地进行处理。也就是说，凡是doStuff()能发给一个Shape的消息，Circle也能接收。所以这样子写是正确的，不会有报错。</p><p>我们把这种生成子类的方法叫做向上转型。向上是因为继承的方向是从“上面”来的——即父类位于顶部，子类在下方展开。</p><p>注意了哦，doStuff()里面的代码，它并非是这样表达的：”如果你是一个Circle，就这样作；如果你是一个Square，就按照那样做；等等诸如此类“。若那样子写代码的话，得累死你，就需要检查Shape所有可能的类型，如圆、矩形、四边形等等等等。这显然是非常麻烦的，而且每次添加了一种新的Shape类型后，都要相应地进行修改，在这里，我们只需要这样做：”你是一种几何形状，我知道你能将自己删掉（即代码里面的erase()），请自己放手去干吧，并且自己去控制所有的细节吧。“</p><p>这边我写了三个代码有助于我们理解：</p><p>代码一（Shape父类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.shape;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/1120:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        out.println(<span class="string">"我是父类中的draw()方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        out.println(<span class="string">"我是父类中的erase()方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        out.println(<span class="string">"我是父类中的move()方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        out.println(<span class="string">"我是父类中的getColor()方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        out.println(<span class="string">"我是父类中的setColor()方法"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码二（Circle继承类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.shape;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/822:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doStuff</span><span class="params">(Shape s)</span></span>&#123;</span><br><span class="line">        s.erase();</span><br><span class="line">        out.println(<span class="string">"我是来自子类Circle里边的doStuff方法。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码三（ShapeTest类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.shape;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ Mr8god</span></span><br><span class="line"><span class="comment"> * @ 2020/4/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShapeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shape sh = <span class="keyword">new</span> Shape();</span><br><span class="line"></span><br><span class="line">        sh.draw();</span><br><span class="line">        sh.erase();</span><br><span class="line">        sh.move();</span><br><span class="line">        sh.getColor();</span><br><span class="line">        sh.setColor();</span><br><span class="line"></span><br><span class="line">        Circle ci = <span class="keyword">new</span> Circle();</span><br><span class="line">        ci.draw();</span><br><span class="line">        ci.erase();</span><br><span class="line">        ci.move();</span><br><span class="line">        ci.getColor();</span><br><span class="line">        ci.setColor();</span><br><span class="line">        ci.doStuff(ci);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自此输出：</p><p><img src="https://i.loli.net/2020/04/11/C8uPNOlLZbco4G7.jpg" alt="向上转型代码的输出.jpg"></p><h2 id="如何实现控制访问"><a href="#如何实现控制访问" class="headerlink" title="如何实现控制访问"></a>如何实现控制访问</h2><p>Java用三个关键字在类的内部设定边界：public、private、protected。这些访问指定词决定了紧跟其后被定义的东西可以被谁使用。</p><p>public：表示紧随其后的元素对任何人都是可用的</p><p>private：这个关键字表示除类型创建者和类型的内部方法之外的其他任何人都不能访问的元素。private就像你与使用类的程序员之间的一堵墙，如果有人试图访问private成员，就会在编译期间得到错误信息。</p><p>protected：这个关键字与private作用相当，差别仅在于继承的类可以访问protected成员，但是不能访问private成员。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java——初章&quot;&gt;&lt;a href=&quot;#Java——初章&quot; class=&quot;headerlink&quot; title=&quot;Java——初章&quot;&gt;&lt;/a&gt;Java——初章&lt;/h1&gt;&lt;p&gt;Java是一种面向对象编程(OOP)的语言。&lt;br&gt;掌握Java需要付出的代价就是，思考对象
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java速记——final变量</title>
    <link href="https://mr8god.cn/2020/04/08/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94final%E5%8F%98%E9%87%8F/"/>
    <id>https://mr8god.cn/2020/04/08/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94final%E5%8F%98%E9%87%8F/</id>
    <published>2020-04-08T07:49:15.000Z</published>
    <updated>2020-04-14T15:53:15.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java速记——final变量"><a href="#Java速记——final变量" class="headerlink" title="Java速记——final变量"></a>Java速记——final变量</h1><p>可以修饰变量（各种变量）、方法、类。</p><p>final和abstract是互斥的：永远都不能够同时出现！</p><h2 id="final修饰变量"><a href="#final修饰变量" class="headerlink" title="final修饰变量"></a>final修饰变量</h2><p>作用：该变量被赋初始值之后，不能被重新赋值！<br>            final修饰的变量<strong>必须</strong>被赋值，且只能被赋值<strong>一次</strong></p><h2 id="final修饰成员变量"><a href="#final修饰成员变量" class="headerlink" title="final修饰成员变量"></a>final修饰成员变量</h2><p>普通成员变量（非final的成员变量），程序员可以不显式指定初始值，系统会为之分配默认初始值，初始值分配规则与数组元素的初始值分配规则完全相同！</p><p>final 成员变量，程序员必须显式指定初始值</p><ul><li><p>final实例变量，必须显式指定初始值，<strong>只能指定一次</strong>。<strong>只能在以下三个位置的其中之一指定：</strong></p><ul><li>定义时指定为初始值。</li><li>实例初始化块</li><li>每个构造器都需要显示指定一次初始值</li></ul><p>上面3个位置的本质其实只有一个，就是构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Final</span>实例变量 </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        age = 24;// 这边错误，被final修饰的成员变量不能被赋值两次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们这样写就没有问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Final</span>实例变量 </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line">    &#123;</span><br><span class="line">        age = <span class="number">24</span>;<span class="comment">// 这边错误，被final修饰的成员变量不能被赋值两次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再一个正确示范</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Final</span>实例变量 </span>&#123;</span><br><span class="line">    <span class="comment">// final实例变量必须显式指定初始值，而且只能在3个位置中指定</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> lg;</span><br><span class="line">    <span class="keyword">public</span> Final实例变量()</span><br><span class="line">    &#123;</span><br><span class="line">        lg = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>final类变量，必须显示指定初始值。只能在以下2个位置的其中之一指定：</p><ul><li>定义时指定初始值</li><li></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java速记——final变量&quot;&gt;&lt;a href=&quot;#Java速记——final变量&quot; class=&quot;headerlink&quot; title=&quot;Java速记——final变量&quot;&gt;&lt;/a&gt;Java速记——final变量&lt;/h1&gt;&lt;p&gt;可以修饰变量（各种变量）、方法、类。
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java速记——抽象类和接口</title>
    <link href="https://mr8god.cn/2020/04/08/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <id>https://mr8god.cn/2020/04/08/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-04-08T07:49:15.000Z</published>
    <updated>2020-04-14T15:53:30.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java速记——抽象类和接口"><a href="#Java速记——抽象类和接口" class="headerlink" title="Java速记——抽象类和接口"></a>Java速记——抽象类和接口</h1><ul><li>abstract关键字</li><li>抽象类</li><li>接口</li><li>JDK1.8/1.9接口的新特性</li><li>抽象类和接口的比较</li><li>面向对象的七个原则</li></ul><h2 id="abstract关键字"><a href="#abstract关键字" class="headerlink" title="abstract关键字"></a>abstract关键字</h2><p>主要修饰类和方法<br>一个方法没有方法体，就是抽象方法了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAbstract</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类包含了抽象方法，那么这个类必须就是抽象类</p><p>务必要记得，有花括号就是方法体。是一个方法声明占位，具体实现留待子类覆盖/重写</p><p>如果类里边没有抽象方法，类也可以是抽象类——抽象类可以没有抽象方法</p><p>抽象类不能够使用new初始化对象；如果我不想让别人实例化我的类，就可以采用抽象类的方法。</p><p>举个例子：目前我们所学的Calendar类就是一个典型的抽象类，她只有一个静态方法——getInstance()——作用：根据当前的Date获得日历对象。</p><p>全局变量是强耦合为什么不好的一个典型的例子，比如你修改了全局变量的类型，则所有使用该变量的代码会受到影响，因此必须检查、修改和重新测试所有这些代码。不仅如此，所有使用该变量的方法都将通过该变量而彼此耦合</p><p>我们要<strong>适度耦合</strong></p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Java中，接口有两种意思：</p><ol><li>是指概念性的接口，即指系统对外提供的所有服务，类的所有能够被外部使用者访问的方法构成了类的接口</li><li>是指用interface关键字定义的实实在在的接口哦，也称为接口类型</li></ol><p>interface：不怎么提属性，操作，只提这个对象对外提供的功能<br>举例：电视机（按钮接口、红外接口：遥控器）、洗衣机（控制面板、洗衣）</p><p>对于接口来说，只有public、static、final常量，没有实例变量</p><p>JDK1.8之前，一定是抽象方法，不需要使用abstract关键字修饰，接口中的内容可见性默认是public，无论是否用public</p><p>类和接口之间要使用implements关键字（UML：实现realization），意味着类实现了某个接口，类就有这个接口的功能了</p><h3 id="接口的作用"><a href="#接口的作用" class="headerlink" title="接口的作用"></a>接口的作用</h3><ul><li>声明期望实现一个或更多的类的方法</li><li>确定对象的编程接口而无需显示类的实际主体</li><li>捕捉非相关类之间的相似性而无需强制类的关系</li><li>通过声明实现几个接口的类来模拟多重继承</li></ul><h2 id="JDK8的新特性"><a href="#JDK8的新特性" class="headerlink" title="JDK8的新特性"></a>JDK8的新特性</h2><p>增加了默认方法</p><p>如果我们要改接口的话，那么我们使用了接口的所有类都需要更改；</p><p>方法冲突<br>一个类可以实现多个接口，也就是说有可能会发生默认方法冲突</p><ul><li>类中的方法优先级最高</li><li>如果无法根据第一条进行判断，那么子接口的优先级更高；函数签名相同时，优先选择拥有最具体实现的默认方法的接口，即如果B继承了A，那么B就比A更加具体</li><li>最后如果还是无法判断，实现多个接口的类必须<ul><li>创建自己的默认方法，来覆盖重写接口的默认方法</li><li>使用super调用指定接口的默认方法</li></ul></li></ul><h2 id="JDK1-9的新特性"><a href="#JDK1-9的新特性" class="headerlink" title="JDK1.9的新特性"></a>JDK1.9的新特性</h2><p>Java9不仅像Java8一样支持接口默认方法，同时还支持私有方法。<br>在Java9中，一个接口中能定义如下集中变量/方法</p><ul><li>常量</li><li>抽象方法</li><li>默认方法</li><li>静态方法</li><li>私有方法：private</li><li>私有静态方法：private static</li></ul><h2 id="关于抽象类，我再补补课"><a href="#关于抽象类，我再补补课" class="headerlink" title="关于抽象类，我再补补课"></a>关于抽象类，我再补补课</h2><p>abstract（抽象），它只能修饰两个东西：</p><ul><li>方法（抽象方法）</li><li>类（抽象类）</li></ul><p>emmmmm，这边加一个<strong>惨痛经验</strong>，<strong>抽象类的抽象方法，务必不能有方法体</strong><br>这很好理解：我们的抽象类是要给别人去重写的，如果我们给了，那还让人家咋重写，emmmmm，我暂时就这么记了！</p><p>abstract与final是<strong>互斥</strong>的！</p><p> 抽象类的特征：有得有失。<br>抽象类与普通类的区别只有4个字：有得有失。</p><ul><li><p>有得：得到一个新功能：抽象类可以拥有这个抽象方法。</p></li><li><p>有失：抽象类失去了一个功能：创建对象</p></li></ul><h3 id="抽象类必须有构造器"><a href="#抽象类必须有构造器" class="headerlink" title="抽象类必须有构造器"></a>抽象类必须有构造器</h3><p>因为抽象类的主要功能是：派生子类；因为子类的构造器一定会调用父类的构造器一次，因此抽象类必须有构造器。<br>而咱们的final是不能有子类，这就是与abstract互斥的原因啦</p><h4 id="抽象类里边可以没有抽象方法吗？"><a href="#抽象类里边可以没有抽象方法吗？" class="headerlink" title="抽象类里边可以没有抽象方法吗？"></a>抽象类里边可以没有抽象方法吗？</h4><p>可以的！</p><h4 id="抽象类里边能不能没有构造器呀？"><a href="#抽象类里边能不能没有构造器呀？" class="headerlink" title="抽象类里边能不能没有构造器呀？"></a>抽象类里边能不能没有构造器呀？</h4><p>可以的！</p><h4 id="抽象类里边能不能没有初始化块呀？"><a href="#抽象类里边能不能没有初始化块呀？" class="headerlink" title="抽象类里边能不能没有初始化块呀？"></a>抽象类里边能不能没有初始化块呀？</h4><p>可以的！</p><h4 id="抽象类里边能不能有成员变量呀？"><a href="#抽象类里边能不能有成员变量呀？" class="headerlink" title="抽象类里边能不能有成员变量呀？"></a>抽象类里边能不能有成员变量呀？</h4><p>可以的！</p><h4 id="抽象类里边能不能有类变量呀？"><a href="#抽象类里边能不能有类变量呀？" class="headerlink" title="抽象类里边能不能有类变量呀？"></a>抽象类里边能不能有类变量呀？</h4><p>可以的！</p><h4 id="上面开个玩笑哈，只要记住普通类有的，抽象类全都有，只是不能创建对象而已"><a href="#上面开个玩笑哈，只要记住普通类有的，抽象类全都有，只是不能创建对象而已" class="headerlink" title="上面开个玩笑哈，只要记住普通类有的，抽象类全都有，只是不能创建对象而已"></a>上面开个玩笑哈，只要记住普通类有的，抽象类全都有，只是不能创建对象而已</h4><h3 id="抽象方法：只有方法签名，没有方法体的方法"><a href="#抽象方法：只有方法签名，没有方法体的方法" class="headerlink" title="抽象方法：只有方法签名，没有方法体的方法"></a>抽象方法：只有方法签名，没有方法体的方法</h3><p>只有抽象类才能拥有抽象方法，普通类不能有抽象方法</p><p>由于咱们的抽象方法没有方法体，那么很明显这就意味着，抽象方法一定要被子类去重写<br>与此相反的是咱们的final：final的意思是——你可不能重写我的方法哦！ </p><p>抽象方法，一定要交给子类去实现（比如说重写），否则不能调用！</p><h4 id="抽象类的作用"><a href="#抽象类的作用" class="headerlink" title="抽象类的作用"></a>抽象类的作用</h4><ol><li>定义变量。我们的抽象类不能创建实例对象，那么我们的抽象类定义之后要赋值的时候，只能用它的子类的实例。（用子类的实例对父类赋值，这叫做<strong>向上转型</strong>在多态时有学习到这个东西）</li><li>调用类方法和类变量</li><li>派生子类——主要目的</li></ol><h4 id="抽象类派生子类："><a href="#抽象类派生子类：" class="headerlink" title="抽象类派生子类："></a>抽象类派生子类：</h4><p>【得出推论规则】：子类要么重写父类中所有的抽象方法，要么子类也只能是抽象的。</p><h2 id="关于接口，我再补补课"><a href="#关于接口，我再补补课" class="headerlink" title="关于接口，我再补补课"></a>关于接口，我再补补课</h2><h3 id="关于接口的基本知识"><a href="#关于接口的基本知识" class="headerlink" title="关于接口的基本知识"></a>关于接口的基本知识</h3><p>接口相当于一种彻底抽象的类，（其实枚举也类似于一个类）<br>接口体现的是一种规范——要暴露出来供大家遵守的规范。<br>所以接口里的所有东西都用public修饰，不管你写还是不写，始终有public修饰。既然默认都有的话，我们其实可以不用写public修饰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] interface 接口名 extends 父接口1，父接口2，……</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; 没有成员变量，只有常量。默认总是会添加public、static、final修饰。&#x2F;&#x2F; 既然默认都有，我们可以不写</span><br><span class="line">&#x2F;&#x2F; 抽象方法。Java8之后，类方法、默认方法（抽象添加方法体）</span><br><span class="line">&#x2F;&#x2F; 内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口是一种彻底抽象的类，抽象的类的话，那么抽象方法只能存在于抽象类。<br>接口里边只能有抽象方法，现在从Java8之后，接口开始有了类方法、方法体（可以说接口好像是被“污染了”，和以前的语法冲突了），但是呢，为了更大程度的和以前的方法体分开来，于是接口添加了<strong>默认方法</strong>这一概念。其实就是原来的<strong>抽象方法+方法体</strong></p><h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>默认方法就是实例方法，与原来抽象方法的规则完全一样，只不过抽象方法不能加方法体，于是默认方法加上default就可以加方法体了</p><p>接口里不能有初始化块，也不能有构造器</p><p>总结：接口里只有三大成员（常量、抽象方法、内部类）</p><p>接口的修饰符：public、<br>接口是彻底抽象，<strong>不能有final</strong>（final和抽象互斥）<br>抽象已经足够抽象了，因此不需要abstract更抽象了</p><p>【随处哔哔】private只能在类里边的类进行修饰，如果在外边那必是没有意义的呀</p><p>接口名：命名规范基本等同于类名。<br>                接口一般推荐使用形容词。<br>                （看看就好看看就好，我暂时还是看《阿里巴巴开发手册》）</p><h3 id="接口里的成员默认会添加public、static、final修饰"><a href="#接口里的成员默认会添加public、static、final修饰" class="headerlink" title="接口里的成员默认会添加public、static、final修饰"></a>接口里的成员默认会添加public、static、final修饰</h3><h4 id="final的变量初始化"><a href="#final的变量初始化" class="headerlink" title="final的变量初始化"></a>final的变量初始化</h4><p>final修饰的类变量必须在两个地方：定义的时候指定初始值、类初始化块指定初始值</p><p>但是接口里没有类初始化块，所以final修饰的变量（其实也是指定的啦，因为final默认在接口中的常量前面进行修饰的），那么很明显，我们默认用final修饰的变量一定且只能在指定初始值的时候进行指定（=）且进行赋初始值</p><h4 id="final的方法"><a href="#final的方法" class="headerlink" title="final的方法"></a>final的方法</h4><p>因为抽象类中的方法默认都是抽象方法，前头都戴着一定隐形的帽子（“abstract”），所以不用写abstract进行修饰</p><h3 id="接口的前世今生"><a href="#接口的前世今生" class="headerlink" title="接口的前世今生"></a>接口的前世今生</h3><h4 id="Java8以前的接口"><a href="#Java8以前的接口" class="headerlink" title="Java8以前的接口"></a>Java8以前的接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 所有成员变量前默认有public static final</span></span><br><span class="line">    <span class="keyword">int</span> MAX_PRESERVE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认有public abstract ，也就是默认是public abstract void test();</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java8之后的接口（有了main方法之后）"><a href="#Java8之后的接口（有了main方法之后）" class="headerlink" title="Java8之后的接口（有了main方法之后）"></a>Java8之后的接口（有了main方法之后）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前头默认public修饰</span></span><br><span class="line">    <span class="keyword">int</span> MAX_PRESERVE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认有public abstract</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Java8之后可以有static方法，所以就能定义main方法</span></span><br><span class="line">    <span class="comment">// 因此接口也可以直接运行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我再加点东西哈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前头默认public修饰</span></span><br><span class="line">    <span class="keyword">int</span> MAX_PRESERVE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的public可以不写，但是static一定要写，因为不写就成了实例方法了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是类方法，因为我有static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【再随处哔哔】方法重载的规则是：两同一不同</p><ul><li>形参列表不同</li><li>方法名相同</li><li>修饰符不同</li></ul><h3 id="接口有什么用呢？"><a href="#接口有什么用呢？" class="headerlink" title="接口有什么用呢？"></a>接口有什么用呢？</h3><ul><li>定义变量，只能用实现类的实例来赋值（向上转型）</li><li>调用类方法或类变量</li><li>派生实现类</li></ul><h3 id="实现接口的语法是？"><a href="#实现接口的语法是？" class="headerlink" title="实现接口的语法是？"></a>实现接口的语法是？</h3><p>首先我们看一下完整的类的语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 父接口1，父接口2，………</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">// 五大成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，上面的也是实现接口的语法了！嘿嘿嘿</p><p>重写接口中的方法只能用public修饰！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java速记——抽象类和接口&quot;&gt;&lt;a href=&quot;#Java速记——抽象类和接口&quot; class=&quot;headerlink&quot; title=&quot;Java速记——抽象类和接口&quot;&gt;&lt;/a&gt;Java速记——抽象类和接口&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;abstract关键字&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java速记——包装类</title>
    <link href="https://mr8god.cn/2020/04/07/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <id>https://mr8god.cn/2020/04/07/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E5%8C%85%E8%A3%85%E7%B1%BB/</id>
    <published>2020-04-07T07:49:15.000Z</published>
    <updated>2020-04-14T15:54:26.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java速记——包装类"><a href="#Java速记——包装类" class="headerlink" title="Java速记——包装类"></a>Java速记——包装类</h1><p>Java有8大基本类型：int、float、double、long、boolean、byte、char、short</p><p>这8个基本类型都不能当成对象使用，不是引用类型，而且也不能接受null值。null值只能赋值给引用类型。</p><p>为了解决上面的问题，Java为8个基本类型提供了对应的包装类——可将它们包装成对象。</p><div class="table-container"><table><thead><tr><th>基本数据类型</th><th>对应的包装类</th></tr></thead><tbody><tr><td>int</td><td>Int</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Char</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>float</td><td>Float</td></tr></tbody></table></div><p><strong>自动装箱</strong>：基本类型的值可以自动当成包装类<br><strong>自动拆箱</strong>：包装类的实例可以自动当成基本类型的值使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关于自动装箱和自动拆箱的代码实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 包装类 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int i = null; // 基本类型不接受null值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2可以自动装箱成Integer</span></span><br><span class="line">        Integer in = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.3自动装箱Double，Double向上转型为</span></span><br><span class="line">        Object ob = <span class="number">2.3</span>;</span><br><span class="line"></span><br><span class="line">        Boolean b = <span class="keyword">true</span>;<span class="comment">// 自动装箱</span></span><br><span class="line"></span><br><span class="line">        Long lg = <span class="number">3L</span>;</span><br><span class="line"></span><br><span class="line">        Long result =  lg * in;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【建议】：做项目的时候，通常来说使用包装类来声明变量。<br>                    好处是：反正基本类型能做的，它都可以做；它还可以当成对象使用。还可以接受null</p><p>包装类的方法：<br>                方法可将字符串转成对应的基本类型值。</p><p>NumberFormatException：要转的字符串不符合数值格式，将会引发该异常。</p><p>当程序对Integer使用自动装箱时，它有一个缓存机制，它会缓存在-128 ~ 127之间的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">heiheihei</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i = <span class="number">20</span>; <span class="comment">// 在-128 ~ 127之间，缓存</span></span><br><span class="line">        Integer j = <span class="number">20</span>; <span class="comment">// 直接用缓存中对象。</span></span><br><span class="line">        System.out.println(i == j);</span><br><span class="line"></span><br><span class="line">        Integer c = <span class="number">204</span>; <span class="comment">// 不在-128 ~ 127之间，不缓存，因为这里边的204超过范围 了</span></span><br><span class="line">        Integer d = <span class="number">204</span>; <span class="comment">// 重新创建</span></span><br><span class="line">        System.out.println(c == d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="两个要被重写的方法："><a href="#两个要被重写的方法：" class="headerlink" title="两个要被重写的方法："></a>两个要被重写的方法：</h2><h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>程序打印对象，或把对象自动转字符串的时候，实际上用的都是该对象的toString()方法的返回值。</p><p>【默认的toString】Object提供的toString返回的是类名@hashCode 方法返回值<br>重写toString：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// toString方法重写实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple123</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参数的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple123</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化全部成员变量的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple123</span><span class="params">(String color, <span class="keyword">double</span> weight)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.color;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">double</span> weight)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWeight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Apple[color="</span> + color</span><br><span class="line">                + <span class="string">", weight="</span> + weight</span><br><span class="line">                + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleTest1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple123 ap = <span class="keyword">new</span> Apple123(<span class="string">"红色"</span> , <span class="number">2.3</span>);</span><br><span class="line">        <span class="comment">// 程序打印对象，或把对象自动转字符串的时候，实际上用的都是该对象的toString()方法的返回值。</span></span><br><span class="line">        <span class="comment">// 下面两行代码是完全相同的</span></span><br><span class="line">        System.out.println(ap);</span><br><span class="line">        System.out.println(ap.toString());</span><br><span class="line"></span><br><span class="line">        Apple123 ap2 = <span class="keyword">new</span> Apple123(<span class="string">"蔡徐坤"</span> , <span class="number">188</span>);</span><br><span class="line">        System.out.println(ap2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任何对象 + ""，就会变成字符串</span></span><br><span class="line">        String str = ap2 + <span class="string">""</span>;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><p>== 如果判断两个引用变量，要求两个引用变量指向同一个对象时，才会返回true。</p><p>但是如果我们直接在main里用equals，还是false，原因是：<br>【默认的equals】Object提供的equals方法，判断两个对象相等的标准与 == 是完全一样的。<br>因此我们要重写equals：根据业务规则来提供两个对象相等的标准。<br>实际项目中，用来作为equals比较的关键成员变量，通常并不需要使用全部的成员变量<br>——只要用它们关键的成员变量即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equals方法重写实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参数的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化全部成员变量的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goat</span><span class="params">(String color, <span class="keyword">double</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// color的setter和getter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// weight</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// this和obj指向同一个对象</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要求obj不为null，且obj必须是Goat</span></span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp; obj.getClass() == Goat<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        </span>&#123;</span><br><span class="line">            Goat target = (Goat)obj;</span><br><span class="line">            <span class="comment">// 业务要求有几个关键属性，此处就比较几个关键属性，比如说这边只有一个color需要比较</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.color.equals(target.color)</span><br><span class="line">                    &amp;&amp; <span class="keyword">this</span>.weight == target.weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Goat goat1 = <span class="keyword">new</span> Goat(<span class="string">"黑色"</span> , <span class="number">78.2</span>);</span><br><span class="line">        Goat goat2 = <span class="keyword">new</span> Goat(<span class="string">"黑色"</span> , <span class="number">78.2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// goat1与goat2分别指向两个不同的对象，因此==判断返回false。</span></span><br><span class="line">        System.out.println(goat1 == goat2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写equals方法，根据业务规则来判断两个对象是否相等。</span></span><br><span class="line">        System.out.println(goat1.equals(goat2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h4 id="static并不是静态的意思。"><a href="#static并不是静态的意思。" class="headerlink" title="static并不是静态的意思。"></a>static并不是静态的意思。</h4><p>static是类的意思， 有static的成员属于类成员，没有static的成员属于势力成员</p><p>static是否可以修饰局部变量？——局部变量不属于成员，因此不能用static修饰。</p><p>static能否修饰外部类？ —— 外部类不属于成员，因此不能用static修饰。</p><h4 id="static修饰的成员：成员变量、方法、初始化块、内部类"><a href="#static修饰的成员：成员变量、方法、初始化块、内部类" class="headerlink" title="static修饰的成员：成员变量、方法、初始化块、内部类"></a>static修饰的成员：成员变量、方法、初始化块、内部类</h4><p>所有类成员，都只能用类名调用！</p><p>Java语法是不好，允许通过对象来调用类成员，是没有意义的 from 李刚老师</p><p>面试的笔试题中，如果遇到使用对象来调用类成员的情形，先把对象改成类——题目马上一目了然。</p><h4 id="static考点（笔试中非常常见）"><a href="#static考点（笔试中非常常见）" class="headerlink" title="static考点（笔试中非常常见）"></a>static考点（笔试中非常常见）</h4><p>static成员不能访问非static成员。<br>非static成员可以访问static成员！</p><p>static成员（4种）不能访问非static成员（5种：方法、变量、构造器、内部类、初始化块）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 方法 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"info"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        info();//Error:(8, 9) java: 无法从静态上下文中引用非静态 方法 info()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 变量  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(age);//Error:(5, 28) java: 无法从静态上下文中引用非静态 变量 age</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 内部类 </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 静态访问，使用了非静态内部类</span></span><br><span class="line"><span class="comment">//        A a = new A();//Error:(9, 15) java: 无法从静态上下文中引用非静态 变量 this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 初始化块 </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;<span class="comment">// 静态成员</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        age = <span class="number">20</span>;<span class="comment">// 非静态成员</span></span><br><span class="line">        <span class="comment">//无法从静态上下文中引用非静态 变量 age</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 初始化块2 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"info 方法"</span>);<span class="comment">// 非静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        info();<span class="comment">// 静态成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 初始块3 </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>最早来自于建筑行业，早期优秀建筑设计师针对建筑给了很多优秀的建筑建议。比如房子有大窗户会更好一点，诸如此类的建筑建议</p><p>对于一批经常出现的设计场景，前人总结出来的比较成功的设计——这就是设计模式。<br>后面的人就应该学习、并模仿他们，从而提高我们的代码质量。</p><p>其中<strong>单例模式</strong>就是设计模式的一种：在某些场景下，某些类只需要（只能）创建一个实例。<br>比如系统的窗口管理器。只能有一个。<br>数据库引擎访问点，整个数据库，Java程序所在JRE环境……都只需要产生一个实例。<br>此时就应该采用单例模式</p><h3 id="如何设计单例模式？"><a href="#如何设计单例模式？" class="headerlink" title="如何设计单例模式？"></a>如何设计单例模式？</h3><ol><li>隐藏构造器——避免被创建实例</li><li>暴露一个static的方法，该方法用于创建实例<br>该方法还需要保证该类只会产生一个实例 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line">    <span class="comment">// 构造器隐藏</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴露一个static方法，用于创建实例变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         Singleton s1 = Singleton.instance();</span><br><span class="line">         Singleton s2 = Singleton.instance();</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java速记——包装类&quot;&gt;&lt;a href=&quot;#Java速记——包装类&quot; class=&quot;headerlink&quot; title=&quot;Java速记——包装类&quot;&gt;&lt;/a&gt;Java速记——包装类&lt;/h1&gt;&lt;p&gt;Java有8大基本类型：int、float、double、long、
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java速记——面向对象快速回顾</title>
    <link href="https://mr8god.cn/2020/04/07/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE/"/>
    <id>https://mr8god.cn/2020/04/07/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE/</id>
    <published>2020-04-07T07:49:15.000Z</published>
    <updated>2020-04-14T15:54:59.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象快速回顾"><a href="#面向对象快速回顾" class="headerlink" title="面向对象快速回顾"></a>面向对象快速回顾</h1><p>345</p><p>3种类型：类、接口、枚举</p><p>4个修饰符：private|protected|public、final、static、abstract</p><p>5个成员</p><h2 id="定义类的语法"><a href="#定义类的语法" class="headerlink" title="定义类的语法"></a>定义类的语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 类名 extends 父类</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; 5大成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义成员变量"><a href="#定义成员变量" class="headerlink" title="定义成员变量"></a>定义成员变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 类型 变量名[ &#x3D; 初始值];</span><br></pre></td></tr></table></figure><h2 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 返回值类型 方法名（形参列表）</span><br><span class="line">&#123;</span><br><span class="line">语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义构造器"><a href="#定义构造器" class="headerlink" title="定义构造器"></a>定义构造器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 构造器名（形参列表）</span><br><span class="line">&#123;</span><br><span class="line">语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义初始化块"><a href="#定义初始化块" class="headerlink" title="定义初始化块"></a>定义初始化块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[static] &#123;</span><br><span class="line">语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类用于干甚？"><a href="#类用于干甚？" class="headerlink" title="类用于干甚？"></a>类用于干甚？</h2><ul><li>定义变量</li><li>创建对象</li><li>调用类、方法或者是访问类变量</li><li>派生子类</li></ul><h2 id="对象用于干甚？"><a href="#对象用于干甚？" class="headerlink" title="对象用于干甚？"></a>对象用于干甚？</h2><ul><li>调用实例方法或访问实例变量</li></ul><h2 id="方法（传参机制、递归方法、形参个数可变的方法、方法重载）"><a href="#方法（传参机制、递归方法、形参个数可变的方法、方法重载）" class="headerlink" title="方法（传参机制、递归方法、形参个数可变的方法、方法重载）"></a>方法（传参机制、递归方法、形参个数可变的方法、方法重载）</h2><h2 id="变量（判断变量：先看位置，再看static；成员变量和局部变量）"><a href="#变量（判断变量：先看位置，再看static；成员变量和局部变量）" class="headerlink" title="变量（判断变量：先看位置，再看static；成员变量和局部变量）"></a>变量（判断变量：先看位置，再看static；成员变量和局部变量）</h2><h2 id="构造器（构造器重载、this调用）"><a href="#构造器（构造器重载、this调用）" class="headerlink" title="构造器（构造器重载、this调用）"></a>构造器（构造器重载、this调用）</h2><p>this调用——出现在构造器的第一行，表明调用同一个类中重载的构造器</p><h2 id="初始化块（实例初始化块、类初始化块）"><a href="#初始化块（实例初始化块、类初始化块）" class="headerlink" title="初始化块（实例初始化块、类初始化块）"></a>初始化块（实例初始化块、类初始化块）</h2><p>实力初始化块：本质是构造器所有代码之前的代码；</p><p>类初始化块：本质是该类第一次被主动执行时，只运行一次。</p><h2 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h2><p>private —&gt; 不写 —&gt; protected —&gt; public</p><h2 id="继承、多态"><a href="#继承、多态" class="headerlink" title="继承、多态"></a>继承、多态</h2><p>Java是单继承的。</p><p>方法重写：两同两小一大。</p><p>子类构造器一定会调用父类构造器一次：创建任何对象，都是从Object的构造器开始执行的。</p><p>多态中：</p><p>​    方法执行：总是动态绑定实际类型的方法。<br>​                        强制转换、instanceof - 必须在有继承关系的两个类型之间进行处理，否则会编译报错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面向对象快速回顾&quot;&gt;&lt;a href=&quot;#面向对象快速回顾&quot; class=&quot;headerlink&quot; title=&quot;面向对象快速回顾&quot;&gt;&lt;/a&gt;面向对象快速回顾&lt;/h1&gt;&lt;p&gt;345&lt;/p&gt;
&lt;p&gt;3种类型：类、接口、枚举&lt;/p&gt;
&lt;p&gt;4个修饰符：private|p
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java速记——面向对象基础回顾</title>
    <link href="https://mr8god.cn/2020/04/06/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/"/>
    <id>https://mr8god.cn/2020/04/06/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/</id>
    <published>2020-04-06T07:49:15.000Z</published>
    <updated>2020-04-14T15:55:32.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java面向对象基础回顾"><a href="#Java面向对象基础回顾" class="headerlink" title="Java面向对象基础回顾"></a>Java面向对象基础回顾</h1><p>定义类、创建对象、调用方法</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><pre><code>[修饰符] class 类名{    //成员变量    //方法    //构造器    //初始化块    //内部类}</code></pre><h2 id="定义成员变量"><a href="#定义成员变量" class="headerlink" title="定义成员变量"></a>定义成员变量</h2><p>[修饰符]    类型    变量名[ = 初始值]；</p><h2 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h2><pre><code>[修饰符]    返回值类型    方法名（形参列表）{    // 各种代码。定义变量、赋值语句、流程控制、输出语句}</code></pre><h2 id="定义构造器"><a href="#定义构造器" class="headerlink" title="定义构造器"></a>定义构造器</h2><pre><code>[修饰符]    构造器名（形参列表）{    // 各种代码。定义变量、赋值语句、流程控制、输出语句}</code></pre><p>构造器，很像一个特殊的方法</p><p>跟方法的两点区别：</p><ol><li>没有返回值类型声明，</li><li>构造器名必须类名相同。</li></ol><p>构造器作用：用于初始化对象——构造器永远属于实例。它不可能用static修饰。</p><h2 id="类可以用来干什么？"><a href="#类可以用来干什么？" class="headerlink" title="类可以用来干什么？"></a>类可以用来干什么？</h2><ol><li>定义变量。所有类都是引用类型。</li><li>调用类变量或类方法。</li><li>创建对象。</li><li>派生子类。</li></ol><h2 id="对象可以用来干什么？"><a href="#对象可以用来干什么？" class="headerlink" title="对象可以用来干什么？"></a>对象可以用来干什么？</h2><ol><li>调用实例变量</li><li>调用实例方法</li></ol><p>调用方法或变量：</p><pre><code>    调用者.方法([参数]);    调用者.实例变量;</code></pre><h2 id="方法详解"><a href="#方法详解" class="headerlink" title="方法详解"></a>方法详解</h2><ul><li>方法所属性。<ul><li>从定义的角度来看，方法不能独立定义，方法必须定义在类里面。</li><li>从调入的角度来看，方法不能独立执行，方法必须有调入者才能执行。<ul><li>类方法：也称静态方法，在方法前加static关键字，就代表这个方法属于这个类本身，不属于它的任何实例。换句话说，这个方法不通过实例进行调用，并且所有实例都共享这一个方法，对方法的调用各个实例相互可见。</li><li>实例方法：一个方法如果不加上static关键字，那么这个方法就是实例方法。意思是它属于类的某个实例，通过这个实例调用它，对类的其他实例不产生影响。</li><li>无论如何，方法都需要调用者，区别在于你在写的时候，要根据方法的类型，是类方法就用类名，是实例方法就用对象去调用它。有些情况下，</li><li>在同一个类里面的一个方法调用另一个方法，这个时候可以省略前面的调用者。省略也分两种情况，<ul><li>如果被调用的是实例方法，那么省略的就是；</li><li>如果被调用的是类方法，那么省略的就是类名（不是对象哦！）</li></ul></li></ul></li></ul></li></ul><p>我再补充几句哈，免得有人看不懂，上面其实说得就是这么个意思，如果你用的是静态方法（前头加static的那个），那么这边建议你用类名调用，不建议了，强制比较好一点。然后呢，这边又提出了个省略型，静态方法的调用呢，我们甚至可以省略掉类名，直接上咱们的方法。</p><p>如果你使用的是非静态方法（不加static，亦或者叫做实例方法），那么你就必须得创建一个对象，然后用对象来调用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fn1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fn2"</span>);</span><br><span class="line">        Test.fn1();<span class="comment">// 这边也可以直接省略掉Test.，比如说向下边这么写</span></span><br><span class="line">        <span class="comment">//fn1();  // 这就是上面说的，直接省略掉类名，上咱们的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">        t.fn2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>形参个数可变的方法</li><li>递归方法：</li><li>方法重载：2同1不同</li><li>方法的传参机制：值传递，传递的是参数的副本，并不是参数本身</li></ul><h2 id="变量的详解"><a href="#变量的详解" class="headerlink" title="变量的详解"></a>变量的详解</h2><p>成员变量（类里面定义）</p><ul><li>类变量。有static。静态变量</li><li>实例变量。无static。非静态变量</li></ul><p>成员变量，无需由程序员显式指定初始值，系统会为之分配默认初始值；</p><p>初始值规则：与数组元素的初始值规则完全相同</p><ul><li><p>类变量：是在第一次用该类的时候，系统会为该类变量分配空间，并初始化。</p><p>每个类的类变量都只有一个</p></li><li><p>实例变量：每次创建对象，系统都会为该对象的实例变量分配空间，并初始化。</p><pre><code>  程序中有几个对象，系统就会为这些对象的实例变量分配对应的空间。</code></pre></li></ul><p>局部变量（方法里定义）</p><ul><li>形参</li><li>方法里局部变量</li><li>代码块的局部变量</li></ul><p>局部变量</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装、继承、多态——面向对象的3大特征。</p><p>封装包含了两方面的内容</p><ul><li>隐藏：隐藏的内部实现细节。</li><li>暴露：将一些操作界面暴露出来。<br>如果通过暴露的界面来操作对象，该对象的内部状态不会被破坏。</li></ul><p>简而言之：封装要求合理隐藏、合理暴露、</p><ul><li>通过访问控制器实现：</li></ul><p>private -&gt;         不写        -&gt;        protected        -&gt;        public</p><p>private（类访问权限）：该修饰符修饰的成员，只能在该类中被访问。</p><p>不写（包访问权限）：该修饰符修饰的成员，只能在该类及其该类所在包中被访问。</p><p>protected（子类访问权限）：该修饰符修饰的成员，只能在该类、及其该类所在包、该类的子类中被访问。</p><p>public（公共）：该修饰符修饰的成员可以在任意地方被访问。</p><div class="table-container"><table><thead><tr><th></th><th>private</th><th>不写</th><th>protected</th><th>public</th></tr></thead><tbody><tr><td>当前类</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>同一个包</td><td>×</td><td>√</td><td>√</td><td>√</td></tr><tr><td>子类</td><td>×</td><td>×</td><td>√</td><td>√</td></tr><tr><td>任意</td><td>×</td><td>×</td><td>×</td><td>√</td></tr><tr><td></td><td>彻底隐藏</td><td>部分隐藏</td><td>部分暴露</td><td>彻底暴露</td></tr></tbody></table></div><p>指导原则：</p><ol><li>成员变量（实例变量），通常用private修饰，为了隐藏实现细节</li><li>为每个成员变量提供getter、setter方法，用于控制该成员变量</li><li>需要暴露的方法，通常用public修饰</li><li>如果希望一个方法主要用于被子类重写，用protected修饰。</li></ol><ul><li><p>包<br>不同公司完全可以定义同名的类，为解决类名冲突的问题，不同公司不同项目的类名重复的问题。<br>Java就引入了“包”的机制。</p><p>举例理解：同一个班的两个同名的同学，为了区别他们，我们通常 会加一些修饰语，比如说“大江”“小江”<br>这边就是在类名前面添加一个前缀。<br>Java如何为类定义包？</p><ul><li>在源代码中用package包名；</li><li>将生成class文件要放在对应的文件结构下。</li></ul><p>包名的命名规范：语法要求，只要标识符即可</p><pre><code>          专业要求，推荐用公司域名倒写：比如org.fkjava.项目名;就挺好。</code></pre><p>【备注】一旦你为类指定了包名之后，使用该类时应该用完整类名：包名+类名</p></li><li><p>导入包<br>impo的作用：为了省略写包名。</p><pre><code>                    如果不用import，每次用类时都需要使用包名+类名的形式。</code></pre><ul><li>import 包名.类名；——每次导入一个类</li><li>import 包名.* ——导入指定的所有类</li><li>Java程序默认已导入java.lang包下所有包</li></ul></li><li>静态导入 import static<ul><li>import的作用：为了省略写包名。</li><li>import static的作用：可以省略写类名。<pre><code>                                  用于导入指定类的所有静态成员，导入之后，即可省略写类名。</code></pre></li><li>import static 包名.类名.静态成员名; ——每次只导入一个静态成员。</li><li>import static 包名.类名.*;  ——导入指定类的所有静态成员。</li></ul></li><li>Java源程序的结构：<br>一条package语句<br>N条import语句<br>N个class定义</li></ul><h2 id="构造器详解"><a href="#构造器详解" class="headerlink" title="构造器详解"></a>构造器详解</h2><h3 id="构造器规则"><a href="#构造器规则" class="headerlink" title="构造器规则"></a>构造器规则</h3><ol><li>构造器用于初始化对象。</li><li>构造器如何调用？必须用new来调用啦。这样就可以返回一个初始化完成的对象。</li><li>如果你不为一个类提供构造器，那么系统会自动为该类提供一个无参数的构造器</li></ol><h2 id="构造器重载"><a href="#构造器重载" class="headerlink" title="构造器重载"></a>构造器重载</h2><p>一个类中可以定义多个构造器（因此构造器名必然相同），必须要求形参列表不同——这就是构造器的重载</p><p>this调用与this引用</p><p>this引用：this紧跟一个。<br>                    this.name;<br>                    this.walk();</p><p>this调用：this紧跟圆括号。<br>                 this（参数）<br>                    this调用代表调用同一个类中重载的构造器——this调用只能出现在【构造器】的【第一行】</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>封装、继承、多态——面向对象三大特征</p><h3 id="理解继承"><a href="#理解继承" class="headerlink" title="理解继承"></a>理解继承</h3><p>苹果类继承了水果类</p><p>老虎继承了动物类</p><p>东北虎继承了老虎类</p><p>Java的继承：是一种类与类之间关系<br>                        是一种由一般到特殊的关系，子类是一种特殊的父类<br>                        子类实例，完全可以当做父类实例来使用！</p><p>父类（超类、基类、大类，一些别称）；</p><p>子类（派生类、小类：一些别称）。</p><h3 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 类名 extends 父类</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明</p><ul><li>Java是单继承，只能有一个直接父类。</li><li>如果你不显式继承父类，Java默认是继承Object类（JDK系统提供的类）</li></ul><p>子类继承父类，可以得到父类的：</p><ul><li>成员变量</li><li>方法</li></ul><p>继承的好处：【代码复用】     </p><h2 id="方法重写（override）"><a href="#方法重写（override）" class="headerlink" title="方法重写（override）"></a>方法重写（override）</h2><p>当子类发现父类不适合自己时，就要重写父类的方法。</p><p>方法重写口诀</p><ol><li><p>方法名相同、形参列表相同。</p></li><li><p>返回值类型相同或更小， 声明跑出的异常相同或更小</p></li><li><p>访问权限相同或更大（如果父类访问权限是public的话，那么我们重写只能是public，因为public的权限是最大的了）</p><p>@Override：作用是报错。</p><pre><code>                    要求被修饰的方法必须重写父类方法，否则就报错。                比如说如果我们重写的类名写错了，用这个方法可以帮我们发现这个错误，比如我们                    需要重写的类名是fly()，而我们写成了f1y()。</code></pre></li></ol><p>Java找变量先就近，</p><h2 id="super限定"><a href="#super限定" class="headerlink" title="super限定"></a>super限定</h2><p>与前面this引用非常相似，super用于限定访问父类定义的实例变量或实例方法</p><p>super.父类定义的实例变量</p><p>super.父类定义的实例方法(参数)</p><h2 id="子类构造器调用父类的构造器"><a href="#子类构造器调用父类的构造器" class="headerlink" title="子类构造器调用父类的构造器"></a>子类构造器调用父类的构造器</h2><p><strong>子类构造器【一定调用】父类构造器【一次】——有且仅有一次。</strong></p><ol><li><p>如果子类构造器没有显式调用父类构造器，那么系统会自动在子类构造器的第一行先调用父类无参数的构造器</p></li><li><p>子类构造器的第一行显式使用super来调用父类构造器<br>super调用一定是调用的父类的构造器。只能出现在构造器的第一行。<br>this调用是调用当前类的构造器。只能出现在构造器的第一行<br>【很明显，super调用和this调用不可能同时出现。】</p><p>super限定：super紧跟一个   <strong>.</strong></p><pre><code>                  super.name;                  super.walk();</code></pre><p>super调用：super后边紧跟括号。</p><pre><code>                  super(参数);</code></pre></li></ol><p>【备注】：如果父类没有无参数的构造器，子类的构造器必须显式调用父类指定的构造器。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>我再回顾一下345</p><p>3种类型：类、接口、枚举。<br>4个修饰符：private|protected|public、final、static、abstract<br>5大成员：成员变量、方法、构造器、初始化块、内部类</p><p>多态的意义：<br>我们先吹一吹<strong>变态</strong>的概念：from 百度百科</p><ul><li>心理、行为上异于常人而且呈现病态。</li><li>经常做出正常人无法理解事情或违背常理行为的人。</li><li>能做出令人厌恶、反常的举动。</li><li>精神病或者神经不正常。</li></ul><p>很明显，这个的意思是，在寻常的正常的一群人或者正常的成长路线中，个别人（对象）呈现出变异的行为特征——这个就是变态的定义</p><p>再说一说<strong>拟态</strong>：动物为了生存下来，变成令人害怕的样子，吓唬别人</p><p><strong>多态</strong>：同一个类型的多个实例、在执行同一个方法，呈现出多种的行为特征——这就叫做“多态”</p><p>举个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 多态 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bird b1 = <span class="keyword">new</span> Sparrow();<span class="comment">// 这边需要注意的是，我的Sparrow类里边是没有fly方法的</span></span><br><span class="line"></span><br><span class="line">        Bird b2 = <span class="keyword">new</span> Ostrich();<span class="comment">// 这边需要注意的是，我的Ostrich类里边是有fly方法的</span></span><br><span class="line"></span><br><span class="line">        b1.fly();<span class="comment">// 当我的b1动态绑定类的fly方法的时候，发现我的Sparrow类里边没有fly方法，于是我的b1就开始寻找父类了，父类Bird里边果然有，所以我输出了“鸟在天上飞”</span></span><br><span class="line"></span><br><span class="line">        b2.fly();<span class="comment">// 当我的b2动态绑定类的fly方法的时候，发现我的Ostrich类里边是有fly方法的，于是我就输出了“鸵鸟当然只能跑啦！”这句话</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我相信上面的例子肯定能够助大家理解什么是多态</span></span><br><span class="line">        <span class="comment">// 相同类型的实例，在执行同一个方法的时候，呈现出多个行为特征。这就叫多态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bird类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name = <span class="string">"鸟"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鸟在天上飞"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sparrow类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ostrich类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ostrich</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鸵鸟当然只能跑啦！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向上转型：子类对象可以直接赋值给父类变量。"><a href="#向上转型：子类对象可以直接赋值给父类变量。" class="headerlink" title="向上转型：子类对象可以直接赋值给父类变量。"></a>向上转型：子类对象可以直接赋值给父类变量。</h3><h3 id="向下转型：父类变量赋值给子类变量。"><a href="#向下转型：父类变量赋值给子类变量。" class="headerlink" title="向下转型：父类变量赋值给子类变量。"></a>向下转型：父类变量赋值给子类变量。</h3><p>强制转换。<br>（类型）变量名。</p><h3 id="为什么会有多态呢？"><a href="#为什么会有多态呢？" class="headerlink" title="为什么会有多态呢？"></a>为什么会有多态呢？</h3><p>当我们的Java执行方法时，方法的执行是 动态绑定的。方法总是执行该变量实际所指向对象的方法。</p><h3 id="变量的类型（这边再讲一个概念）"><a href="#变量的类型（这边再讲一个概念）" class="headerlink" title="变量的类型（这边再讲一个概念）"></a>变量的类型（这边再讲一个概念）</h3><p>编译时的类型：声明该变量时指定的类型。<br>                           在Java程序的编译阶段，Java编译器只认编译时的类型。</p><p>运行时的类型（实际类型）：该变量实际所引用的对象的类型。</p><h3 id="强制转换运算符的注意点："><a href="#强制转换运算符的注意点：" class="headerlink" title="强制转换运算符的注意点："></a>强制转换运算符的注意点：</h3><ol><li><p>强制转换运算符只能在具有编译类型具有父子关系的变量之间进行转换。否则编译错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"在平面上绘制图形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> <span class="keyword">extends</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是一个矩形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">round</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"绕着圆形走一圈"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 多态2 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// s1编译类型是Shape，实际类型是Rect</span></span><br><span class="line">        Shape s1 = <span class="keyword">new</span> Rect();</span><br><span class="line">        s1.draw();</span><br><span class="line"><span class="comment">//        s1.info();// 无法调用，找不到info方法，因为，Java在编译的时候，只认编译类型。对于Java编译器来说，s1是Shape类型</span></span><br><span class="line">        <span class="comment">// 实际上是可以允许的，s1是有这个方法的，是可以运行的，只是编译不能通过</span></span><br><span class="line">        Shape s2 = <span class="keyword">new</span> Circle();</span><br><span class="line">        <span class="comment">// 对于编译器而言，s2是Shape类型，Shape没有round方法</span></span><br><span class="line"><span class="comment">//        s2.round();// 无法运行，同上理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// s2编译类型是Shape，c要求是Circle，Shape无法转换为Circle。，这个时候要用强制转换</span></span><br><span class="line"><span class="comment">//        Circle c = s2;</span></span><br><span class="line">        <span class="comment">// 解决上面的方法是强制转换。</span></span><br><span class="line">        Circle c = (Circle)s2;</span><br><span class="line">        c.round();</span><br><span class="line"></span><br><span class="line">        Circle c2 = (Circle)s1;<span class="comment">// 类型转换异常，s1指向的是Rect，强制转换只能是本来指向要转换的类才能进行转换</span></span><br><span class="line">        <span class="comment">// 比如这边的s2本来就是指向Circle的，于是可以转换</span></span><br><span class="line">        <span class="comment">// 这边的s1本来是指向Rect，所以不能转换</span></span><br><span class="line">        c2.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子加以说明</p></li><li><p>如果在编译类型具有继承关系的变量之间转换，如果被转变量的实际类型，不是要转的目标类型，那么程序就会引发ClassCastException（类型转换异常）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 强转2 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object str1 = <span class="string">"Mr8god"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 强转</span></span><br><span class="line"></span><br><span class="line">        String str = <span class="string">"Mr8god"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Integer it = (Integer) str;// 会报不兼容的错误，因为String跟Integer没有继承关系，所以编译就会报错，报不兼容的类型</span></span><br><span class="line">        Integer it = (Integer) str1;<span class="comment">// 这边Object与Integer之间有继承关系，所以编译能通过，但是运行会出现异常。</span></span><br><span class="line">        <span class="comment">// 编译器要求：必须在编译类型具有继承关系才能强转</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上头还是我写的一个小栗子；</p></li></ol><h3 id="instanceof运算符（为了避免ClassCastException异常）："><a href="#instanceof运算符（为了避免ClassCastException异常）：" class="headerlink" title="instanceof运算符（为了避免ClassCastException异常）："></a>instanceof运算符（为了避免ClassCastException异常）：</h3><p>为了避免ClassCastException异常，Java就增加了这个运算符。</p><p>变量名 instanceof 类型 —— 当前面的变量所引用对象是后面类或者子类的实例时，该运算符返回true。</p><p>instanceof 只能在编译类型具有继承关系之间进行判断，否则编译报错：不兼容的类型。</p><p>所以我们以后在强制转换之前，都要做到先判断再转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 强转2 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object str1 = <span class="string">"Mr8god"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 强转</span></span><br><span class="line"></span><br><span class="line">        String str = <span class="string">"Mr8god"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Integer it = (Integer) str;// 会报不兼容的错误，因为String跟Integer没有继承关系，所以编译就会报错，报不兼容的类型</span></span><br><span class="line"><span class="comment">//        Integer it = (Integer) str1;// 这边Object与Integer之间有继承关系，所以编译能通过，但是运行会出现异常。</span></span><br><span class="line">        <span class="comment">// 编译器要求：必须在编译类型具有继承关系才能强转</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (str1 <span class="keyword">instanceof</span> Integer)</span><br><span class="line">        &#123;</span><br><span class="line">            Integer it = (Integer)str1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有在编译类型具有继承关系才能进行判断，否则编译报错，下面的例子又是一个不兼容的问题，String无法转换为Integer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 强转2 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String s = <span class="string">"Mr8god"</span>;</span><br><span class="line"><span class="comment">//        System.out.println(s instanceof Integer);//是不能运行的，因为String无法转换为Integer。。。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h2><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[修饰符]&#123;</span><br><span class="line"></span><br><span class="line">​各种语句</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化块是没有名字的，<br>修饰符只能出现一个：static。</p><ul><li>有static的叫做类初始化块（静态初始化块）；</li><li>无static的叫做实例初始化块（非静态初始化块）；</li></ul><p>初始化块代码小栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">happy1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">2</span>;<span class="comment">// 成员变量-&gt; 实例变量</span></span><br><span class="line"><span class="comment">//    String name;</span></span><br><span class="line"><span class="comment">//    name = "Mr8god";</span></span><br><span class="line">    <span class="comment">//赋值语句不能放在类里边，赋值语句放在方法中</span></span><br><span class="line">    </span><br><span class="line">    String name ;</span><br><span class="line">    &#123;name = <span class="string">"Mr8god"</span>;&#125;<span class="comment">// 这样就变成初始化块了，就可以写了。这个东西叫做代码块中的初始化块（一种特例）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化块分成两种："><a href="#初始化块分成两种：" class="headerlink" title="初始化块分成两种："></a>初始化块分成两种：</h3><h4 id="实例初始化块（无static）"><a href="#实例初始化块（无static）" class="headerlink" title="实例初始化块（无static）"></a>实例初始化块（无static）</h4><p>实例初始化块其实是一种“假象”，一个类在编译之后，实例初始化块就会消失。</p><p>实力初始化块的所有代码会被还原到每个构造器的开始部分。<br>举个代码小栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitTest</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Mr8god"</span>);<span class="comment">// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面有两个构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InitTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一个无参构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InitTest</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"带String参数的构造器， 参数为："</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译之后，上面所以代码会变成下面的样子，下面的代码就是上面的本质。</span></span><br><span class="line"><span class="comment">//    public InitTest()</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("Mr8god");// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println("这是一个无参构造器");</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    public InitTest(String name)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("Mr8god");// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println("带String参数的构造器， 参数为：" + name);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边介绍一个命令javap -c 用于分析Java 的class文件<br><img src="https://i.loli.net/2020/04/07/mH9yhbtZ7dSeiwJ.jpg" alt="javap之后的真相.jpg"></p><p>经过反编译，得到具体代码运行过程后，我们发现事实确实是这样的哈。</p><p>这边再附上一个代码调用上面的类，以方便以后复现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Init in = <span class="keyword">new</span> Init();</span><br><span class="line"></span><br><span class="line">        Init in2 = <span class="keyword">new</span> Init(<span class="string">"江某人来了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实例初始化块的作用："><a href="#实例初始化块的作用：" class="headerlink" title="实例初始化块的作用："></a>实例初始化块的作用：</h5><ol><li>类似于C++中的全局变量，只需要维护一个地方就够了，不需要到每个构造器里操作。</li><li>将多个构造器前面部分相同的代码可以提取到实例初始化块中！</li></ol><h5 id="实例初始化块何时执行呢？"><a href="#实例初始化块何时执行呢？" class="headerlink" title="实例初始化块何时执行呢？"></a>实例初始化块何时执行呢？</h5><p>只要程序调用构造器创建对象，程序总会先执行实例初始化块——因为实例初始化块被还原到每个构造器的所有代码之前。</p><h5 id="定义实例变量"><a href="#定义实例变量" class="headerlink" title="定义实例变量"></a>定义实例变量</h5><p>当我的init类是这个时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Init</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Mr8god"</span>);<span class="comment">// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 下面有两个构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一个无参构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Init</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"带String参数的构造器， 参数为："</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initTest是这个时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Init in = <span class="keyword">new</span> Init();</span><br><span class="line"></span><br><span class="line">        Init in2 = <span class="keyword">new</span> Init(<span class="string">"江某人来了"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(in2.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果并不是如我刚开始想象的那样是20，因为我以为初始化的20 ，是分散到两个方法里去了，那么引用的话，应该是20呀。结果却是2。</p><p><strong>定义实例变量时指定的初始值，也是“假象” 。</strong></p><p><strong>——指定初始值，编译之后就变成构造器所有代码之前一条赋值语句！</strong></p><p>这里边的int age = 2，本质上是int age ;我们可以通过反编译工具看到</p><p><img src="https://i.loli.net/2020/04/07/5jsBlRHOqDAVC2Z.jpg" alt="age没有赋值.jpg"></p><p>所以我上面的Init类现在实际上已经变成了这个样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Init</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 下面有两个构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mr8god"</span>);<span class="comment">// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">        age = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">"这是一个无参构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Init</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mr8god"</span>);<span class="comment">// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">        age = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">"带String参数的构造器， 参数为："</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么很明显，最近一次的赋值age是2。所以会出现问题，不是我想象中的20，也是理所应当了</p><p>这里边大费周章又是比较代码又是反编译的，其实主要是为了说明一点</p><p>即使我们的赋值语句不在代码块中，编译之后，也是会一起到构造语句中的。over</p><p>也就是说，如果我把int age = 2;放在类中的首行，也就是public Init()的上一行，我们得出的结果就会是20了，只是一个age赋值先后顺序的关系。</p><h5 id="总结总结总结"><a href="#总结总结总结" class="headerlink" title="总结总结总结"></a>总结总结总结</h5><p>实例初始化块的语句要还原到构造器的所有代码之前；定义变量指定的初始值，也要还原到构造器的所有代码之前；那么这两者的先后顺序呢？按照它们在源代码中的顺序。</p><h4 id="类初始化块（有static）"><a href="#类初始化块（有static）" class="headerlink" title="类初始化块（有static）"></a>类初始化块（有static）</h4><p>类初始化块——负责对类执行初始化。<br>                            当程序<strong>第一次主动</strong>使用该类时，系统会为该类分配内存空间、并执行初始化（调用类初始化块）</p><h5 id="对-第一次主动-概念做解释："><a href="#对-第一次主动-概念做解释：" class="headerlink" title="对 第一次主动 概念做解释："></a>对 <strong>第一次主动</strong> 概念做解释：</h5><p>除了用类去声明变量，其他只要你使用该类，都算是第一次主动使用该类。可以从Java编译器的角度去理解</p><h5 id="类初始化块何时执行"><a href="#类初始化块何时执行" class="headerlink" title="类初始化块何时执行"></a>类初始化块何时执行</h5><p>程序第一次【主动】使用该类时，会执行该类的类初始化块。<br>程序运行时，该类初始化块只会执行一次！</p><div class="table-container"><table><thead><tr><th></th><th>执行次数</th><th>执行先后</th><th>何时执行</th></tr></thead><tbody><tr><td>类初始化块</td><td>1次·</td><td>先</td><td>第一次主动用该类</td></tr><tr><td>实例初始化块</td><td>N次</td><td>后</td><td>每次调用构造器</td></tr></tbody></table></div><p><strong>定义实例变量时指定的初始值，也是“假象” 。</strong></p><p><strong>——指定初始值，编译之后就变成类初始化中的一条赋值语句！但到底是在类初始化块的代码之前，还是代码之后呢，取决于它在源代码中的顺序。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInit</span> </span>&#123;</span><br><span class="line"><span class="comment">//    static int age = 30;</span></span><br><span class="line"><span class="comment">//    // 类初始化块</span></span><br><span class="line"><span class="comment">//    static &#123;</span></span><br><span class="line"><span class="comment">//        age = 300;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上面代码的本质，如下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 类初始化块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        age = <span class="number">30</span>;</span><br><span class="line">        age = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="大一统"><a href="#大一统" class="headerlink" title="大一统"></a>大一统</h4><p>先上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base11</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Base11 的类初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Base11 的实例始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base11</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Base11 无参数构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base11</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Base11 的（String）参数构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mid</span> <span class="keyword">extends</span> <span class="title">Base11</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Mid 的类初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Mid 的实例初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">(<span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        System.out.println(<span class="string">"Mid 的(int)构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"Mr8god"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Mid 的无参数构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub1</span> <span class="keyword">extends</span> <span class="title">Mid</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Sub 的类初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Sub 的实例初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sub1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sub 的无参数构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sub1</span><span class="params">(<span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        System.out.println(<span class="string">"Sub 的（double）构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Sub1(<span class="number">3.4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【结论】：初始化任何类之前，一定先从Object开始初始化，依次初始化它所有祖先类，最后才到它自己；创建任何对象的时候，一定是从Object构造器开始执行，执行它所有祖先类的构造器，最后才执行它自己的构造器！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java面向对象基础回顾&quot;&gt;&lt;a href=&quot;#Java面向对象基础回顾&quot; class=&quot;headerlink&quot; title=&quot;Java面向对象基础回顾&quot;&gt;&lt;/a&gt;Java面向对象基础回顾&lt;/h1&gt;&lt;p&gt;定义类、创建对象、调用方法&lt;/p&gt;
&lt;h2 id=&quot;定义类&quot;
      
    
    </summary>
    
    
      <category term="技术" scheme="https://mr8god.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://mr8god.cn/tags/Java/"/>
    
  </entry>
  
</feed>
