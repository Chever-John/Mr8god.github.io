<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js ? id=UA-162074438-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-162074438-1');
</script>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mr8god.cn","root":"/","scheme":"Muse","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Just learning！">
<meta property="og:type" content="website">
<meta property="og:title" content="Mr8god&#39;s blog">
<meta property="og:url" content="https://mr8god.cn/page/3/index.html">
<meta property="og:site_name" content="Mr8god&#39;s blog">
<meta property="og:description" content="Just learning！">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Mr8god">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://mr8god.cn/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Mr8god's blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-162074438-1# <app_id>"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-162074438-1# <app_id>');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Mr8god's blog" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>
<a href="https://github.com/Mr8god/Mr8god.github.io" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mr8god's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">coding,coding,always coding!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mr8god.cn/2020/04/09/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mr8god">
      <meta itemprop="description" content="Just learning！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr8god's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/09/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" class="post-title-link" itemprop="url">Java速记——类型转换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-09 15:49:15" itemprop="dateCreated datePublished" datetime="2020-04-09T15:49:15+08:00">2020-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-15 00:04:42" itemprop="dateModified" datetime="2020-04-15T00:04:42+08:00">2020-04-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java速记——类型转换"><a href="#Java速记——类型转换" class="headerlink" title="Java速记——类型转换"></a>Java速记——类型转换</h1><p>整形的注意点，</p>
<ol>
<li>直接给出一个整形整数值，该整数值默认为int型，但如果该整数位于byte、short的取值范围内，Java也可以直接把整数值当做byte、short处理，</li>
<li>如果你希望一个整数被当成long处理，必须在整数后添加L或者l。</li>
<li>整数有4种表达形式：<ol>
<li>十进制：常用。</li>
<li>八进制：以0开头，数值不超过7。</li>
<li>16进制：以0x或0X开头，数值不能超过F、a代表10、b代表11……f代表15。</li>
<li>二进制：以0b或0B开头，数值不能超过1。</li>
</ol>
</li>
</ol>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="自动转化：取值范围小的，自动转化为取值范围大的"><a href="#自动转化：取值范围小的，自动转化为取值范围大的" class="headerlink" title="自动转化：取值范围小的，自动转化为取值范围大的"></a>自动转化：取值范围小的，自动转化为取值范围大的</h3><p>byte&gt;short&gt;int &gt; long&gt; float&gt;double</p>
<p>​            char可以转化为int</p>
<p>每个字符都是有一个编号，计算机只存编号</p>
<p>short：-32768~+32768</p>
<p>char:0-65535</p>
<p>声明变量：</p>
<p>​            类型 变量[ = 初始值 ]；</p>
<p>类型 byte，</p>
<p>自动转化几条规则：</p>
<ol>
<li>所有整型都可以自动转成浮点型</li>
<li>所有整型都可以自动转化为long型</li>
<li>所有数值型，都可以自动转成double型</li>
</ol>
<p>记一下常识性的东西</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\r  <span class="number">13</span></span><br><span class="line"></span><br><span class="line">\n  <span class="number">10</span></span><br><span class="line"></span><br><span class="line">\t	<span class="number">9</span></span><br><span class="line"></span><br><span class="line">\<span class="string">'	39</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">\''</span>	<span class="number">34</span></span><br></pre></td></tr></table></figure>
<h3 id="强制转化："><a href="#强制转化：" class="headerlink" title="强制转化："></a>强制转化：</h3><p>上图上反过来转换，就需要强制转换</p>
<ol>
<li>浮点数转整数，砍掉小数部分</li>
<li>强制转换可能发生“溢出”</li>
</ol>
<h3 id="表达式类型的自动提升"><a href="#表达式类型的自动提升" class="headerlink" title="表达式类型的自动提升"></a>表达式类型的自动提升</h3><p>整个表达式的类型，与该表达式中最高等级的操作数的类型相同</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>算术运算符（7个）</p>
<p>+、-、*、/、%</p>
<p>++ ：将单个变量的值+1</p>
<p>​        放在变量之后，表示先用变量的值，再自加</p>
<p>​        放在变量之前，表示先自加，在用变量的值</p>
<p>—：将单个变量的值-1</p>
<p>​        放在变量之后</p>
<p>对于一些复杂运算需要使用math </p>
<h4 id="赋值运算符："><a href="#赋值运算符：" class="headerlink" title="赋值运算符：="></a>赋值运算符：=</h4><p>将=右边的值装入左边的容器（变量）</p>
<p>=左边只能是变量</p>
<p>=右边可以是任何复杂的表达式</p>
<p>大部分时候= 右边往往都是复杂的表达式</p>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>$&gt;$</p>
<p>$&gt;=$</p>
<p>$&lt;$</p>
<p>$&lt;=$</p>
<p>$==$</p>
<p>$~=$</p>
<p>比较运算符，用于比较两个变量或两个值，如果符合预期得到true，否则得到false</p>
<h4 id="逻辑运算符："><a href="#逻辑运算符：" class="headerlink" title="逻辑运算符："></a>逻辑运算符：</h4><p>只能对boolean值进行运算。</p>
<p>&amp;&amp;        与</p>
<p> &amp;</p>
<p>||        或</p>
<p>|</p>
<p>！        非</p>
<p>^            </p>
<p>两个条件相同则为false；不同则为true</p>
<p>富 美</p>
<p>既富，也美 - and</p>
<p>富或美  </p>
<p>短路与和与的区别：如果第一个操作数已经是false，&amp;&amp;运算符不会算第二个操作数，称之为短路。</p>
<p>​                                    如果第一个操作数已经是false，&amp;运算符依然会计算第二个操作数，称之为不短路</p>
<p>||和|的区别：同理如短路与！</p>
<p>一般来说，编程时都用短路与和短路或</p>
<h4 id="位运算符："><a href="#位运算符：" class="headerlink" title="位运算符："></a>位运算符：</h4><p>它只能对整型（byte、short、int、long、char（0~65535））运算</p>
<p>负数的进制码：保存的是它的补码</p>
<p>原码：数，直接算出来叫原码。最高位，又叫做符号位，0代表正数；1代表负数</p>
<p>反码：除符号位之外，其他位都按位取反</p>
<p>补码：反码+1。</p>
<ol>
<li><p>&amp;：按位与。上下两位都是1时，得到的结果才是1。</p>
</li>
<li><p>|：按位或。上下两位有一个1时，得到的结果就是1。</p>
<p>与位运算符相当常用，当表示状态时，会用特定的数代表开关。文本状态：粗体（1）、斜体（2）、下划线（4）、中划线（8）。就可以靠位与运算符进行控制。</p>
<p>所有涉及到开关的设计都会用到位于运算符</p>
</li>
<li><p>~：按位取反，正数变成负的（绝对值+1），负数变为正的（绝对值-1）。可以通过数学定理证明</p>
</li>
<li><p>^：按位异或。上下两位相同时，得到的结果是1.不同的时候，得到的结果为0.</p>
</li>
<li><p>&lt;&lt;：左移。左移N位相当于乘以2的N次方</p>
<p>2乘以8，最快的算法：2&lt;&lt;3</p>
</li>
<li><p>$&gt;&gt;$：右移N位，就是除以2的N次方，会砍掉小数，所以在除不尽的情况下，结果会比实际结果略小</p>
</li>
<li><p>$&gt;&gt;&gt;$：无符号右移。不太常用<br>如果被移的数是正数，那么该运算符与$&gt;&gt;$运算符效果一样<br>如果被移的数是负数，被空出来的数高位高位总是补0——这个数就会变成正数。</p>
</li>
</ol>
<h4 id="扩展的赋值运算符："><a href="#扩展的赋值运算符：" class="headerlink" title="扩展的赋值运算符："></a>扩展的赋值运算符：</h4><p>a  += b;        a = (类型)（a + b),这种更加好用，因为他可以自动强制转换为原先的类型。</p>
<p>所以推崇这种写法。</p>
<p>a -= b             a = (类型)（a - b)</p>
<p>……………………</p>
<p>基本上，前面介绍的所有双目运算符都可以和=结合，形成扩展的赋值运算符</p>
<h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><p>逻辑表达式？ 值1：值2</p>
<p><strong>常用的是三目运算符的嵌套</strong>！！！</p>
<p>嵌套后的三目运算符可能返回3个，甚至于更多值的其中之一</p>
<h4 id="运算符的结合性和优先级"><a href="#运算符的结合性和优先级" class="headerlink" title="运算符的结合性和优先级"></a>运算符的结合性和优先级</h4><p>结合性：控制运算符的运算方向：从左到右？还是从右到左？</p>
<p>大部分运算符都是从左到右。=运算符是从右到左的</p>
<p>推荐，记不清的时候，用括号来保证优先级</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol>
<li>变量定义、复制（简单值、表达式）</li>
<li>8个基本类型：byte、short、int、long、float、double、char、boolean</li>
</ol>
<p>运算符</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ol>
<li>顺序结构：从上到下、逐行执行</li>
<li>分支结构：根据具体情况，做出判断</li>
<li>循环结构：根据条件，让一个或多个步骤<strong>重复</strong>执行很多次</li>
</ol>
<p>目前可能存在的问题：</p>
<ol>
<li>语法掌握其实并不熟练</li>
<li>缺乏正确的程序员思维</li>
</ol>
<h3 id="顺序结构："><a href="#顺序结构：" class="headerlink" title="顺序结构："></a><strong>顺序结构</strong>：</h3><p>不加什么控制，程序代码都是从上到下，依次执行</p>
<h3 id="分支结构："><a href="#分支结构：" class="headerlink" title="分支结构："></a><strong>分支结构</strong>：</h3><p>不加什么控制，程序代码都是从上到下，依次执</p>
<h4 id="if分支："><a href="#if分支：" class="headerlink" title="if分支："></a>if分支：</h4><h5 id="两个注意点："><a href="#两个注意点：" class="headerlink" title="两个注意点："></a>两个注意点：</h5><ol>
<li>如果条件执行体只有一条语句，条件执行体的花括号可以省略。<br>如果省略了花括号，<strong>if条件只控制到紧跟if条件的第一个分号。</strong></li>
<li>else。否则，就是对前面条件取反<br>建议：如果if语句中有多个else if块，一定要先处理范围小的条件</li>
</ol>
<h4 id="switch分支："><a href="#switch分支：" class="headerlink" title="switch分支："></a>switch分支：</h4><p>switch(表达式){</p>
<p>​    case 值1：</p>
<p>​                    执行体</p>
<p>​                    break；</p>
<p>​    case 值2：</p>
<p>​                    执行体</p>
<p>​                    break;</p>
<p>…………………………</p>
<p>​    default:</p>
<p>​                    执行体</p>
<p>​                    brake;</p>
<p>}</p>
<p>程序会计算switch表达式的值，表达式的值等于哪个case块，就执行哪个case块。</p>
<p>如果都不等于，就执行default块</p>
<p>Java的switch不能处理范围！</p>
<h5 id="两个注意点：-1"><a href="#两个注意点：-1" class="headerlink" title="两个注意点："></a>两个注意点：</h5><ol>
<li>switch分支的表达式之鞥是byte、char、short、int、枚举、Strin（从java7开始才可以）这六个类型。</li>
<li>如果不写break，会发生贯穿，<br>贯穿：java会从第一个匹配的case块开始执行，在遇到break之前，直接忽略case值执行每个case块的代码</li>
</ol>
<h3 id="循环分支"><a href="#循环分支" class="headerlink" title="循环分支"></a>循环分支</h3><h4 id="while循环："><a href="#while循环：" class="headerlink" title="while循环："></a>while循环：</h4><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><p>while(条件){</p>
<p>​        // 循环体</p>
<p>}</p>
<p>程序首先判断循环条件，如果循环条件为true，执行循环体；</p>
<p>循环体执行完后，再次判断循环条件，如果循环条件Wietrue，执行循环体；</p>
<p>直到最后一次判断，循环条件为false，结束循环。</p>
<p>循环条件执行次数 == 循环体执行次数 + 1</p>
<p>死循环：无限循环，永远不会停止的循环。</p>
<h5 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h5><ol>
<li><p>如果循环体只有一条语句，那么循环体 的花括号可以省略</p>
<p>如果省略了花括号，while条件只控制到紧跟while条件的第一个分号。</p>
</li>
</ol>
<h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h4><h5 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h5><p>do{</p>
<p>​    // 循环体</p>
<p>}while (条件)</p>
<p>程序先执行一次循环体。</p>
<p>循环体执行完之后，再次判断循环条件，如果循环条件为true，执行循环体；</p>
<p>知道最后一次判断，循环条件为false，结束循环。</p>
<p>循环条件执行次数 == 循环体执行次数</p>
<h5 id="特征：即使循环条件开始就是false，循环体也会执行一次。"><a href="#特征：即使循环条件开始就是false，循环体也会执行一次。" class="headerlink" title="特征：即使循环条件开始就是false，循环体也会执行一次。"></a>特征：即使循环条件开始就是false，循环体也会执行一次。</h5><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><p>语法：</p>
<p>for([初始化语句]; [循环条件] ; [迭代语句]){</p>
<p>​        // 循环体</p>
<p>}</p>
<p>所有循环开始前，先执行初始化语句，只执行一次。</p>
<p>程序判断循环条件，如果循环条件为true，执行循环体；</p>
<p>循环体执行完后，执行迭代语句，然后再次判断循环条件 ，如果循环条件为true，执行循环体</p>
<h5 id="for循环的几个用法："><a href="#for循环的几个用法：" class="headerlink" title="for循环的几个用法："></a>for循环的几个用法：</h5><ol>
<li><p>for循环中，只有两个分号是必须的，其他都是可以省略的。</p>
<p>如果省略循环条件，循环条件永远都是true。</p>
<p>一定要写条件语句，不写的话就是死循环了。</p>
</li>
<li><p>尽量不要在循环体内改变循环计数器的值</p>
</li>
<li><p>初始化语句也可以初始化多个变量，只要它们的数据类型相同即可。<br>迭代语句也可以有多条，多条迭代语句之间用逗号隔开即可。</p>
</li>
</ol>
<h4 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h4><p>循环里再次放置循环，此时里层循环相当于外层循环的一条语句</p>
<h4 id="break终止结束"><a href="#break终止结束" class="headerlink" title="break终止结束"></a>break终止结束</h4><p>结束循环，跳出循环，break可以带标签，用于结束标签所代表的循环</p>
<h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p>忽略本次循环continue后面的语句，重新开始执行下一次循环</p>
<p>所以：不带标签的continue语句，如果是循环体的最后一行，那是没有任何意义的</p>
<p>continue可以带标签，用于忽略标签所代表的循环，重新开始下一次标签所代表的循环</p>
<h4 id="return"><a href="#return" class="headerlink" title="return"></a>return</h4><p>结束方法</p>
<p>循环总是位于方法中的，return既然可以结束方法，无论他在多深的循环里，他可以直接结束</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mr8god.cn/2020/04/09/Java/Java%E6%B7%B1%E8%80%95/Java%E6%B7%B1%E8%80%95%E2%80%94%E2%80%94%E5%88%9D%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mr8god">
      <meta itemprop="description" content="Just learning！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr8god's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/09/Java/Java%E6%B7%B1%E8%80%95/Java%E6%B7%B1%E8%80%95%E2%80%94%E2%80%94%E5%88%9D%E7%AB%A0/" class="post-title-link" itemprop="url">Java深耕——初章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-09 15:49:15" itemprop="dateCreated datePublished" datetime="2020-04-09T15:49:15+08:00">2020-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 23:51:25" itemprop="dateModified" datetime="2020-04-14T23:51:25+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java——初章"><a href="#Java——初章" class="headerlink" title="Java——初章"></a>Java——初章</h1><p>Java是一种面向对象编程(OOP)的语言。<br>掌握Java需要付出的代价就是，思考对象的时候，需要采用 形象思维（一种抽象思维），而不是程序化的思维。<br>特别是在尝试创建可重复使用（可再生） 的对象的时候，我们都会面临着一项痛苦的抉择。<br>事实上，正是由于这样的特性，很难有人能够设计出完美的东西，只有一些Java的编程专家才能编写出可以让大多数人使用的代码，而我江某人学习编程的目的就在于此，成为编程专家。</p>
<p>初章主要是描述了Java的多项设计思想，并从概念上解释面向对象的程序设计。</p>
<h2 id="抽象概念的由来"><a href="#抽象概念的由来" class="headerlink" title="抽象概念的由来"></a>抽象概念的由来</h2><h3 id="抽象方法是怎么出现的呢？"><a href="#抽象方法是怎么出现的呢？" class="headerlink" title="抽象方法是怎么出现的呢？"></a>抽象方法是怎么出现的呢？</h3><p>​        起因是我们在解决实际问题的时候发现每一类问题都有其自己的特征。而我们在C或一切其他语言中学到的都只是根据一类问题设计一套方法来解决它。以至于当超出这个问题的时候，方法就会显得特别笨拙。<br>​        面向对象的程序设计就是在以上基础跨出一大步。我们利用一些概念去描述表达实际问题中的元素。我们利用“<strong>对象</strong>”这个概念建立起实际问题和方法之间的联系。如果一些问题在后期出现了更多的问题，我们就可以相应的在代码中加入其它对象<br>通过添加新的对象类型，程序可以灵活的进行调整。与特定的问题打配合。从而达到解决问题的目的。<br>​        毫无疑问，<strong>面向对象程序设计语言</strong>是一门灵活、强大的语言抽象方法。它允许我们<strong>根据问题来描述问题，而不是单纯地根据方案。</strong></p>
<h4 id="OOP面向对象程序设计的特征"><a href="#OOP面向对象程序设计的特征" class="headerlink" title="OOP面向对象程序设计的特征"></a>OOP面向对象程序设计的特征</h4><p>通过上面讲述的这些特征，我们可以理解“纯粹”的面向对象程序设计方法是什么样子的：<br>(1)    所有东西都是对象。可以将对象想象成一种新型变量；它保存着数据，但可要求它对它自身进行一些操作，比如说增加点方法，增加点变量。理论上来讲，我们可以从问题中找出所有概念性的东西，然后在我们的程序中将其表达为一个对象。</p>
<p>(2)    程序将会是一大堆对象的组合；通过对象与对象之间的消息传递（传参），各个对象都知道自己该干什么，不该干什么。为了向另外一个对象发出请求，就需要向那个对象发送消息。<strong>具体来讲</strong>，我们可以将消息想象为一个调用请求，它调用的是从属于目标对象的一个子例程或函数。</p>
<p>(3)    每个对象都有自己的存储空间，可以容纳其他对象。或者是通过封装现有对象，进而制造出新的对象。所以尽管先前我们讲的对象看起来很简单，其实在每一个程序中，这些概念都能上升到一个任意高的复杂程度。</p>
<p>(4)    每个对象都有一种类型。根据Java的基本语法，每个对象都是某一个“类”的一个“实例”。而不同类与类之间的区别是什么呢？我抽象地讲，是“<strong>能将什么消息发给它？</strong>”</p>
<p>(5)    <strong>同一类的所有对象都能接收相同的消息。</strong>举例子举例子，这边有圆（Circle）、形状（Shape）两个类。由于圆其实也是形状嘛，我可以这样说，圆（Circle）的一个对象也属于类型为形状（Shape）的一个对象，所以一个圆能够完全接收来自形状（Shape）的任意消息。这就意味着我们可以让程序代码统一指挥形状（Shape），令其自动控制所有符合形状（Shape）描述的对象，其中自然包括圆（Circle）类的那个对象。这一特性叫做对象的”可替换性“，是OOP最重要的概念之一。</p>
<h2 id="对象的接口"><a href="#对象的接口" class="headerlink" title="对象的接口"></a>对象的接口</h2><p>上头我已经为大家引入了类与对象的概念，其实很好理解。类就相当于一样东西，比如说程序员就是一类。而对象呢，按照程序员类来说，这边的对象就是具体的一个程序员，比如说我江某人，就是一个程序员类的对象。</p>
<p>​        每一个对象都隶属于一个特定的“类”，那个类具有自己的通用特征与行为。</p>
<p>​        我们该如何让对象完成真正有用的工作呢？比如说让我江某人程序员对象完成一个C++的代码工作。我们可以在类中定义“<strong>接口</strong>”，对象的“类”就规定了它的接口形式。“类”和“接口”的等价或对应关系就是面向对象程序设计的基础。</p>
<p>​        下面来一个图解</p>
<p><img src="https://i.loli.net/2020/04/11/MvF6VlU21SKIfdh.jpg" alt="接口的讲解.jpg"></p>
<p>在上面这个图解中，，类的名字叫做Light，我们可以向Light对象发出的请求包括有打开（on）、关闭（off）、变得更明亮（brighten）、变得更黯淡（dim）。我们可以简单地声明一个名字（lt），我们为Light对象创建了一个“句柄”（就是名字，咱们对象的名字，在这边名字就叫做lt），这里边lt，也就是咱们的句柄，指向了刚刚新建的对象。然后我们用new关键字新建类型为Light的一个对象。再用等号将其赋值给句柄。</p>
<p>​        为了向对象发送一条消息，我们使用下面的格式来将句柄名、句点符号、和消息名称（on、off之类的）连接起来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lt.on();</span><br></pre></td></tr></table></figure>
<h2 id="实现方案的隐藏"><a href="#实现方案的隐藏" class="headerlink" title="实现方案的隐藏"></a>实现方案的隐藏</h2><p>这部分我将谈谈我们为什么要隐藏我们的类成员，类中的方法</p>
<p>​        首先我想就程序员的分类来讲，目前使用面向对象程序设计语言的程序员主要是分为两类的，一类是类的创建者，一类是类的使用者。前者制造出了包含各种使用的类包，后者会用前者的类包，解决各种问题。</p>
<p>​        这个时候，我们就需要考虑一个问题了，类创建者创建的类包里不能所有东西都能被使用者调用呀。如果任何人都能使用一个类的所有成员，那么使用者就可以对那个类做出任何事情。即使是一些不能够给使用者使用的类内包含的一些成员。如若不能进行控制的话，就没有办法组织这一情况的发生。</p>
<h3 id="为啥要控制类中成员的访问权限呢？"><a href="#为啥要控制类中成员的访问权限呢？" class="headerlink" title="为啥要控制类中成员的访问权限呢？"></a>为啥要控制类中成员的访问权限呢？</h3><p>综上，我们有两方面的原因促使我们需要对类中成员的访问权限进行控制。<br>原因一：防止使用者程序员接触他们不该接触的东西——通常是一些内部数据类型的设计思想。若只是为了使用类包解决问题，用户只需要操作接口就行了，不需要明白这些信息。我们向用户提供的实际是一种服务。<br>原因二：允许类包设计人员修改内部结构，不用担心它对使用者程序员造成影响。假如我们（类设计程序员）最开始写了一个简单的类包，以便简化开发。以后又决定进行改写，使其更快地运行。若接口与实现方法早已经隔离开了，并分别受到保护，就可以放心做到这一点。</p>
<h3 id="Java如何实现控制呢？"><a href="#Java如何实现控制呢？" class="headerlink" title="Java如何实现控制呢？"></a>Java如何实现控制呢？</h3><p>Java采用三个显式（明确）关键字以及一个隐式（暗示）关键字来设置类边界：public、private、protected 以及暗示性的friendly。若未明确指定其他关键字，则默认为后者。</p>
<p>解释这些关键字：</p>
<p>public（公共）：意味着后续的定义，任何人均可使用。<br>private（私有）：意味着除您自己、类型的创建者以及那个类型的内部函数成员之外，其他任何人都不能访问后续的定义信息。private在类创建者和类使用者之间竖起了一堵墙。若有人试图调用，便会在编译期报错。<br>friendly（友好的）涉及“包装”或“封装”（Package）的概念——即Java用来构建库的方法。若某样东西是“友好的”，意味着它只能在这个包装的范围内使用（所以这一访问级别有时也叫做“包装访问”）<br>protected（受保护的）：与“private”相似，只是一个继承的类就可以访问咱们的受保护成员，但是依旧不能访问私有成员。</p>
<h2 id="方案的重复使用"><a href="#方案的重复使用" class="headerlink" title="方案的重复使用"></a>方案的重复使用</h2><p>创建并测试好一个类后，这个好不容易创建好的类其实往往有很多缺点。只有较多经验以及洞察力的人才能 设计出一个好的方案。</p>
<p>​        为了重复使用一个类，最简单的方法就是仅直接使用那个类的对象。同时也将那个类的一个对象植入一个新类中。我们把这叫做“创建一个成员对象”。新类可以由任意数量和类型的其他对象构成。这个概念叫做“组织”——在现有类的基础上组织一个新类。有时组织也称为“包含”关系，比如“一辆车包含了一个变速箱”</p>
<p>​        对象的组织具有极大的灵活性。新类的“成员对象”通常设为“私有”，使用这个类的使用者程序员不能访问它们。</p>
<h2 id="继承：重新使用接口"><a href="#继承：重新使用接口" class="headerlink" title="继承：重新使用接口"></a>继承：重新使用接口</h2><p>当我们费尽心思做出一种数据类型之后，加入不得不又新建一种类型，令其实现大致相同的功能，那会是一件很麻烦的事情。但是若能利用已有的数据类型，对其进行“克隆模仿”，再根据实际情况进行添加或修改，那情况就会好多了。“继承”正是针对这个目标而设计的。但是继承并不完全等价于克隆。在继承的过程中，如果父类发生了变化，子类（继承后产生的新类）也会反映出这种变化。</p>
<p>在Java中继承是通过extends关键字实现的。使用继承时，相当于创建了一个新类。这个新类不仅包含了现有类型的所有成员（除了不能被访问的private成员）。其中最最重要的是它还复制了父类的接口。也就是说，能向父类发送的消息，亦可原样发给子类的对象。</p>
<p>由于父类和子类拥有相同的接口了，但是我们的子类不能一模一样呀，那样还跟父类有什么区别？为了做出区分，所以那个接口也必须进行特殊的设计。下面讲一下两种区分父类和子类的方法：</p>
<h3 id="区分父类子类的方法"><a href="#区分父类子类的方法" class="headerlink" title="区分父类子类的方法"></a>区分父类子类的方法</h3><p><strong>方法一</strong>：为子类添加新函数（功能）。这些新函数并非父类接口的一部分。为什么会有这种方法的出现呢？一般是因为我们发现父类原有的功能已经不能满足我们的需求了，于是我们就要添加更多的函数。这是一种最简单最基本的继承用法。</p>
<p><strong>方法二</strong>：近看extends关键字看上去是让我们要为接口“扩展”新功能，但实情并非肯定得照办。为了区分我们的新类，第二个办法就是改变父类，“改善”父类。</p>
<h3 id="改善父类"><a href="#改善父类" class="headerlink" title="改善父类"></a>改善父类</h3><p>为了改善一个父类，我们无非就是改善父类中的函数（或者叫方法），那么我们相应的只需要在子类中的函数中建立一个新的定义就可以了。我们的目标是：”尽管使用的函数接口未变，但他的新版本具有不同的表现“，但是万物没有这么绝对，我们还有另外情况，这边引用两个概念：<strong>等价关系</strong>和<strong>类似关系</strong></p>
<p>等价关系：子类完全照搬父类的所有的东西<br>类似关系：我们在子类中新加入了新的东西，那是原来父类中没有的东西。新的子类依旧拥有旧的父类的接口，但也包含了其他一些新的东西。所以就变成了不是上面所说的那种“等价关系”。</p>
<p>举一个例子：假定我有一个房间，房间连好了用于制冷的各种控制装置，用程序员思维来看，就是说我们已经拥有了必要的“接口”来控制制冷。现在假设我们的制冷机坏掉了，于是我将它换成了一台新型的冷、热两用空调，冬天制热、夏天制冷嘛。冷热空调“<strong>类似</strong>“制冷机，但是能做更多的事情。但是呢，由于我们的房间只安装了控制制冷的设备”<strong>接口</strong>“，所以”<strong>接口</strong>“们只能同新机器的制冷部分打交道。新机器的接口已得到扩展，但现有的系统并不知情，也不能够接触除了原始接口以外的任何东西。</p>
<p>当我们明确了等价和类似两种概念之后，以后在面对情况的时候就可以合理选择了。</p>
<h2 id="多形对象的互换使用"><a href="#多形对象的互换使用" class="headerlink" title="多形对象的互换使用"></a>多形对象的互换使用</h2><p>继承的结果往往会是创造了一系列的类，而这所有的类都是建立在统一的接口基础上的。如图</p>
<p><img src="https://i.loli.net/2020/04/11/DlvLfm5qPKnFzpX.jpg" alt="向上转型的形象描述.jpg"></p>
<p>这边要讲一个很重要的概念了哈，我们一定要把子类的对象当做父类的对象来对待。这一点是非常重要的。这就意味着我们只需编写代码就行了，不需要注意类的特定细节，只与父类打交道。</p>
<p>根据图例我们可以看到通过集成，这边有三个子类。那么我们为三个子类新编写的代码也会像在父类中那样良好工作。所以说程序具备了“扩展能力”，具有扩展性。</p>
<p>假设我们新加了一个函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doStuff</span><span class="params">(Shape s)</span>&#125;</span>&#123;</span><br><span class="line">	s.erase();</span><br><span class="line">	<span class="comment">// 等等等等等</span></span><br><span class="line">	s.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一个函数可以用途任何“几何形状”（Shape）通信，例如我这边又安排了一个代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Circle c = <span class="keyword">new</span> Circle();</span><br><span class="line">Triangle t = <span class="keyword">new</span> Triangle();</span><br><span class="line">Line l = <span class="keyword">new</span> Line();</span><br><span class="line">doStuff(c);</span><br><span class="line">doStuff(t);</span><br><span class="line">doStuff(l);</span><br></pre></td></tr></table></figure>
<p>这边我就分析一下doStuff(c)这串代码的意思（事实就是：我确实后边安排了这个代码）<br>此时，一个Circle句柄传递给了一个本来期待Shape句柄的函数。但是由于咱们的圆也是一种几何形状，所以doStuff()能够正确地进行处理。也就是说，凡是doStuff()能发给一个Shape的消息，Circle也能接收。所以这样子写是正确的，不会有报错。</p>
<p>我们把这种生成子类的方法叫做向上转型。向上是因为继承的方向是从“上面”来的——即父类位于顶部，子类在下方展开。</p>
<p>注意了哦，doStuff()里面的代码，它并非是这样表达的：”如果你是一个Circle，就这样作；如果你是一个Square，就按照那样做；等等诸如此类“。若那样子写代码的话，得累死你，就需要检查Shape所有可能的类型，如圆、矩形、四边形等等等等。这显然是非常麻烦的，而且每次添加了一种新的Shape类型后，都要相应地进行修改，在这里，我们只需要这样做：”你是一种几何形状，我知道你能将自己删掉（即代码里面的erase()），请自己放手去干吧，并且自己去控制所有的细节吧。“</p>
<p>这边我写了三个代码有助于我们理解：</p>
<p>代码一（Shape父类）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.shape;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/1120:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        out.println(<span class="string">"我是父类中的draw()方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        out.println(<span class="string">"我是父类中的erase()方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        out.println(<span class="string">"我是父类中的move()方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        out.println(<span class="string">"我是父类中的getColor()方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        out.println(<span class="string">"我是父类中的setColor()方法"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码二（Circle继承类）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.shape;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/822:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doStuff</span><span class="params">(Shape s)</span></span>&#123;</span><br><span class="line">        s.erase();</span><br><span class="line">        out.println(<span class="string">"我是来自子类Circle里边的doStuff方法。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码三（ShapeTest类）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.shape;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ Mr8god</span></span><br><span class="line"><span class="comment"> * @ 2020/4/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShapeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shape sh = <span class="keyword">new</span> Shape();</span><br><span class="line"></span><br><span class="line">        sh.draw();</span><br><span class="line">        sh.erase();</span><br><span class="line">        sh.move();</span><br><span class="line">        sh.getColor();</span><br><span class="line">        sh.setColor();</span><br><span class="line"></span><br><span class="line">        Circle ci = <span class="keyword">new</span> Circle();</span><br><span class="line">        ci.draw();</span><br><span class="line">        ci.erase();</span><br><span class="line">        ci.move();</span><br><span class="line">        ci.getColor();</span><br><span class="line">        ci.setColor();</span><br><span class="line">        ci.doStuff(ci);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自此输出：</p>
<p><img src="https://i.loli.net/2020/04/11/C8uPNOlLZbco4G7.jpg" alt="向上转型代码的输出.jpg"></p>
<h2 id="如何实现控制访问"><a href="#如何实现控制访问" class="headerlink" title="如何实现控制访问"></a>如何实现控制访问</h2><p>Java用三个关键字在类的内部设定边界：public、private、protected。这些访问指定词决定了紧跟其后被定义的东西可以被谁使用。</p>
<p>public：表示紧随其后的元素对任何人都是可用的</p>
<p>private：这个关键字表示除类型创建者和类型的内部方法之外的其他任何人都不能访问的元素。private就像你与使用类的程序员之间的一堵墙，如果有人试图访问private成员，就会在编译期间得到错误信息。</p>
<p>protected：这个关键字与private作用相当，差别仅在于继承的类可以访问protected成员，但是不能访问private成员。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mr8god.cn/2020/04/08/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94final%E5%8F%98%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mr8god">
      <meta itemprop="description" content="Just learning！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr8god's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/08/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94final%E5%8F%98%E9%87%8F/" class="post-title-link" itemprop="url">Java速记——final变量</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-08 15:49:15" itemprop="dateCreated datePublished" datetime="2020-04-08T15:49:15+08:00">2020-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 23:53:15" itemprop="dateModified" datetime="2020-04-14T23:53:15+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java速记——final变量"><a href="#Java速记——final变量" class="headerlink" title="Java速记——final变量"></a>Java速记——final变量</h1><p>可以修饰变量（各种变量）、方法、类。</p>
<p>final和abstract是互斥的：永远都不能够同时出现！</p>
<h2 id="final修饰变量"><a href="#final修饰变量" class="headerlink" title="final修饰变量"></a>final修饰变量</h2><p>作用：该变量被赋初始值之后，不能被重新赋值！<br>            final修饰的变量<strong>必须</strong>被赋值，且只能被赋值<strong>一次</strong></p>
<h2 id="final修饰成员变量"><a href="#final修饰成员变量" class="headerlink" title="final修饰成员变量"></a>final修饰成员变量</h2><p>普通成员变量（非final的成员变量），程序员可以不显式指定初始值，系统会为之分配默认初始值，初始值分配规则与数组元素的初始值分配规则完全相同！</p>
<p>final 成员变量，程序员必须显式指定初始值</p>
<ul>
<li><p>final实例变量，必须显式指定初始值，<strong>只能指定一次</strong>。<strong>只能在以下三个位置的其中之一指定：</strong></p>
<ul>
<li>定义时指定为初始值。</li>
<li>实例初始化块</li>
<li>每个构造器都需要显示指定一次初始值</li>
</ul>
<p>上面3个位置的本质其实只有一个，就是构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Final</span>实例变量 </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        age = 24;// 这边错误，被final修饰的成员变量不能被赋值两次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我们这样写就没有问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Final</span>实例变量 </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line">    &#123;</span><br><span class="line">        age = <span class="number">24</span>;<span class="comment">// 这边错误，被final修饰的成员变量不能被赋值两次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再一个正确示范</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Final</span>实例变量 </span>&#123;</span><br><span class="line">    <span class="comment">// final实例变量必须显式指定初始值，而且只能在3个位置中指定</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> lg;</span><br><span class="line">    <span class="keyword">public</span> Final实例变量()</span><br><span class="line">    &#123;</span><br><span class="line">        lg = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>final类变量，必须显示指定初始值。只能在以下2个位置的其中之一指定：</p>
<ul>
<li>定义时指定初始值</li>
<li></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mr8god.cn/2020/04/08/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mr8god">
      <meta itemprop="description" content="Just learning！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr8god's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/08/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/" class="post-title-link" itemprop="url">Java速记——抽象类和接口</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-08 15:49:15" itemprop="dateCreated datePublished" datetime="2020-04-08T15:49:15+08:00">2020-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 23:53:30" itemprop="dateModified" datetime="2020-04-14T23:53:30+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java速记——抽象类和接口"><a href="#Java速记——抽象类和接口" class="headerlink" title="Java速记——抽象类和接口"></a>Java速记——抽象类和接口</h1><ul>
<li>abstract关键字</li>
<li>抽象类</li>
<li>接口</li>
<li>JDK1.8/1.9接口的新特性</li>
<li>抽象类和接口的比较</li>
<li>面向对象的七个原则</li>
</ul>
<h2 id="abstract关键字"><a href="#abstract关键字" class="headerlink" title="abstract关键字"></a>abstract关键字</h2><p>主要修饰类和方法<br>一个方法没有方法体，就是抽象方法了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAbstract</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个类包含了抽象方法，那么这个类必须就是抽象类</p>
<p>务必要记得，有花括号就是方法体。是一个方法声明占位，具体实现留待子类覆盖/重写</p>
<p>如果类里边没有抽象方法，类也可以是抽象类——抽象类可以没有抽象方法</p>
<p>抽象类不能够使用new初始化对象；如果我不想让别人实例化我的类，就可以采用抽象类的方法。</p>
<p>举个例子：目前我们所学的Calendar类就是一个典型的抽象类，她只有一个静态方法——getInstance()——作用：根据当前的Date获得日历对象。</p>
<p>全局变量是强耦合为什么不好的一个典型的例子，比如你修改了全局变量的类型，则所有使用该变量的代码会受到影响，因此必须检查、修改和重新测试所有这些代码。不仅如此，所有使用该变量的方法都将通过该变量而彼此耦合</p>
<p>我们要<strong>适度耦合</strong></p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Java中，接口有两种意思：</p>
<ol>
<li>是指概念性的接口，即指系统对外提供的所有服务，类的所有能够被外部使用者访问的方法构成了类的接口</li>
<li>是指用interface关键字定义的实实在在的接口哦，也称为接口类型</li>
</ol>
<p>interface：不怎么提属性，操作，只提这个对象对外提供的功能<br>举例：电视机（按钮接口、红外接口：遥控器）、洗衣机（控制面板、洗衣）</p>
<p>对于接口来说，只有public、static、final常量，没有实例变量</p>
<p>JDK1.8之前，一定是抽象方法，不需要使用abstract关键字修饰，接口中的内容可见性默认是public，无论是否用public</p>
<p>类和接口之间要使用implements关键字（UML：实现realization），意味着类实现了某个接口，类就有这个接口的功能了</p>
<h3 id="接口的作用"><a href="#接口的作用" class="headerlink" title="接口的作用"></a>接口的作用</h3><ul>
<li>声明期望实现一个或更多的类的方法</li>
<li>确定对象的编程接口而无需显示类的实际主体</li>
<li>捕捉非相关类之间的相似性而无需强制类的关系</li>
<li>通过声明实现几个接口的类来模拟多重继承</li>
</ul>
<h2 id="JDK8的新特性"><a href="#JDK8的新特性" class="headerlink" title="JDK8的新特性"></a>JDK8的新特性</h2><p>增加了默认方法</p>
<p>如果我们要改接口的话，那么我们使用了接口的所有类都需要更改；</p>
<p>方法冲突<br>一个类可以实现多个接口，也就是说有可能会发生默认方法冲突</p>
<ul>
<li>类中的方法优先级最高</li>
<li>如果无法根据第一条进行判断，那么子接口的优先级更高；函数签名相同时，优先选择拥有最具体实现的默认方法的接口，即如果B继承了A，那么B就比A更加具体</li>
<li>最后如果还是无法判断，实现多个接口的类必须<ul>
<li>创建自己的默认方法，来覆盖重写接口的默认方法</li>
<li>使用super调用指定接口的默认方法</li>
</ul>
</li>
</ul>
<h2 id="JDK1-9的新特性"><a href="#JDK1-9的新特性" class="headerlink" title="JDK1.9的新特性"></a>JDK1.9的新特性</h2><p>Java9不仅像Java8一样支持接口默认方法，同时还支持私有方法。<br>在Java9中，一个接口中能定义如下集中变量/方法</p>
<ul>
<li>常量</li>
<li>抽象方法</li>
<li>默认方法</li>
<li>静态方法</li>
<li>私有方法：private</li>
<li>私有静态方法：private static</li>
</ul>
<h2 id="关于抽象类，我再补补课"><a href="#关于抽象类，我再补补课" class="headerlink" title="关于抽象类，我再补补课"></a>关于抽象类，我再补补课</h2><p>abstract（抽象），它只能修饰两个东西：</p>
<ul>
<li>方法（抽象方法）</li>
<li>类（抽象类）</li>
</ul>
<p>emmmmm，这边加一个<strong>惨痛经验</strong>，<strong>抽象类的抽象方法，务必不能有方法体</strong><br>这很好理解：我们的抽象类是要给别人去重写的，如果我们给了，那还让人家咋重写，emmmmm，我暂时就这么记了！</p>
<p>abstract与final是<strong>互斥</strong>的！</p>
<p> 抽象类的特征：有得有失。<br>抽象类与普通类的区别只有4个字：有得有失。</p>
<ul>
<li><p>有得：得到一个新功能：抽象类可以拥有这个抽象方法。</p>
</li>
<li><p>有失：抽象类失去了一个功能：创建对象</p>
</li>
</ul>
<h3 id="抽象类必须有构造器"><a href="#抽象类必须有构造器" class="headerlink" title="抽象类必须有构造器"></a>抽象类必须有构造器</h3><p>因为抽象类的主要功能是：派生子类；因为子类的构造器一定会调用父类的构造器一次，因此抽象类必须有构造器。<br>而咱们的final是不能有子类，这就是与abstract互斥的原因啦</p>
<h4 id="抽象类里边可以没有抽象方法吗？"><a href="#抽象类里边可以没有抽象方法吗？" class="headerlink" title="抽象类里边可以没有抽象方法吗？"></a>抽象类里边可以没有抽象方法吗？</h4><p>可以的！</p>
<h4 id="抽象类里边能不能没有构造器呀？"><a href="#抽象类里边能不能没有构造器呀？" class="headerlink" title="抽象类里边能不能没有构造器呀？"></a>抽象类里边能不能没有构造器呀？</h4><p>可以的！</p>
<h4 id="抽象类里边能不能没有初始化块呀？"><a href="#抽象类里边能不能没有初始化块呀？" class="headerlink" title="抽象类里边能不能没有初始化块呀？"></a>抽象类里边能不能没有初始化块呀？</h4><p>可以的！</p>
<h4 id="抽象类里边能不能有成员变量呀？"><a href="#抽象类里边能不能有成员变量呀？" class="headerlink" title="抽象类里边能不能有成员变量呀？"></a>抽象类里边能不能有成员变量呀？</h4><p>可以的！</p>
<h4 id="抽象类里边能不能有类变量呀？"><a href="#抽象类里边能不能有类变量呀？" class="headerlink" title="抽象类里边能不能有类变量呀？"></a>抽象类里边能不能有类变量呀？</h4><p>可以的！</p>
<h4 id="上面开个玩笑哈，只要记住普通类有的，抽象类全都有，只是不能创建对象而已"><a href="#上面开个玩笑哈，只要记住普通类有的，抽象类全都有，只是不能创建对象而已" class="headerlink" title="上面开个玩笑哈，只要记住普通类有的，抽象类全都有，只是不能创建对象而已"></a>上面开个玩笑哈，只要记住普通类有的，抽象类全都有，只是不能创建对象而已</h4><h3 id="抽象方法：只有方法签名，没有方法体的方法"><a href="#抽象方法：只有方法签名，没有方法体的方法" class="headerlink" title="抽象方法：只有方法签名，没有方法体的方法"></a>抽象方法：只有方法签名，没有方法体的方法</h3><p>只有抽象类才能拥有抽象方法，普通类不能有抽象方法</p>
<p>由于咱们的抽象方法没有方法体，那么很明显这就意味着，抽象方法一定要被子类去重写<br>与此相反的是咱们的final：final的意思是——你可不能重写我的方法哦！ </p>
<p>抽象方法，一定要交给子类去实现（比如说重写），否则不能调用！</p>
<h4 id="抽象类的作用"><a href="#抽象类的作用" class="headerlink" title="抽象类的作用"></a>抽象类的作用</h4><ol>
<li>定义变量。我们的抽象类不能创建实例对象，那么我们的抽象类定义之后要赋值的时候，只能用它的子类的实例。（用子类的实例对父类赋值，这叫做<strong>向上转型</strong>在多态时有学习到这个东西）</li>
<li>调用类方法和类变量</li>
<li>派生子类——主要目的</li>
</ol>
<h4 id="抽象类派生子类："><a href="#抽象类派生子类：" class="headerlink" title="抽象类派生子类："></a>抽象类派生子类：</h4><p>【得出推论规则】：子类要么重写父类中所有的抽象方法，要么子类也只能是抽象的。</p>
<h2 id="关于接口，我再补补课"><a href="#关于接口，我再补补课" class="headerlink" title="关于接口，我再补补课"></a>关于接口，我再补补课</h2><h3 id="关于接口的基本知识"><a href="#关于接口的基本知识" class="headerlink" title="关于接口的基本知识"></a>关于接口的基本知识</h3><p>接口相当于一种彻底抽象的类，（其实枚举也类似于一个类）<br>接口体现的是一种规范——要暴露出来供大家遵守的规范。<br>所以接口里的所有东西都用public修饰，不管你写还是不写，始终有public修饰。既然默认都有的话，我们其实可以不用写public修饰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] interface 接口名 extends 父接口1，父接口2，……</span><br><span class="line">&#123;</span><br><span class="line">		&#x2F;&#x2F; 没有成员变量，只有常量。默认总是会添加public、static、final修饰。		&#x2F;&#x2F; 既然默认都有，我们可以不写</span><br><span class="line">		&#x2F;&#x2F; 抽象方法。Java8之后，类方法、默认方法（抽象添加方法体）</span><br><span class="line">		&#x2F;&#x2F; 内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口是一种彻底抽象的类，抽象的类的话，那么抽象方法只能存在于抽象类。<br>接口里边只能有抽象方法，现在从Java8之后，接口开始有了类方法、方法体（可以说接口好像是被“污染了”，和以前的语法冲突了），但是呢，为了更大程度的和以前的方法体分开来，于是接口添加了<strong>默认方法</strong>这一概念。其实就是原来的<strong>抽象方法+方法体</strong></p>
<h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>默认方法就是实例方法，与原来抽象方法的规则完全一样，只不过抽象方法不能加方法体，于是默认方法加上default就可以加方法体了</p>
<p>接口里不能有初始化块，也不能有构造器</p>
<p>总结：接口里只有三大成员（常量、抽象方法、内部类）</p>
<p>接口的修饰符：public、<br>接口是彻底抽象，<strong>不能有final</strong>（final和抽象互斥）<br>抽象已经足够抽象了，因此不需要abstract更抽象了</p>
<p>【随处哔哔】private只能在类里边的类进行修饰，如果在外边那必是没有意义的呀</p>
<p>接口名：命名规范基本等同于类名。<br>                接口一般推荐使用形容词。<br>                （看看就好看看就好，我暂时还是看《阿里巴巴开发手册》）</p>
<h3 id="接口里的成员默认会添加public、static、final修饰"><a href="#接口里的成员默认会添加public、static、final修饰" class="headerlink" title="接口里的成员默认会添加public、static、final修饰"></a>接口里的成员默认会添加public、static、final修饰</h3><h4 id="final的变量初始化"><a href="#final的变量初始化" class="headerlink" title="final的变量初始化"></a>final的变量初始化</h4><p>final修饰的类变量必须在两个地方：定义的时候指定初始值、类初始化块指定初始值</p>
<p>但是接口里没有类初始化块，所以final修饰的变量（其实也是指定的啦，因为final默认在接口中的常量前面进行修饰的），那么很明显，我们默认用final修饰的变量一定且只能在指定初始值的时候进行指定（=）且进行赋初始值</p>
<h4 id="final的方法"><a href="#final的方法" class="headerlink" title="final的方法"></a>final的方法</h4><p>因为抽象类中的方法默认都是抽象方法，前头都戴着一定隐形的帽子（“abstract”），所以不用写abstract进行修饰</p>
<h3 id="接口的前世今生"><a href="#接口的前世今生" class="headerlink" title="接口的前世今生"></a>接口的前世今生</h3><h4 id="Java8以前的接口"><a href="#Java8以前的接口" class="headerlink" title="Java8以前的接口"></a>Java8以前的接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 所有成员变量前默认有public static final</span></span><br><span class="line">    <span class="keyword">int</span> MAX_PRESERVE = <span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 默认有public abstract ，也就是默认是public abstract void test();</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Java8之后的接口（有了main方法之后）"><a href="#Java8之后的接口（有了main方法之后）" class="headerlink" title="Java8之后的接口（有了main方法之后）"></a>Java8之后的接口（有了main方法之后）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前头默认public修饰</span></span><br><span class="line">    <span class="keyword">int</span> MAX_PRESERVE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认有public abstract</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Java8之后可以有static方法，所以就能定义main方法</span></span><br><span class="line">    <span class="comment">// 因此接口也可以直接运行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我再加点东西哈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前头默认public修饰</span></span><br><span class="line">    <span class="keyword">int</span> MAX_PRESERVE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面的public可以不写，但是static一定要写，因为不写就成了实例方法了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是类方法，因为我有static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【再随处哔哔】方法重载的规则是：两同一不同</p>
<ul>
<li>形参列表不同</li>
<li>方法名相同</li>
<li>修饰符不同</li>
</ul>
<h3 id="接口有什么用呢？"><a href="#接口有什么用呢？" class="headerlink" title="接口有什么用呢？"></a>接口有什么用呢？</h3><ul>
<li>定义变量，只能用实现类的实例来赋值（向上转型）</li>
<li>调用类方法或类变量</li>
<li>派生实现类</li>
</ul>
<h3 id="实现接口的语法是？"><a href="#实现接口的语法是？" class="headerlink" title="实现接口的语法是？"></a>实现接口的语法是？</h3><p>首先我们看一下完整的类的语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 父接口1，父接口2，………</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">		<span class="comment">// 五大成员		</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，上面的也是实现接口的语法了！嘿嘿嘿</p>
<p>重写接口中的方法只能用public修饰！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mr8god.cn/2020/04/07/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E5%8C%85%E8%A3%85%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mr8god">
      <meta itemprop="description" content="Just learning！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr8god's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/07/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E5%8C%85%E8%A3%85%E7%B1%BB/" class="post-title-link" itemprop="url">Java速记——包装类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-07 15:49:15" itemprop="dateCreated datePublished" datetime="2020-04-07T15:49:15+08:00">2020-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 23:54:26" itemprop="dateModified" datetime="2020-04-14T23:54:26+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java速记——包装类"><a href="#Java速记——包装类" class="headerlink" title="Java速记——包装类"></a>Java速记——包装类</h1><p>Java有8大基本类型：int、float、double、long、boolean、byte、char、short</p>
<p>这8个基本类型都不能当成对象使用，不是引用类型，而且也不能接受null值。null值只能赋值给引用类型。</p>
<p>为了解决上面的问题，Java为8个基本类型提供了对应的包装类——可将它们包装成对象。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>对应的包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>Int</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Char</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
</tbody>
</table>
</div>
<p><strong>自动装箱</strong>：基本类型的值可以自动当成包装类<br><strong>自动拆箱</strong>：包装类的实例可以自动当成基本类型的值使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关于自动装箱和自动拆箱的代码实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 包装类 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int i = null; // 基本类型不接受null值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2可以自动装箱成Integer</span></span><br><span class="line">        Integer in = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.3自动装箱Double，Double向上转型为</span></span><br><span class="line">        Object ob = <span class="number">2.3</span>;</span><br><span class="line"></span><br><span class="line">        Boolean b = <span class="keyword">true</span>;<span class="comment">// 自动装箱</span></span><br><span class="line"></span><br><span class="line">        Long lg = <span class="number">3L</span>;</span><br><span class="line"></span><br><span class="line">        Long result =  lg * in;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【建议】：做项目的时候，通常来说使用包装类来声明变量。<br>                    好处是：反正基本类型能做的，它都可以做；它还可以当成对象使用。还可以接受null</p>
<p>包装类的方法：<br>                方法可将字符串转成对应的基本类型值。</p>
<p>NumberFormatException：要转的字符串不符合数值格式，将会引发该异常。</p>
<p>当程序对Integer使用自动装箱时，它有一个缓存机制，它会缓存在-128 ~ 127之间的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">heiheihei</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i = <span class="number">20</span>; <span class="comment">// 在-128 ~ 127之间，缓存</span></span><br><span class="line">        Integer j = <span class="number">20</span>; <span class="comment">// 直接用缓存中对象。</span></span><br><span class="line">        System.out.println(i == j);</span><br><span class="line"></span><br><span class="line">        Integer c = <span class="number">204</span>; <span class="comment">// 不在-128 ~ 127之间，不缓存，因为这里边的204超过范围 了</span></span><br><span class="line">        Integer d = <span class="number">204</span>; <span class="comment">// 重新创建</span></span><br><span class="line">        System.out.println(c == d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<h2 id="两个要被重写的方法："><a href="#两个要被重写的方法：" class="headerlink" title="两个要被重写的方法："></a>两个要被重写的方法：</h2><h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>程序打印对象，或把对象自动转字符串的时候，实际上用的都是该对象的toString()方法的返回值。</p>
<p>【默认的toString】Object提供的toString返回的是类名@hashCode 方法返回值<br>重写toString：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// toString方法重写实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple123</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参数的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple123</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化全部成员变量的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple123</span><span class="params">(String color, <span class="keyword">double</span> weight)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.color;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">double</span> weight)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWeight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Apple[color="</span> + color</span><br><span class="line">                + <span class="string">", weight="</span> + weight</span><br><span class="line">                + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleTest1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple123 ap = <span class="keyword">new</span> Apple123(<span class="string">"红色"</span> , <span class="number">2.3</span>);</span><br><span class="line">        <span class="comment">// 程序打印对象，或把对象自动转字符串的时候，实际上用的都是该对象的toString()方法的返回值。</span></span><br><span class="line">        <span class="comment">// 下面两行代码是完全相同的</span></span><br><span class="line">        System.out.println(ap);</span><br><span class="line">        System.out.println(ap.toString());</span><br><span class="line"></span><br><span class="line">        Apple123 ap2 = <span class="keyword">new</span> Apple123(<span class="string">"蔡徐坤"</span> , <span class="number">188</span>);</span><br><span class="line">        System.out.println(ap2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任何对象 + ""，就会变成字符串</span></span><br><span class="line">        String str = ap2 + <span class="string">""</span>;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><p>== 如果判断两个引用变量，要求两个引用变量指向同一个对象时，才会返回true。</p>
<p>但是如果我们直接在main里用equals，还是false，原因是：<br>【默认的equals】Object提供的equals方法，判断两个对象相等的标准与 == 是完全一样的。<br>因此我们要重写equals：根据业务规则来提供两个对象相等的标准。<br>实际项目中，用来作为equals比较的关键成员变量，通常并不需要使用全部的成员变量<br>——只要用它们关键的成员变量即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equals方法重写实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参数的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化全部成员变量的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goat</span><span class="params">(String color, <span class="keyword">double</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// color的setter和getter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// weight</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// this和obj指向同一个对象</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要求obj不为null，且obj必须是Goat</span></span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp; obj.getClass() == Goat<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        </span>&#123;</span><br><span class="line">            Goat target = (Goat)obj;</span><br><span class="line">            <span class="comment">// 业务要求有几个关键属性，此处就比较几个关键属性，比如说这边只有一个color需要比较</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.color.equals(target.color)</span><br><span class="line">                    &amp;&amp; <span class="keyword">this</span>.weight == target.weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Goat goat1 = <span class="keyword">new</span> Goat(<span class="string">"黑色"</span> , <span class="number">78.2</span>);</span><br><span class="line">        Goat goat2 = <span class="keyword">new</span> Goat(<span class="string">"黑色"</span> , <span class="number">78.2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// goat1与goat2分别指向两个不同的对象，因此==判断返回false。</span></span><br><span class="line">        System.out.println(goat1 == goat2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写equals方法，根据业务规则来判断两个对象是否相等。</span></span><br><span class="line">        System.out.println(goat1.equals(goat2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h4 id="static并不是静态的意思。"><a href="#static并不是静态的意思。" class="headerlink" title="static并不是静态的意思。"></a>static并不是静态的意思。</h4><p>static是类的意思， 有static的成员属于类成员，没有static的成员属于势力成员</p>
<p>static是否可以修饰局部变量？——局部变量不属于成员，因此不能用static修饰。</p>
<p>static能否修饰外部类？ —— 外部类不属于成员，因此不能用static修饰。</p>
<h4 id="static修饰的成员：成员变量、方法、初始化块、内部类"><a href="#static修饰的成员：成员变量、方法、初始化块、内部类" class="headerlink" title="static修饰的成员：成员变量、方法、初始化块、内部类"></a>static修饰的成员：成员变量、方法、初始化块、内部类</h4><p>所有类成员，都只能用类名调用！</p>
<p>Java语法是不好，允许通过对象来调用类成员，是没有意义的 from 李刚老师</p>
<p>面试的笔试题中，如果遇到使用对象来调用类成员的情形，先把对象改成类——题目马上一目了然。</p>
<h4 id="static考点（笔试中非常常见）"><a href="#static考点（笔试中非常常见）" class="headerlink" title="static考点（笔试中非常常见）"></a>static考点（笔试中非常常见）</h4><p>static成员不能访问非static成员。<br>非static成员可以访问static成员！</p>
<p>static成员（4种）不能访问非static成员（5种：方法、变量、构造器、内部类、初始化块）；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 方法 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"info"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        info();//Error:(8, 9) java: 无法从静态上下文中引用非静态 方法 info()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 变量  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(age);//Error:(5, 28) java: 无法从静态上下文中引用非静态 变量 age</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 内部类 </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 静态访问，使用了非静态内部类</span></span><br><span class="line"><span class="comment">//        A a = new A();//Error:(9, 15) java: 无法从静态上下文中引用非静态 变量 this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 初始化块 </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;<span class="comment">// 静态成员</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        age = <span class="number">20</span>;<span class="comment">// 非静态成员</span></span><br><span class="line">        <span class="comment">//无法从静态上下文中引用非静态 变量 age</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 初始化块2 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"info 方法"</span>);<span class="comment">// 非静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        info();<span class="comment">// 静态成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 初始块3 </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>最早来自于建筑行业，早期优秀建筑设计师针对建筑给了很多优秀的建筑建议。比如房子有大窗户会更好一点，诸如此类的建筑建议</p>
<p>对于一批经常出现的设计场景，前人总结出来的比较成功的设计——这就是设计模式。<br>后面的人就应该学习、并模仿他们，从而提高我们的代码质量。</p>
<p>其中<strong>单例模式</strong>就是设计模式的一种：在某些场景下，某些类只需要（只能）创建一个实例。<br>比如系统的窗口管理器。只能有一个。<br>数据库引擎访问点，整个数据库，Java程序所在JRE环境……都只需要产生一个实例。<br>此时就应该采用单例模式</p>
<h3 id="如何设计单例模式？"><a href="#如何设计单例模式？" class="headerlink" title="如何设计单例模式？"></a>如何设计单例模式？</h3><ol>
<li>隐藏构造器——避免被创建实例</li>
<li>暴露一个static的方法，该方法用于创建实例<br>该方法还需要保证该类只会产生一个实例 </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line">    <span class="comment">// 构造器隐藏</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴露一个static方法，用于创建实例变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         Singleton s1 = Singleton.instance();</span><br><span class="line">         Singleton s2 = Singleton.instance();</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mr8god.cn/2020/04/07/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mr8god">
      <meta itemprop="description" content="Just learning！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr8god's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/07/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE/" class="post-title-link" itemprop="url">Java速记——面向对象快速回顾</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-07 15:49:15" itemprop="dateCreated datePublished" datetime="2020-04-07T15:49:15+08:00">2020-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 23:54:59" itemprop="dateModified" datetime="2020-04-14T23:54:59+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="面向对象快速回顾"><a href="#面向对象快速回顾" class="headerlink" title="面向对象快速回顾"></a>面向对象快速回顾</h1><p>345</p>
<p>3种类型：类、接口、枚举</p>
<p>4个修饰符：private|protected|public、final、static、abstract</p>
<p>5个成员</p>
<h2 id="定义类的语法"><a href="#定义类的语法" class="headerlink" title="定义类的语法"></a>定义类的语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 类名 extends 父类</span><br><span class="line">&#123;</span><br><span class="line">		&#x2F;&#x2F; 5大成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义成员变量"><a href="#定义成员变量" class="headerlink" title="定义成员变量"></a>定义成员变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 类型 变量名[ &#x3D; 初始值];</span><br></pre></td></tr></table></figure>
<h2 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 返回值类型 方法名（形参列表）</span><br><span class="line">&#123;</span><br><span class="line">		语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义构造器"><a href="#定义构造器" class="headerlink" title="定义构造器"></a>定义构造器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 构造器名（形参列表）</span><br><span class="line">&#123;</span><br><span class="line">			语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义初始化块"><a href="#定义初始化块" class="headerlink" title="定义初始化块"></a>定义初始化块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[static] &#123;</span><br><span class="line">	语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类用于干甚？"><a href="#类用于干甚？" class="headerlink" title="类用于干甚？"></a>类用于干甚？</h2><ul>
<li>定义变量</li>
<li>创建对象</li>
<li>调用类、方法或者是访问类变量</li>
<li>派生子类</li>
</ul>
<h2 id="对象用于干甚？"><a href="#对象用于干甚？" class="headerlink" title="对象用于干甚？"></a>对象用于干甚？</h2><ul>
<li>调用实例方法或访问实例变量</li>
</ul>
<h2 id="方法（传参机制、递归方法、形参个数可变的方法、方法重载）"><a href="#方法（传参机制、递归方法、形参个数可变的方法、方法重载）" class="headerlink" title="方法（传参机制、递归方法、形参个数可变的方法、方法重载）"></a>方法（传参机制、递归方法、形参个数可变的方法、方法重载）</h2><h2 id="变量（判断变量：先看位置，再看static；成员变量和局部变量）"><a href="#变量（判断变量：先看位置，再看static；成员变量和局部变量）" class="headerlink" title="变量（判断变量：先看位置，再看static；成员变量和局部变量）"></a>变量（判断变量：先看位置，再看static；成员变量和局部变量）</h2><h2 id="构造器（构造器重载、this调用）"><a href="#构造器（构造器重载、this调用）" class="headerlink" title="构造器（构造器重载、this调用）"></a>构造器（构造器重载、this调用）</h2><p>this调用——出现在构造器的第一行，表明调用同一个类中重载的构造器</p>
<h2 id="初始化块（实例初始化块、类初始化块）"><a href="#初始化块（实例初始化块、类初始化块）" class="headerlink" title="初始化块（实例初始化块、类初始化块）"></a>初始化块（实例初始化块、类初始化块）</h2><p>实力初始化块：本质是构造器所有代码之前的代码；</p>
<p>类初始化块：本质是该类第一次被主动执行时，只运行一次。</p>
<h2 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h2><p>private —&gt; 不写 —&gt; protected —&gt; public</p>
<h2 id="继承、多态"><a href="#继承、多态" class="headerlink" title="继承、多态"></a>继承、多态</h2><p>Java是单继承的。</p>
<p>方法重写：两同两小一大。</p>
<p>子类构造器一定会调用父类构造器一次：创建任何对象，都是从Object的构造器开始执行的。</p>
<p>多态中：</p>
<p>​    方法执行：总是动态绑定实际类型的方法。<br>​                        强制转换、instanceof - 必须在有继承关系的两个类型之间进行处理，否则会编译报错。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mr8god.cn/2020/04/06/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mr8god">
      <meta itemprop="description" content="Just learning！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr8god's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/06/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/" class="post-title-link" itemprop="url">Java速记——面向对象基础回顾</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-06 15:49:15" itemprop="dateCreated datePublished" datetime="2020-04-06T15:49:15+08:00">2020-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 23:55:32" itemprop="dateModified" datetime="2020-04-14T23:55:32+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java面向对象基础回顾"><a href="#Java面向对象基础回顾" class="headerlink" title="Java面向对象基础回顾"></a>Java面向对象基础回顾</h1><p>定义类、创建对象、调用方法</p>
<h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><pre><code>[修饰符] class 类名

{
    //成员变量

    //方法

    //构造器

    //初始化块

    //内部类
}
</code></pre><h2 id="定义成员变量"><a href="#定义成员变量" class="headerlink" title="定义成员变量"></a>定义成员变量</h2><p>[修饰符]    类型    变量名[ = 初始值]；</p>
<h2 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h2><pre><code>[修饰符]    返回值类型    方法名（形参列表）

{
    // 各种代码。定义变量、赋值语句、流程控制、输出语句
}
</code></pre><h2 id="定义构造器"><a href="#定义构造器" class="headerlink" title="定义构造器"></a>定义构造器</h2><pre><code>[修饰符]    构造器名（形参列表）

{
    // 各种代码。定义变量、赋值语句、流程控制、输出语句
}
</code></pre><p>构造器，很像一个特殊的方法</p>
<p>跟方法的两点区别：</p>
<ol>
<li>没有返回值类型声明，</li>
<li>构造器名必须类名相同。</li>
</ol>
<p>构造器作用：用于初始化对象——构造器永远属于实例。它不可能用static修饰。</p>
<h2 id="类可以用来干什么？"><a href="#类可以用来干什么？" class="headerlink" title="类可以用来干什么？"></a>类可以用来干什么？</h2><ol>
<li>定义变量。所有类都是引用类型。</li>
<li>调用类变量或类方法。</li>
<li>创建对象。</li>
<li>派生子类。</li>
</ol>
<h2 id="对象可以用来干什么？"><a href="#对象可以用来干什么？" class="headerlink" title="对象可以用来干什么？"></a>对象可以用来干什么？</h2><ol>
<li>调用实例变量</li>
<li>调用实例方法</li>
</ol>
<p>调用方法或变量：</p>
<pre><code>    调用者.方法([参数]);

    调用者.实例变量;
</code></pre><h2 id="方法详解"><a href="#方法详解" class="headerlink" title="方法详解"></a>方法详解</h2><ul>
<li>方法所属性。<ul>
<li>从定义的角度来看，方法不能独立定义，方法必须定义在类里面。</li>
<li>从调入的角度来看，方法不能独立执行，方法必须有调入者才能执行。<ul>
<li>类方法：也称静态方法，在方法前加static关键字，就代表这个方法属于这个类本身，不属于它的任何实例。换句话说，这个方法不通过实例进行调用，并且所有实例都共享这一个方法，对方法的调用各个实例相互可见。</li>
<li>实例方法：一个方法如果不加上static关键字，那么这个方法就是实例方法。意思是它属于类的某个实例，通过这个实例调用它，对类的其他实例不产生影响。</li>
<li>无论如何，方法都需要调用者，区别在于你在写的时候，要根据方法的类型，是类方法就用类名，是实例方法就用对象去调用它。有些情况下，</li>
<li>在同一个类里面的一个方法调用另一个方法，这个时候可以省略前面的调用者。省略也分两种情况，<ul>
<li>如果被调用的是实例方法，那么省略的就是；</li>
<li>如果被调用的是类方法，那么省略的就是类名（不是对象哦！）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>我再补充几句哈，免得有人看不懂，上面其实说得就是这么个意思，如果你用的是静态方法（前头加static的那个），那么这边建议你用类名调用，不建议了，强制比较好一点。然后呢，这边又提出了个省略型，静态方法的调用呢，我们甚至可以省略掉类名，直接上咱们的方法。</p>
<p>如果你使用的是非静态方法（不加static，亦或者叫做实例方法），那么你就必须得创建一个对象，然后用对象来调用方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fn1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fn2"</span>);</span><br><span class="line">        Test.fn1();<span class="comment">// 这边也可以直接省略掉Test.，比如说向下边这么写</span></span><br><span class="line">        <span class="comment">//fn1();  // 这就是上面说的，直接省略掉类名，上咱们的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">        t.fn2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>形参个数可变的方法</li>
<li>递归方法：</li>
<li>方法重载：2同1不同</li>
<li>方法的传参机制：值传递，传递的是参数的副本，并不是参数本身</li>
</ul>
<h2 id="变量的详解"><a href="#变量的详解" class="headerlink" title="变量的详解"></a>变量的详解</h2><p>成员变量（类里面定义）</p>
<ul>
<li>类变量。有static。静态变量</li>
<li>实例变量。无static。非静态变量</li>
</ul>
<p>成员变量，无需由程序员显式指定初始值，系统会为之分配默认初始值；</p>
<p>初始值规则：与数组元素的初始值规则完全相同</p>
<ul>
<li><p>类变量：是在第一次用该类的时候，系统会为该类变量分配空间，并初始化。</p>
<p>每个类的类变量都只有一个</p>
</li>
<li><p>实例变量：每次创建对象，系统都会为该对象的实例变量分配空间，并初始化。</p>
<pre><code>  程序中有几个对象，系统就会为这些对象的实例变量分配对应的空间。
</code></pre></li>
</ul>
<p>局部变量（方法里定义）</p>
<ul>
<li>形参</li>
<li>方法里局部变量</li>
<li>代码块的局部变量</li>
</ul>
<p>局部变量</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装、继承、多态——面向对象的3大特征。</p>
<p>封装包含了两方面的内容</p>
<ul>
<li>隐藏：隐藏的内部实现细节。</li>
<li>暴露：将一些操作界面暴露出来。<br>如果通过暴露的界面来操作对象，该对象的内部状态不会被破坏。</li>
</ul>
<p>简而言之：封装要求合理隐藏、合理暴露、</p>
<ul>
<li>通过访问控制器实现：</li>
</ul>
<p>private -&gt;         不写        -&gt;        protected        -&gt;        public</p>
<p>private（类访问权限）：该修饰符修饰的成员，只能在该类中被访问。</p>
<p>不写（包访问权限）：该修饰符修饰的成员，只能在该类及其该类所在包中被访问。</p>
<p>protected（子类访问权限）：该修饰符修饰的成员，只能在该类、及其该类所在包、该类的子类中被访问。</p>
<p>public（公共）：该修饰符修饰的成员可以在任意地方被访问。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>private</th>
<th>不写</th>
<th>protected</th>
<th>public</th>
</tr>
</thead>
<tbody>
<tr>
<td>当前类</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>同一个包</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>子类</td>
<td>×</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>任意</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td></td>
<td>彻底隐藏</td>
<td>部分隐藏</td>
<td>部分暴露</td>
<td>彻底暴露</td>
</tr>
</tbody>
</table>
</div>
<p>指导原则：</p>
<ol>
<li>成员变量（实例变量），通常用private修饰，为了隐藏实现细节</li>
<li>为每个成员变量提供getter、setter方法，用于控制该成员变量</li>
<li>需要暴露的方法，通常用public修饰</li>
<li>如果希望一个方法主要用于被子类重写，用protected修饰。</li>
</ol>
<ul>
<li><p>包<br>不同公司完全可以定义同名的类，为解决类名冲突的问题，不同公司不同项目的类名重复的问题。<br>Java就引入了“包”的机制。</p>
<p>举例理解：同一个班的两个同名的同学，为了区别他们，我们通常 会加一些修饰语，比如说“大江”“小江”<br>这边就是在类名前面添加一个前缀。<br>Java如何为类定义包？</p>
<ul>
<li>在源代码中用package包名；</li>
<li>将生成class文件要放在对应的文件结构下。</li>
</ul>
<p>包名的命名规范：语法要求，只要标识符即可</p>
<pre><code>          专业要求，推荐用公司域名倒写：比如org.fkjava.项目名;就挺好。
</code></pre><p>【备注】一旦你为类指定了包名之后，使用该类时应该用完整类名：包名+类名</p>
</li>
<li><p>导入包<br>impo的作用：为了省略写包名。</p>
<pre><code>                    如果不用import，每次用类时都需要使用包名+类名的形式。
</code></pre><ul>
<li>import 包名.类名；——每次导入一个类</li>
<li>import 包名.* ——导入指定的所有类</li>
<li>Java程序默认已导入java.lang包下所有包</li>
</ul>
</li>
<li>静态导入 import static<ul>
<li>import的作用：为了省略写包名。</li>
<li>import static的作用：可以省略写类名。<pre><code>                                  用于导入指定类的所有静态成员，导入之后，即可省略写类名。
</code></pre></li>
<li>import static 包名.类名.静态成员名; ——每次只导入一个静态成员。</li>
<li>import static 包名.类名.*;  ——导入指定类的所有静态成员。</li>
</ul>
</li>
<li>Java源程序的结构：<br>一条package语句<br>N条import语句<br>N个class定义</li>
</ul>
<h2 id="构造器详解"><a href="#构造器详解" class="headerlink" title="构造器详解"></a>构造器详解</h2><h3 id="构造器规则"><a href="#构造器规则" class="headerlink" title="构造器规则"></a>构造器规则</h3><ol>
<li>构造器用于初始化对象。</li>
<li>构造器如何调用？必须用new来调用啦。这样就可以返回一个初始化完成的对象。</li>
<li>如果你不为一个类提供构造器，那么系统会自动为该类提供一个无参数的构造器</li>
</ol>
<h2 id="构造器重载"><a href="#构造器重载" class="headerlink" title="构造器重载"></a>构造器重载</h2><p>一个类中可以定义多个构造器（因此构造器名必然相同），必须要求形参列表不同——这就是构造器的重载</p>
<p>this调用与this引用</p>
<p>this引用：this紧跟一个。<br>                    this.name;<br>                    this.walk();</p>
<p>this调用：this紧跟圆括号。<br>                 this（参数）<br>                    this调用代表调用同一个类中重载的构造器——this调用只能出现在【构造器】的【第一行】</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>封装、继承、多态——面向对象三大特征</p>
<h3 id="理解继承"><a href="#理解继承" class="headerlink" title="理解继承"></a>理解继承</h3><p>苹果类继承了水果类</p>
<p>老虎继承了动物类</p>
<p>东北虎继承了老虎类</p>
<p>Java的继承：是一种类与类之间关系<br>                        是一种由一般到特殊的关系，子类是一种特殊的父类<br>                        子类实例，完全可以当做父类实例来使用！</p>
<p>父类（超类、基类、大类，一些别称）；</p>
<p>子类（派生类、小类：一些别称）。</p>
<h3 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 类名 extends 父类</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​		</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明</p>
<ul>
<li>Java是单继承，只能有一个直接父类。</li>
<li>如果你不显式继承父类，Java默认是继承Object类（JDK系统提供的类）</li>
</ul>
<p>子类继承父类，可以得到父类的：</p>
<ul>
<li>成员变量</li>
<li>方法</li>
</ul>
<p>继承的好处：【代码复用】     </p>
<h2 id="方法重写（override）"><a href="#方法重写（override）" class="headerlink" title="方法重写（override）"></a>方法重写（override）</h2><p>当子类发现父类不适合自己时，就要重写父类的方法。</p>
<p>方法重写口诀</p>
<ol>
<li><p>方法名相同、形参列表相同。</p>
</li>
<li><p>返回值类型相同或更小， 声明跑出的异常相同或更小</p>
</li>
<li><p>访问权限相同或更大（如果父类访问权限是public的话，那么我们重写只能是public，因为public的权限是最大的了）</p>
<p>@Override：作用是报错。</p>
<pre><code>                    要求被修饰的方法必须重写父类方法，否则就报错。
                比如说如果我们重写的类名写错了，用这个方法可以帮我们发现这个错误，比如我们                    需要重写的类名是fly()，而我们写成了f1y()。
</code></pre></li>
</ol>
<p>Java找变量先就近，</p>
<h2 id="super限定"><a href="#super限定" class="headerlink" title="super限定"></a>super限定</h2><p>与前面this引用非常相似，super用于限定访问父类定义的实例变量或实例方法</p>
<p>super.父类定义的实例变量</p>
<p>super.父类定义的实例方法(参数)</p>
<h2 id="子类构造器调用父类的构造器"><a href="#子类构造器调用父类的构造器" class="headerlink" title="子类构造器调用父类的构造器"></a>子类构造器调用父类的构造器</h2><p><strong>子类构造器【一定调用】父类构造器【一次】——有且仅有一次。</strong></p>
<ol>
<li><p>如果子类构造器没有显式调用父类构造器，那么系统会自动在子类构造器的第一行先调用父类无参数的构造器</p>
</li>
<li><p>子类构造器的第一行显式使用super来调用父类构造器<br>super调用一定是调用的父类的构造器。只能出现在构造器的第一行。<br>this调用是调用当前类的构造器。只能出现在构造器的第一行<br>【很明显，super调用和this调用不可能同时出现。】</p>
<p>super限定：super紧跟一个   <strong>.</strong></p>
<pre><code>                  super.name;
                  super.walk();
</code></pre><p>super调用：super后边紧跟括号。</p>
<pre><code>                  super(参数);
</code></pre></li>
</ol>
<p>【备注】：如果父类没有无参数的构造器，子类的构造器必须显式调用父类指定的构造器。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>我再回顾一下345</p>
<p>3种类型：类、接口、枚举。<br>4个修饰符：private|protected|public、final、static、abstract<br>5大成员：成员变量、方法、构造器、初始化块、内部类</p>
<p>多态的意义：<br>我们先吹一吹<strong>变态</strong>的概念：from 百度百科</p>
<ul>
<li>心理、行为上异于常人而且呈现病态。</li>
<li>经常做出正常人无法理解事情或违背常理行为的人。</li>
<li>能做出令人厌恶、反常的举动。</li>
<li>精神病或者神经不正常。</li>
</ul>
<p>很明显，这个的意思是，在寻常的正常的一群人或者正常的成长路线中，个别人（对象）呈现出变异的行为特征——这个就是变态的定义</p>
<p>再说一说<strong>拟态</strong>：动物为了生存下来，变成令人害怕的样子，吓唬别人</p>
<p><strong>多态</strong>：同一个类型的多个实例、在执行同一个方法，呈现出多种的行为特征——这就叫做“多态”</p>
<p>举个栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 多态 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bird b1 = <span class="keyword">new</span> Sparrow();<span class="comment">// 这边需要注意的是，我的Sparrow类里边是没有fly方法的</span></span><br><span class="line"></span><br><span class="line">        Bird b2 = <span class="keyword">new</span> Ostrich();<span class="comment">// 这边需要注意的是，我的Ostrich类里边是有fly方法的</span></span><br><span class="line"></span><br><span class="line">        b1.fly();<span class="comment">// 当我的b1动态绑定类的fly方法的时候，发现我的Sparrow类里边没有fly方法，于是我的b1就开始寻找父类了，父类Bird里边果然有，所以我输出了“鸟在天上飞”</span></span><br><span class="line"></span><br><span class="line">        b2.fly();<span class="comment">// 当我的b2动态绑定类的fly方法的时候，发现我的Ostrich类里边是有fly方法的，于是我就输出了“鸵鸟当然只能跑啦！”这句话</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我相信上面的例子肯定能够助大家理解什么是多态</span></span><br><span class="line">        <span class="comment">// 相同类型的实例，在执行同一个方法的时候，呈现出多个行为特征。这就叫多态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Bird类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name = <span class="string">"鸟"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鸟在天上飞"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Sparrow类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ostrich类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ostrich</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鸵鸟当然只能跑啦！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="向上转型：子类对象可以直接赋值给父类变量。"><a href="#向上转型：子类对象可以直接赋值给父类变量。" class="headerlink" title="向上转型：子类对象可以直接赋值给父类变量。"></a>向上转型：子类对象可以直接赋值给父类变量。</h3><h3 id="向下转型：父类变量赋值给子类变量。"><a href="#向下转型：父类变量赋值给子类变量。" class="headerlink" title="向下转型：父类变量赋值给子类变量。"></a>向下转型：父类变量赋值给子类变量。</h3><p>强制转换。<br>（类型）变量名。</p>
<h3 id="为什么会有多态呢？"><a href="#为什么会有多态呢？" class="headerlink" title="为什么会有多态呢？"></a>为什么会有多态呢？</h3><p>当我们的Java执行方法时，方法的执行是 动态绑定的。方法总是执行该变量实际所指向对象的方法。</p>
<h3 id="变量的类型（这边再讲一个概念）"><a href="#变量的类型（这边再讲一个概念）" class="headerlink" title="变量的类型（这边再讲一个概念）"></a>变量的类型（这边再讲一个概念）</h3><p>编译时的类型：声明该变量时指定的类型。<br>                           在Java程序的编译阶段，Java编译器只认编译时的类型。</p>
<p>运行时的类型（实际类型）：该变量实际所引用的对象的类型。</p>
<h3 id="强制转换运算符的注意点："><a href="#强制转换运算符的注意点：" class="headerlink" title="强制转换运算符的注意点："></a>强制转换运算符的注意点：</h3><ol>
<li><p>强制转换运算符只能在具有编译类型具有父子关系的变量之间进行转换。否则编译错误</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"在平面上绘制图形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> <span class="keyword">extends</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是一个矩形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">round</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"绕着圆形走一圈"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 多态2 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// s1编译类型是Shape，实际类型是Rect</span></span><br><span class="line">        Shape s1 = <span class="keyword">new</span> Rect();</span><br><span class="line">        s1.draw();</span><br><span class="line"><span class="comment">//        s1.info();// 无法调用，找不到info方法，因为，Java在编译的时候，只认编译类型。对于Java编译器来说，s1是Shape类型</span></span><br><span class="line">        <span class="comment">// 实际上是可以允许的，s1是有这个方法的，是可以运行的，只是编译不能通过</span></span><br><span class="line">        Shape s2 = <span class="keyword">new</span> Circle();</span><br><span class="line">        <span class="comment">// 对于编译器而言，s2是Shape类型，Shape没有round方法</span></span><br><span class="line"><span class="comment">//        s2.round();// 无法运行，同上理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// s2编译类型是Shape，c要求是Circle，Shape无法转换为Circle。，这个时候要用强制转换</span></span><br><span class="line"><span class="comment">//        Circle c = s2;</span></span><br><span class="line">        <span class="comment">// 解决上面的方法是强制转换。</span></span><br><span class="line">        Circle c = (Circle)s2;</span><br><span class="line">        c.round();</span><br><span class="line"></span><br><span class="line">        Circle c2 = (Circle)s1;<span class="comment">// 类型转换异常，s1指向的是Rect，强制转换只能是本来指向要转换的类才能进行转换</span></span><br><span class="line">        <span class="comment">// 比如这边的s2本来就是指向Circle的，于是可以转换</span></span><br><span class="line">        <span class="comment">// 这边的s1本来是指向Rect，所以不能转换</span></span><br><span class="line">        c2.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个例子加以说明</p>
</li>
<li><p>如果在编译类型具有继承关系的变量之间转换，如果被转变量的实际类型，不是要转的目标类型，那么程序就会引发ClassCastException（类型转换异常）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 强转2 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object str1 = <span class="string">"Mr8god"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 强转</span></span><br><span class="line"></span><br><span class="line">        String str = <span class="string">"Mr8god"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Integer it = (Integer) str;// 会报不兼容的错误，因为String跟Integer没有继承关系，所以编译就会报错，报不兼容的类型</span></span><br><span class="line">        Integer it = (Integer) str1;<span class="comment">// 这边Object与Integer之间有继承关系，所以编译能通过，但是运行会出现异常。</span></span><br><span class="line">        <span class="comment">// 编译器要求：必须在编译类型具有继承关系才能强转</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上头还是我写的一个小栗子；</p>
</li>
</ol>
<h3 id="instanceof运算符（为了避免ClassCastException异常）："><a href="#instanceof运算符（为了避免ClassCastException异常）：" class="headerlink" title="instanceof运算符（为了避免ClassCastException异常）："></a>instanceof运算符（为了避免ClassCastException异常）：</h3><p>为了避免ClassCastException异常，Java就增加了这个运算符。</p>
<p>变量名 instanceof 类型 —— 当前面的变量所引用对象是后面类或者子类的实例时，该运算符返回true。</p>
<p>instanceof 只能在编译类型具有继承关系之间进行判断，否则编译报错：不兼容的类型。</p>
<p>所以我们以后在强制转换之前，都要做到先判断再转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 强转2 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object str1 = <span class="string">"Mr8god"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 强转</span></span><br><span class="line"></span><br><span class="line">        String str = <span class="string">"Mr8god"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Integer it = (Integer) str;// 会报不兼容的错误，因为String跟Integer没有继承关系，所以编译就会报错，报不兼容的类型</span></span><br><span class="line"><span class="comment">//        Integer it = (Integer) str1;// 这边Object与Integer之间有继承关系，所以编译能通过，但是运行会出现异常。</span></span><br><span class="line">        <span class="comment">// 编译器要求：必须在编译类型具有继承关系才能强转</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (str1 <span class="keyword">instanceof</span> Integer)</span><br><span class="line">        &#123;</span><br><span class="line">            Integer it = (Integer)str1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有在编译类型具有继承关系才能进行判断，否则编译报错，下面的例子又是一个不兼容的问题，String无法转换为Integer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 强转2 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String s = <span class="string">"Mr8god"</span>;</span><br><span class="line"><span class="comment">//        System.out.println(s instanceof Integer);//是不能运行的，因为String无法转换为Integer。。。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h2><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[修饰符]&#123;</span><br><span class="line"></span><br><span class="line">​			各种语句</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化块是没有名字的，<br>修饰符只能出现一个：static。</p>
<ul>
<li>有static的叫做类初始化块（静态初始化块）；</li>
<li>无static的叫做实例初始化块（非静态初始化块）；</li>
</ul>
<p>初始化块代码小栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">happy1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">2</span>;<span class="comment">// 成员变量-&gt; 实例变量</span></span><br><span class="line"><span class="comment">//    String name;</span></span><br><span class="line"><span class="comment">//    name = "Mr8god";</span></span><br><span class="line">    <span class="comment">//赋值语句不能放在类里边，赋值语句放在方法中</span></span><br><span class="line">    </span><br><span class="line">    String name ;</span><br><span class="line">    &#123;name = <span class="string">"Mr8god"</span>;&#125;<span class="comment">// 这样就变成初始化块了，就可以写了。这个东西叫做代码块中的初始化块（一种特例）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化块分成两种："><a href="#初始化块分成两种：" class="headerlink" title="初始化块分成两种："></a>初始化块分成两种：</h3><h4 id="实例初始化块（无static）"><a href="#实例初始化块（无static）" class="headerlink" title="实例初始化块（无static）"></a>实例初始化块（无static）</h4><p>实例初始化块其实是一种“假象”，一个类在编译之后，实例初始化块就会消失。</p>
<p>实力初始化块的所有代码会被还原到每个构造器的开始部分。<br>举个代码小栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitTest</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Mr8god"</span>);<span class="comment">// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面有两个构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InitTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一个无参构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InitTest</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"带String参数的构造器， 参数为："</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译之后，上面所以代码会变成下面的样子，下面的代码就是上面的本质。</span></span><br><span class="line"><span class="comment">//    public InitTest()</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("Mr8god");// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println("这是一个无参构造器");</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    public InitTest(String name)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("Mr8god");// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println("带String参数的构造器， 参数为：" + name);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边介绍一个命令javap -c 用于分析Java 的class文件<br><img src="https://i.loli.net/2020/04/07/mH9yhbtZ7dSeiwJ.jpg" alt="javap之后的真相.jpg"></p>
<p>经过反编译，得到具体代码运行过程后，我们发现事实确实是这样的哈。</p>
<p>这边再附上一个代码调用上面的类，以方便以后复现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Init in = <span class="keyword">new</span> Init();</span><br><span class="line"></span><br><span class="line">        Init in2 = <span class="keyword">new</span> Init(<span class="string">"江某人来了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="实例初始化块的作用："><a href="#实例初始化块的作用：" class="headerlink" title="实例初始化块的作用："></a>实例初始化块的作用：</h5><ol>
<li>类似于C++中的全局变量，只需要维护一个地方就够了，不需要到每个构造器里操作。</li>
<li>将多个构造器前面部分相同的代码可以提取到实例初始化块中！</li>
</ol>
<h5 id="实例初始化块何时执行呢？"><a href="#实例初始化块何时执行呢？" class="headerlink" title="实例初始化块何时执行呢？"></a>实例初始化块何时执行呢？</h5><p>只要程序调用构造器创建对象，程序总会先执行实例初始化块——因为实例初始化块被还原到每个构造器的所有代码之前。</p>
<h5 id="定义实例变量"><a href="#定义实例变量" class="headerlink" title="定义实例变量"></a>定义实例变量</h5><p>当我的init类是这个时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Init</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Mr8god"</span>);<span class="comment">// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 下面有两个构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一个无参构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Init</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"带String参数的构造器， 参数为："</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>initTest是这个时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Init in = <span class="keyword">new</span> Init();</span><br><span class="line"></span><br><span class="line">        Init in2 = <span class="keyword">new</span> Init(<span class="string">"江某人来了"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(in2.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果并不是如我刚开始想象的那样是20，因为我以为初始化的20 ，是分散到两个方法里去了，那么引用的话，应该是20呀。结果却是2。</p>
<p><strong>定义实例变量时指定的初始值，也是“假象” 。</strong></p>
<p><strong>——指定初始值，编译之后就变成构造器所有代码之前一条赋值语句！</strong></p>
<p>这里边的int age = 2，本质上是int age ;我们可以通过反编译工具看到</p>
<p><img src="https://i.loli.net/2020/04/07/5jsBlRHOqDAVC2Z.jpg" alt="age没有赋值.jpg"></p>
<p>所以我上面的Init类现在实际上已经变成了这个样子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Init</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 下面有两个构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mr8god"</span>);<span class="comment">// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">        age = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">"这是一个无参构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Init</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mr8god"</span>);<span class="comment">// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">        age = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">"带String参数的构造器， 参数为："</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么很明显，最近一次的赋值age是2。所以会出现问题，不是我想象中的20，也是理所应当了</p>
<p>这里边大费周章又是比较代码又是反编译的，其实主要是为了说明一点</p>
<p>即使我们的赋值语句不在代码块中，编译之后，也是会一起到构造语句中的。over</p>
<p>也就是说，如果我把int age = 2;放在类中的首行，也就是public Init()的上一行，我们得出的结果就会是20了，只是一个age赋值先后顺序的关系。</p>
<h5 id="总结总结总结"><a href="#总结总结总结" class="headerlink" title="总结总结总结"></a>总结总结总结</h5><p>实例初始化块的语句要还原到构造器的所有代码之前；定义变量指定的初始值，也要还原到构造器的所有代码之前；那么这两者的先后顺序呢？按照它们在源代码中的顺序。</p>
<h4 id="类初始化块（有static）"><a href="#类初始化块（有static）" class="headerlink" title="类初始化块（有static）"></a>类初始化块（有static）</h4><p>类初始化块——负责对类执行初始化。<br>                            当程序<strong>第一次主动</strong>使用该类时，系统会为该类分配内存空间、并执行初始化（调用类初始化块）</p>
<h5 id="对-第一次主动-概念做解释："><a href="#对-第一次主动-概念做解释：" class="headerlink" title="对 第一次主动 概念做解释："></a>对 <strong>第一次主动</strong> 概念做解释：</h5><p>除了用类去声明变量，其他只要你使用该类，都算是第一次主动使用该类。可以从Java编译器的角度去理解</p>
<h5 id="类初始化块何时执行"><a href="#类初始化块何时执行" class="headerlink" title="类初始化块何时执行"></a>类初始化块何时执行</h5><p>程序第一次【主动】使用该类时，会执行该类的类初始化块。<br>程序运行时，该类初始化块只会执行一次！</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>执行次数</th>
<th>执行先后</th>
<th>何时执行</th>
</tr>
</thead>
<tbody>
<tr>
<td>类初始化块</td>
<td>1次·</td>
<td>先</td>
<td>第一次主动用该类</td>
</tr>
<tr>
<td>实例初始化块</td>
<td>N次</td>
<td>后</td>
<td>每次调用构造器</td>
</tr>
</tbody>
</table>
</div>
<p><strong>定义实例变量时指定的初始值，也是“假象” 。</strong></p>
<p><strong>——指定初始值，编译之后就变成类初始化中的一条赋值语句！但到底是在类初始化块的代码之前，还是代码之后呢，取决于它在源代码中的顺序。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInit</span> </span>&#123;</span><br><span class="line"><span class="comment">//    static int age = 30;</span></span><br><span class="line"><span class="comment">//    // 类初始化块</span></span><br><span class="line"><span class="comment">//    static &#123;</span></span><br><span class="line"><span class="comment">//        age = 300;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上面代码的本质，如下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 类初始化块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        age = <span class="number">30</span>;</span><br><span class="line">        age = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="大一统"><a href="#大一统" class="headerlink" title="大一统"></a>大一统</h4><p>先上代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base11</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Base11 的类初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Base11 的实例始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base11</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Base11 无参数构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base11</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Base11 的（String）参数构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mid</span> <span class="keyword">extends</span> <span class="title">Base11</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Mid 的类初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Mid 的实例初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">(<span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        System.out.println(<span class="string">"Mid 的(int)构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"Mr8god"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Mid 的无参数构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub1</span> <span class="keyword">extends</span> <span class="title">Mid</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Sub 的类初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Sub 的实例初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sub1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sub 的无参数构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sub1</span><span class="params">(<span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        System.out.println(<span class="string">"Sub 的（double）构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Sub1(<span class="number">3.4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【结论】：初始化任何类之前，一定先从Object开始初始化，依次初始化它所有祖先类，最后才到它自己；创建任何对象的时候，一定是从Object构造器开始执行，执行它所有祖先类的构造器，最后才执行它自己的构造器！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mr8god.cn/2020/04/04/Java/Java%E6%B7%B1%E8%80%95/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B7%B1%E8%80%95%E2%80%94%E2%80%94%E5%86%85%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mr8god">
      <meta itemprop="description" content="Just learning！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr8god's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/04/Java/Java%E6%B7%B1%E8%80%95/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B7%B1%E8%80%95%E2%80%94%E2%80%94%E5%86%85%E5%AD%98/" class="post-title-link" itemprop="url">Java虚拟机深耕——内存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-04 15:49:15" itemprop="dateCreated datePublished" datetime="2020-04-04T15:49:15+08:00">2020-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 23:55:47" itemprop="dateModified" datetime="2020-04-14T23:55:47+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="浅谈Java内存"><a href="#浅谈Java内存" class="headerlink" title="浅谈Java内存"></a>浅谈Java内存</h1><h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><p><img src="https://i.loli.net/2020/04/04/RMaGdC8hxOqc9SY.jpg" alt="Java虚拟机运行时数据区.jpg"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a><strong>程序计数器</strong></h3><ol>
<li>作用：当前线程所执行的字节码的行号指示器。</li>
<li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li>
<li>存在的意义：Java虚拟机的多线程是通过线程轮流切换实现的，类似于操作系统的时间片算法来分配核心（处理器）的执行时间。所以，为了线程每一次切换后能够恢复到之前正确的执行位置，每个线程就需要各自独立的程序计数器。</li>
<li>如果线程此时正在执行的是一个Java方法，计数器记录的即是正在执行的虚拟机字节码指令的地址；如果正在执行的是Nativie方法，这个计数器即是空（Undefined）。</li>
</ol>
<h3 id="Java虚拟机栈（就是大家常说的栈内存）"><a href="#Java虚拟机栈（就是大家常说的栈内存）" class="headerlink" title="Java虚拟机栈（就是大家常说的栈内存）"></a><strong>Java虚拟机栈</strong>（就是大家常说的栈内存）</h3><p>虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个<strong>栈帧</strong>，用于存储局部变量表、操作栈、动态链接、方法出口等信息。</p>
<p>每一个方法被调用直至执行完成的过程，就对应着一个<strong>栈帧</strong>在虚拟机栈中从入栈到出栈的过程。</p>
<p>大部分程序员把Java的内存区域划分为堆内存（Heap）和栈内存（Stack），事实上Java内存区域的划分远比这复杂。其中所指的“堆”在后边会聊到，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变量表部分。</p>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>局部变量表存放了编译期可知的8种基本数据类型（int、char、byte、short、long、double、boolean、float）、对象引用和returnAddress类型</p>
<p>这边插一句关于对象引用类型的分析解释：字如其意，是一种引用，就是C中的指针嘛，我们来看一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>=左边的arr是变量部分，=右边的是一个对象。</p>
<p>右边只是一个指向对象起始地址的引用指针。</p>
<p>左边的arr是变量，所以被存放在栈内存中。右边的是对象， 所以被存放在堆内存中，两者靠指针来维系关系。上面这句话应该这么来理解。</p>
<p>continue！继续聊局部变量表，8种基本数据类型里64位长度的long和double类型的数据会占用2个局部变量空间，其余的数据类型只占用1个。</p>
<p>局部变量表所需的内存空间在编译期间就完成了分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是早就确定好的，而且我们在方法运行期间不会改变 局部变量表的大小。</p>
<p>continue！继续聊虚拟机栈，我们聊报错</p>
<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p>有两种：</p>
<ol>
<li>StackOverflowError异常：如果线程请求的栈深度大于虚拟机所允许的深度</li>
<li>OutOfMemoryError异常：当我们使用的虚拟机栈的内存不够时就会出现这个报错</li>
</ol>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>与虚拟机栈作用相似 ，区别在于虚拟机栈是为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用的Native方法服务。</p>
<p>甚至于有的虚拟机（比如Sun HotSpot虚拟机）直接将本地方法栈和虚拟机栈合二为一。</p>
<p>与虚拟机栈一样，本地方法栈区域也会抛出两种报错StackOverflowError和OutOfMemoryError。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>是Java虚拟机所管理的内存中最大的一块。在虚拟机启动时就被创建了。</p>
<p>唯一目的就是存放对象实例，只要我们new的对象实例都在这边分配了内存。</p>
<p>Java对可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。</p>
<p>当前主流的虚拟机都是按照可扩展来实现的（通过 -Xmx：最大多少内存空间，-Xms：最小多少内存空间   来控制）</p>
<p>如果堆中内存不够的话，将会抛出OutOfMemoryError异常，我称之为爆内存，并且在下面给出爆内存的具体例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 爆内存 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> it = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">long</span>[] arr = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">100</span>];</span><br><span class="line">        arr[<span class="number">99</span>] = <span class="number">33</span>;</span><br><span class="line">        System.out.println(arr[<span class="number">99</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//教你如何爆内存哈，在终端输入Java -Xmx256 爆内存</span></span><br></pre></td></tr></table></figure>
<p>当然爆内存知识OutOfMemoryError异常三种情况中的一种，之后我也会仔细围绕这个好好讲讲，<a href="https://blog.csdn.net/z453588/article/details/83743837，可以先看看这个博客解解馋" target="_blank" rel="noopener">https://blog.csdn.net/z453588/article/details/83743837，可以先看看这个博客解解馋</a></p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>与Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>可以和Java堆一样不需要连续的内存 和可以选择固定大小或者可扩展外</p>
<p>还可以选择不识闲垃圾回收。相对而言，垃圾收集行为在这个区域很少见。但是并非是说数据进入方法区就永久存在了。</p>
<p>这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>是方法区的一部分。</p>
<p>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征就是<strong>具备动态性</strong>。</p>
<p>动态性：Java语言并不要求常量一定只能在编译期产生，运行期间也可能将新的常量放入池中。这种特性被开发人员用的较多的就是String类的intern()方法。</p>
<p>既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当无法再申请到内存时会抛出OutOfMemoryError异常。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</p>
<p>JDK1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用来进行操作。这样在一些场景中能显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>
<p>既然是直接内存，那么这一部分内存是不会受到Java堆大小的限制的咯，</p>
<p>但是既然是内存，则肯定还是会受到本机总共内存的大小和处理器寻址空间的限制。</p>
<p>服务器管理员配置虚拟机参数时，一般会根据实际内存设置 -Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制（包括物理上的限制和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。</p>
<h3 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h3><p>上面都是从Java虚拟机的运行时数据区来讨论的，这边在讨论一个话题：对象访问是如何进行的呢？</p>
<p>对象访问是Java中的常客，即使是最简答的访问，也会涉及到Java栈、Java堆、方法区这三个最重要内存区域之间的关联关系。举个例子说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<p>等号左边的一部分会被保存在Java栈的本地变量表里，我之前也有所涉及，作为一个reference类型数据出现，一个引用类型嘛。</p>
<p>而右边的部分会被存储到Java堆中去。形成一块连在一起的结构化内存（类似于数组一样的结构）</p>
<p>另外在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。</p>
<h4 id="对象访问的两种方法：使用句柄和直接指针"><a href="#对象访问的两种方法：使用句柄和直接指针" class="headerlink" title="对象访问的两种方法：使用句柄和直接指针"></a>对象访问的两种方法：使用句柄和直接指针</h4><p>如果<strong>使用句柄访问方式</strong>，Java堆中将会划分出一块内存来作为句柄池，栈内存中存储的就是<strong>对象的句柄地址</strong>，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。</p>
<p><img src="https://i.loli.net/2020/04/04/a8p6zHbD1cl9NEF.jpg" alt="通过句柄访问对象.jpg"></p>
<p>如果使用<strong>直接指针访问方式</strong>，Java堆对象的布局就必须要考虑如何放置访问类型数据的相关信息，栈内存中直接存储的就是<strong>对象地址</strong></p>
<p><img src="https://i.loli.net/2020/04/04/9FjKNb6Xy3zU2tx.jpg" alt="通过直接指针访问对象.jpg"></p>
<p>各有优势：</p>
<p>使用句柄访问方式的最大好处就是堆内存中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针就行了。</p>
<p>使用直接指针访问方式的最大好处是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此此类开销积少成多后会非常可观。</p>
<h2 id="各种异常实战"><a href="#各种异常实战" class="headerlink" title="各种异常实战"></a>各种异常实战</h2><p>明儿个再补充</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mr8god.cn/2020/04/03/C++/%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%87%BD%E6%95%B0%E5%B0%8F%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mr8god">
      <meta itemprop="description" content="Just learning！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr8god's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/03/C++/%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%87%BD%E6%95%B0%E5%B0%8F%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">你所不知道的函数小知识——结构体与函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-03 15:49:15" itemprop="dateCreated datePublished" datetime="2020-04-03T15:49:15+08:00">2020-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 23:56:11" itemprop="dateModified" datetime="2020-04-14T23:56:11+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="结构体与函数之间的那点儿事"><a href="#结构体与函数之间的那点儿事" class="headerlink" title="结构体与函数之间的那点儿事"></a>结构体与函数之间的那点儿事</h1><p>正如标题哈，本篇博文讲的就是结构体和函数。不是新手向的教程哈，更多的这是一篇记录经验的文章。话不多说，开始咯！</p>
<p>我们将注意力从之前的数组转到结构上面。为结构写函数可比为数组写函数要简单得多了。虽然结构变量和数组一样，都可以存储多个数据项。但是在涉及到函数的时候，结构变量的行为更接近与基本的单值变量。这个名词可能太专业了哈。我做一下解释，还是拿数组来做比较，数组中都是一个元素为单位存储的，在结构中，相应的便是将数据组合成一个实体，实体就是数据，数据就是实体。<strong>实体（结构）==元素（数组）</strong>。</p>
<p>这边实现传值的思想主要是利用了<strong>一个结构可以赋给另外一个结构</strong>这样子的常识知识。就像普通变量一样。我需要额外补充的是，函数将使用原始结构的副本。</p>
<p>函数也可以返回结构 。这边与<strong>使用数组名就是代表了数组第一个元素的地址</strong>这样的观点不同的是，结构名只是结构的名称，<strong>要获得结构的地址，必须使用地址运算符&amp;</strong>。</p>
<p>咱们传递结构体的基本方法就是<strong>按值传递</strong>（圈起来，要考！）但是C++作为一门精细的语言，细节到每一个内存都要深挖，不能忍受这种方法的一个缺点：<strong>如果结构非常大的话，复制结构将增加内存要求，降低系统运行的速度。</strong>出于这种原因，我们更愿意的是采取<strong>按地址传递</strong>（没错，又是“该死”的指针，所以说C++指针一定要学好！）。然后使用指针来访问结构的内容。</p>
<h2 id="首先介绍“按值传递”"><a href="#首先介绍“按值传递”" class="headerlink" title="首先介绍“按值传递”"></a>首先介绍“按值传递”</h2><p>当结构比较小时，按值传递最舒服了用起来。接下来举的例子来源于《C++ Primer Plus（第六版）》</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从a到b城需要3小时50分钟，而从b到g城需要1小时25分钟，对于这种时间，可以使用结构来表示——一个成员表示小时值，另一个成员表示分钟值，将两个时间加起来需要一些技巧，因为可能需要将分钟值转换为小时。例如前面列出的两个时间的总和为4小时75分钟，应将它转化为5小时15分钟，下面开发用于表示时间值的结构，然后再开发一个函数，它接受两个这样的结构为参数并返回表示参数的和的结构。</span><br></pre></td></tr></table></figure>
<p>突出介绍一下结构函数的写法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">travel_time</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> hours;</span><br><span class="line">    <span class="keyword">int</span> mins;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在已经定义好时间的结构的前提下，开始声明结构函数</span></span><br><span class="line"></span><br><span class="line"><span class="function">travel_time <span class="title">sum</span><span class="params">(travel_time t1, travel_time t2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>完整代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">travel_time</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> hours;</span><br><span class="line">    <span class="keyword">int</span> mins;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mins_per_hr = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">travel_time <span class="title">sum</span><span class="params">(travel_time t1, travel_time t2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_time</span><span class="params">(travel_time t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    travel_time day1 = &#123;<span class="number">5</span>, <span class="number">45</span>&#125;;</span><br><span class="line">    travel_time day2 = &#123;<span class="number">4</span>, <span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line">    travel_time trip = sum(day1, day2);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Two-day total: "</span>;</span><br><span class="line">    show_time(trip);</span><br><span class="line"></span><br><span class="line">    travel_time day3 = &#123;<span class="number">4</span>, <span class="number">32</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Three-day total: "</span>;</span><br><span class="line">    show_time(sum(trip, day3));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">travel_time <span class="title">sum</span><span class="params">(travel_time t1, travel_time t2)</span></span>&#123;</span><br><span class="line">    travel_time total;</span><br><span class="line"></span><br><span class="line">    total.mins = (t1.mins + t2.mins) % Mins_per_hr;</span><br><span class="line">    total.hours = t1.hours + t2.hours + (t1.mins + t2.mins) / Mins_per_hr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_time</span><span class="params">(travel_time t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t.hours &lt;&lt; <span class="string">" hours, "</span> &lt;&lt; t.mins &lt;&lt; <span class="string">" minutes\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><p>travel_time 就像是一个标准的类型名，可以用来声明变量、函数的返回类型和函数的参数类型。</p>
<p>然后试travel_time结构的变量total 和t1，使用成员运算符进行数据的操作。代码很简单，可以看得懂。</p>
<h2 id="然后介绍“按地址传递”"><a href="#然后介绍“按地址传递”" class="headerlink" title="然后介绍“按地址传递”"></a>然后介绍“按地址传递”</h2><p>这一次我换了个题目，题目的内容我简要地说一下哈：通常我们表示一件物品的位置的时候，都是采取选择参照系利用直角坐标系或者极坐标系进行精确表示的，这边写了一个程序用于两种坐标系之间的转换。就是这样。</p>
<p>由于和上面的代码极其类似，所以我认为看看例子就能理解欧，就不做解析了。over</p>
<p>这个代码有一个小东西讲讲熬，就是while里边的cin&gt;&gt; 的用法，cin的特性是可以输入int整型数，但是一旦发现你输入的不是数字的时候，他就会不满足条件，变为0，然后while就会跳出循环，蛮好用的小技巧，推荐学习！</p>
<p>代码奉上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">polar</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> distance;</span><br><span class="line">    <span class="keyword">double</span> angle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rect</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rect_to_polar</span><span class="params">(<span class="keyword">const</span> <span class="built_in">rect</span> * pxy, polar * pda)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_polar</span><span class="params">(<span class="keyword">const</span> polar * pda)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">rect</span> rplace;</span><br><span class="line">    polar pplace;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter the x and y values: "</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; rplace.x &gt;&gt; rplace.y)&#123;</span><br><span class="line">        rect_to_polar(&amp;rplace, &amp;pplace);</span><br><span class="line">        show_polar(&amp;pplace);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Next two numbers (q to quit): "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Done.\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rect_to_polar</span><span class="params">(<span class="keyword">const</span> <span class="built_in">rect</span> * pxy, polar * pda)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    pda-&gt;distance = <span class="built_in">sqrt</span>(pxy-&gt;x * pxy-&gt;x + pxy-&gt;y * pxy-&gt;y);</span><br><span class="line">    pda-&gt;angle = <span class="built_in">atan2</span>(pxy-&gt;y, pxy-&gt;x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_polar</span><span class="params">(<span class="keyword">const</span> polar * pda)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> Rad_to_deg = <span class="number">57.29577951</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"distance = "</span> &lt;&lt; pda-&gt;distance;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">", angle = "</span> &lt;&lt; pda-&gt;angle * Rad_to_deg;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" degrees\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mr8god.cn/2020/04/02/C++/C++%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mr8god">
      <meta itemprop="description" content="Just learning！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr8god's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/02/C++/C++%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">C++函数中的指针应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-02 15:49:15" itemprop="dateCreated datePublished" datetime="2020-04-02T15:49:15+08:00">2020-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 23:56:28" itemprop="dateModified" datetime="2020-04-14T23:56:28+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="函数与数组"><a href="#函数与数组" class="headerlink" title="函数与数组"></a>函数与数组</h1><p>虽然我上面开了两篇博客准备一锅把函数端掉，但是当我想到数组哈，我觉得还是有必要对它好好搞一番。为什么呢？因为当我们在形参中放一个数组时，要开始注意了昂，这个数组是按照数组基本的操作传递值的，它是以指针的方式运转的！！！一提到指针哈，就得好好琢磨琢磨了，毕竟我江某人如今的观点是C++最重要的有两个：指针和STL库。</p>
<p>要我说，之前讲的两章，着实是对函数基础知识的总结。而我们日常使用中，是不会这么简单的。比如说我们企业中要计算某个项目中每个用户所购买的东西之和。我们很容易想到每个数组可以索引指向一个顾客，要计算总共有多少个东西被买掉了，我们可以使用循环来计算出总和。这不是不可以哈。但是呢，我们其实可以用一个函数来实现它。我们可以在声明函数时，放入一个数组形状的形参，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">( <span class="keyword">int</span> arr[], <span class="keyword">int</span> a)</span></span></span><br></pre></td></tr></table></figure>
<p>很明显，这里边arr就是咱们即将要传递的数组，[]里边是空的，说明我们待会要传递的数组的长度是需要额外设置的。但是我再强调一点哈，这个arr实际上并不是数组，而是一个指针！但是呢，我们在编写函数的时候，是可以将arr看做是数组的。</p>
<h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p>下面是我写的一个小example</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ArSize = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">int</span> counts[ArSize] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>,<span class="number">128</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = sums(counts, ArSize);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Total counts: "</span> &lt;&lt; sum &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        total = total + arr[i];</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我来详细讲一讲哈，其实我们当初在学习数组的时候就知道，数组名是可以当做指针来用的，数组名指向该数组的第一个元素的地址。但是呢，这边在函数中讨论数组和指针的话。我得把需要注意的几个点额外说一哈</p>
<ol>
<li>数组声明使用数组名来表示存储位置</li>
<li>对数组使用sizeof得到的是整个数组的长度，举个例子哈，int aaa[8]，int是4个字节，对这个数组使用sizeof的话，我们得到的长度为32位字节</li>
<li>如果我们使用取地址符&amp;的话，我们得到的也会是一个长度为32字节的内存块的地址。</li>
</ol>
<p>arr是咱们的数组名，根据C++规则，arr指代的是第一个元素的地址。 所以咱们的函数传递的也是地址哈。元素的类型是int，那么咱们的指针也应该是int类型的。因此，我们可以使用int *来表示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = sums(<span class="keyword">int</span> * arr, <span class="keyword">int</span> n)</span><br></pre></td></tr></table></figure>
<p>易知，int * arr 替换了int arr[]，这两个的含义是相同的。</p>
<p>但是呢，其实这两种表达方法也是有区别的，</p>
<p>数组表达式（int arr[])提醒咱们的程序员，arr不仅指向int，还指向了int数组的第一个int。当指针指向数组的第一个元素时，本书使用了数组表达法；</p>
<p>指针表达式可以用在当我们指针指向一个独立的值，而不是第一个值的时候。</p>
<p>！！！要记住只有在这边是可以的等价的，在其他地方都是不等价的哦。例如我们不能再函数体中将两者相替换。</p>
<p>经过我们的挖掘后，知道了arr数组名实际上是一个指针的事实后，我们也可以 用方括号数组表示法来访问数组元素。无论arr是指针还是数组名，表达式arr[3]都指的是数组的第4 个元素。</p>
<p>这边总结出两个式子，希望能记住：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr[i] == *(ar + i)</span><br><span class="line">&amp;arr[i] == ar + i</span><br></pre></td></tr></table></figure>
<p>在强调一点，指针加一的意义，指的是加上一个与指针指向的类型的长度。例如上文中的32字节内存块。对于遍历数组而言，使用指针加法和数组下标是等效的。</p>
<h2 id="数组作为参数有啥意义呢？"><a href="#数组作为参数有啥意义呢？" class="headerlink" title="数组作为参数有啥意义呢？"></a>数组作为参数有啥意义呢？</h2><p>讲得更加清楚一点，实际上数组内容并没有传递给函数，而是将数组的地址、包含的元素类型以及元素数目提交给了函数。有了这些信息后，函数便可以使用原来的数组。传递<strong>常规变量时</strong>，函数将<strong>使用该变量的拷贝</strong>；但传递<strong>数组</strong>时，函数将<strong>使用原来的数组</strong>。</p>
<p>一种是拷贝了原始数据，并进行操作，一种是使用指针，直接操作原始数据。都实现了函数的值传递。但是我想两种方法肯定是有利有弊的呀。继续往下分析。</p>
<h3 id="数组名与指针对应是否是好事呢？"><a href="#数组名与指针对应是否是好事呢？" class="headerlink" title="数组名与指针对应是否是好事呢？"></a>数组名与指针对应是否是好事呢？</h3><p>先说回答哈，确实是一件好事。将数组地址作为参数可以节省复制整个数组所需要的时间和内存。如果数组很大的话。则使用拷贝的系统开销将非常大；程序不仅需要更多的计算机内存，还需要花费时间来复制大块的数据。</p>
<p>但是呢，有利有弊哈，我们使用指针其本质上时使用了原始数据，增加了破坏数据的风险。不过不怕，C++可以解决它，ANSI C也可以解决它，那就是const限定符了。稍后我在写例子哈。</p>
<p>这边再写一个例子，用于演示咱们的指针是如何运转的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ArSize = <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> things[ArSize] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>,<span class="number">64</span>,<span class="number">128</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; things &lt;&lt; <span class="string">" = arr address, "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(things) &lt;&lt; <span class="string">" = sizeof things\n"</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = sums(things, ArSize);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Total things: "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    sum = sums(things, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"First tree people buy "</span> &lt;&lt; sum &lt;&lt; <span class="string">" things.\n"</span>;</span><br><span class="line">    sum = sums(things + <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Last four people buy "</span> &lt;&lt; sum &lt;&lt; <span class="string">" things.\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; arr &lt;&lt; <span class="string">" = arr, "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(* arr) &lt;&lt; <span class="string">" = sizeof  arr\n "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        total += arr[i];</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边的地址值和数组的长度会随着系统的变化而变化哈，如果你和你的小伙伴们运行出不一样的结果，不要诧异哦！此外，有些C++实现 的是以十进制而不是十六进制格式显示地址哈，所以不要太大惊小怪，显得见识浅薄了些。还有一些编译器以十六进制显示地址时，会加上前缀0x呢。</p>
<p><strong>代码说明：</strong></p>
<p>首先我这边things和arr指向了同一个地址。但是sizeof(things)的值为32，而sizeof(arr)为4（是我电脑上运行的结果哈）。这是由于sizeof(things)是整个数组的长度，而sizeof(arr)只是指针变量的长度。顺道加一个知识点，这也是必须显式传递数组长度，而不能在sums()中使用sizeof(arr)的原因；指针本身并没有之处数组的长度。</p>
<p>因为咱们的sums()只能通过第二个参数获知数组中的元素数量，我们可以对函数做修改。例如，程序第二次使用该函数时，这样调用它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = sums(things， <span class="number">3</span>)；</span><br></pre></td></tr></table></figure>
<p>通过告诉函数things有3个元素，可以让它计算前3个元素的总和。</p>
<p>也可以提供假的数组起始位置：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = sums(things + <span class="number">4</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>由于things是第一个元素的地址，因此things+4是第五个元素的地址。这条语句将计算数组第5、6、7、8个元素的总和。请注意输出中第三次函数调用选择将不同于前两个调用的地址赋给arr的。</p>
<p><strong>Attention！</strong></p>
<p>我们可以数组类型和元素数量告诉数组处理函数，通过两个不同的参数来传递他们：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> n)</span></span></span><br></pre></td></tr></table></figure>
<p>而不要试图使用方括号表示法来传递数组长度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">int</span> arr[<span class="built_in">size</span>])</span></span></span><br></pre></td></tr></table></figure>
<h2 id="各种例子，来更深入了解数组函数"><a href="#各种例子，来更深入了解数组函数" class="headerlink" title="各种例子，来更深入了解数组函数"></a>各种例子，来更深入了解数组函数</h2><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>假设要使用一个数组来记录房地产的价值。</p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>首先要明确使用哪种类型。当然double的取值范围比int和long大，并且提供了足够多的有效位数来精确地表示这些值。</p>
<p>接下来必须决定数组元素的数目。（这边不考虑动态数组）如果房地产数目不超过5个，则可以使用一个包含5个元素的double数组。</p>
<p>考虑操作：两个基本的操作，一、将值读入到数组中和显示数组内容。二、重新评估每种房地产的值。</p>
<p>简单起见，我们规定房地产以相同比率增加或者减少。</p>
<h3 id="1-填充数组"><a href="#1-填充数组" class="headerlink" title="1.填充数组"></a>1.填充数组</h3><p>顾客不止一个，所以我们可以做多个数组，房产得有上限，毕竟我这边不搞花里胡哨的动态数组。所以函数定义为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill_array</span><span class="params">(<span class="keyword">double</span> arr[], <span class="keyword">int</span> limit)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数接受两个参数，一个是数组名，另一个指定了要读取的最大元素数；该函数返回实际读取的元素数。例如，如果使用该函数处理一个包含了5个元素的数组，则将5作为第二个参数。如果只输入3个值，则该函数将返回3.</p>
<p>可有循环连续地将值读入到数组中，但是我们该如何提早结束循环呢？有两种思路，一、使用一个特殊值来指定输出结束。由于所有的属性不为负，我们可以使用负值来指出输入结束。二、该函数应对错误输入做出反应，如停止输入等。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill_array</span><span class="params">(<span class="keyword">double</span> arr[], <span class="keyword">int</span> limit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">double</span> temp;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter value # "</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">cin</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">cin</span>.<span class="built_in">get</span>() != <span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Bad input; input process terminated.\n"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        arr[i] = temp;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面函数可以判断输入是否出错，比如说负值啦等等。如果输入正确的话，则循环将会在读取最大数目的值后结束。循环完成的最后一项工作后，将i加1，因此循环结束后，i将比最后一个数组索引大1，即等于填充的元素数目。然后，函数返回这个值。</p>
<h3 id="2-显示数组及用const保护数组"><a href="#2-显示数组及用const保护数组" class="headerlink" title="2.显示数组及用const保护数组"></a>2.显示数组及用const保护数组</h3><p>不是啥高大的东西，就是显示元素的数组，但是最重要的东西应该是const保护数组。</p>
<p>当我们用数组名表示指针传递值时，会导致原始数据受到威胁。这个时候我呼应了上文中所要讲的方法const保护数组不被修改。</p>
<p>为了防止函数无意中修改数组的内容，我们可以在声明形参时使用关键字const：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> arr[], <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该声明表明，指针arr指向的是常量数据。这意味着不能使用arr修改该数据，也就是说，可以使用值，但是不会修改。咳咳，这并不是意味着原始数组必须是常量，而只是意味着不能在show_array()函数中使用arr来修改数据。因此该函数将数组视为只读数据。 如果你要在函数中给原数组赋值的话，是会报错的。</p>
<p>show_array函数代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Property #"</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">": $"</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-修改数组"><a href="#3-修改数组" class="headerlink" title="3.修改数组"></a>3.修改数组</h3><p>实现的功能是对数组中每个元素与同一个重新评估因子相乘。需要给函数传递3个参数：因子、数组和元素数目。该函数不需要返回值，因此代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Property #"</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">": $"</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就和上一个函数不一样了，这边是必须要修改值的，所以不能加const</p>
<h2 id="4-组合代码解出题目"><a href="#4-组合代码解出题目" class="headerlink" title="4.组合代码解出题目"></a>4.组合代码解出题目</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill_array</span><span class="params">(<span class="keyword">double</span> arr[], <span class="keyword">int</span> limit)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> arr[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">revalue</span><span class="params">(<span class="keyword">double</span> r, <span class="keyword">double</span> arr[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">double</span> properties[Max];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = fill_array(properties, Max);</span><br><span class="line">    show_array(properties, <span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter revaluation factor: "</span>;</span><br><span class="line">        <span class="keyword">double</span> factor;</span><br><span class="line">        <span class="keyword">while</span> (!(<span class="built_in">cin</span> &gt;&gt; factor))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">cin</span>.<span class="built_in">get</span>() != <span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Bad input; Please enter a number: "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        revalue(factor, properties, <span class="built_in">size</span>);</span><br><span class="line">        show_array(properties, <span class="built_in">size</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Done.\n"</span>;</span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">    <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill_array</span><span class="params">(<span class="keyword">double</span> arr[], <span class="keyword">int</span> limit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">double</span> temp;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter value #"</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">cin</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">cin</span>.<span class="built_in">get</span>() != <span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Bad input; input process terminated.\n"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Property #"</span> &lt;&lt; (i + <span class="number">1</span>) &lt;&lt; <span class="string">": $"</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">revalue</span><span class="params">(<span class="keyword">double</span> r, <span class="keyword">double</span> arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        arr[i] *= r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-程序说明"><a href="#5-程序说明" class="headerlink" title="5.程序说明"></a>5.程序说明</h3><p>回顾一下整个过程。我们首先考虑的是通过数据类型和设计适当的函数来处理数据，然后讲这些函数组合成一个程序。有时这个也称为自下而上的程序设计（bottom-up programming)，因为设计过程是从组建到整体进行。这种方法非常适合于OOP——它首先强调的是数据表示和操纵。</p>
<p>以前的过程性编程倾向于从上而下的程序设计，首先指定模块化设计方案，然后在研究细节，</p>
<p>最终产品都是模块化程序，也就是我们最后得到的东西都是模块化的东西，据我目前的经验来看，当代程序的思路都是模块化！</p>
<h3 id="6-数组处理函数的常用编写方式"><a href="#6-数组处理函数的常用编写方式" class="headerlink" title="6.数组处理函数的常用编写方式"></a>6.数组处理函数的常用编写方式</h3><p>总结一下数组处理函数无非就两种情况</p>
<p>情况一：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f_modify</span><span class="params">(<span class="keyword">double</span> ar[], <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<p>情况二：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _f_no_change(<span class="keyword">const</span> <span class="keyword">double</span> ar[], <span class="keyword">int</span> n);</span><br></pre></td></tr></table></figure>
<p>再扯几句哈，函数原型是可以省略变量名的，也可以将返回类型作指定，比如这边就指定了void。</p>
<h3 id="7-使用数组区间的函数"><a href="#7-使用数组区间的函数" class="headerlink" title="7.使用数组区间的函数"></a>7.使用数组区间的函数</h3><p>上面我们讲数组和函数的时候，用的是传统的C++方法，将指向数组起始处的指针作为一个参数，将数组长度作为第二个参数（指针指出数组的位置和数组类型），这样便给函数提供了找到所有数据所需要的信息。</p>
<p>我们处理数组的C++函数，必须将数组中的数据种类、数组的起始位置和数组中元素数量给函数。</p>
<p>还有一种给函数提供所需信息的方法是，即指定元素区间，这可以通过传递两个指针来完成：一个指针表示数组的开头，另一个指针标识数组的尾部。（C++标准模板库STL中将区间方法广义化了，STL方法使用“ 超尾”概念来指定区间，也就是说，对于数组而言，标识数组结尾的参数将是指向最后一个元素后面的指针。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> elboud[<span class="number">20</span>];</span><br></pre></td></tr></table></figure>
<p>指针elboud和elboud+20定义了区间。唉，其实就是数组名+多少个（数字）从而做出区间，写个小例子便于理解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ArSize = <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> * <span class="built_in">begin</span>, <span class="keyword">const</span> <span class="keyword">int</span> * <span class="built_in">end</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">int</span> things[ArSize] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = sums(things, things + ArSize);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Total things eaten: "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    sum = sums(things, things + <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"First three people buy "</span> &lt;&lt; sum &lt;&lt; <span class="string">" things.\n"</span>;</span><br><span class="line">    sum = sums(things + <span class="number">4</span>, things + <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Last four people buy "</span> &lt;&lt; sum &lt;&lt; <span class="string">" things.\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> * <span class="built_in">begin</span>, <span class="keyword">const</span> <span class="keyword">int</span> * <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> * pt;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(pt = <span class="built_in">begin</span>; pt != <span class="built_in">end</span>; pt++)</span><br><span class="line">        total += *pt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>太简单了，不解释了！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Mr8god</p>
  <div class="site-description" itemprop="description">Just learning！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">苏 ICP 备 20015778 号 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr8god</span>
</div>
  <!-- <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>
  -->

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共73.4k字</span>
</div>
        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




  















  

  

  

</body>
</html>
