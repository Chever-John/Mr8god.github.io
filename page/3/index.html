<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js ? id=UA-162074438-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-162074438-1');
</script>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mr8god.cn","root":"/","scheme":"Muse","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Just learning！">
<meta property="og:type" content="website">
<meta property="og:title" content="Mr8god&#39;s blog">
<meta property="og:url" content="https://mr8god.cn/page/3/index.html">
<meta property="og:site_name" content="Mr8god&#39;s blog">
<meta property="og:description" content="Just learning！">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Mr8god">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://mr8god.cn/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Mr8god's blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-162074438-1# <app_id>"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-162074438-1# <app_id>');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Mr8god's blog" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>
<a href="https://github.com/Mr8god/Mr8god.github.io" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mr8god's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">coding,coding,always coding!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mr8god.cn/2020/04/09/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E5%8F%98%E9%87%8F%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mr8god">
      <meta itemprop="description" content="Just learning！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr8god's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/09/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E5%8F%98%E9%87%8F%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Java速记——变量详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-09 15:49:15" itemprop="dateCreated datePublished" datetime="2020-04-09T15:49:15+08:00">2020-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 23:52:51" itemprop="dateModified" datetime="2020-04-14T23:52:51+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java速记——变量详解"><a href="#Java速记——变量详解" class="headerlink" title="Java速记——变量详解"></a>Java速记——变量详解</h1><p>Java没有全局变量的概念！！！</p>
<p>Java变量</p>
<ul>
<li>成员变量：<ul>
<li>位置：类中定义成员变量<ul>
<li>类变量 ： 有static</li>
<li>实例变量 ： 无static</li>
</ul>
</li>
</ul>
</li>
<li>局部变量<ul>
<li>位置：方法中定义局部变量<ul>
<li>形参</li>
<li>普通局部变量</li>
<li>代码块的局部变量</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>判断变量：</p>
<ol>
<li>首先看位置</li>
<li>然后看修饰符</li>
</ol>
<h2 id="成员变量："><a href="#成员变量：" class="headerlink" title="成员变量："></a>成员变量：</h2><p>可以不需要显式指定初始值，系统可以自动分配初始值；</p>
<p>初始值规则与数组元素的初始值规则完全能相同。</p>
<p><strong>观点</strong>：程序中，类本身只有一个；程序一定先有类，再有对象（实例）！！！</p>
<h3 id="类变量："><a href="#类变量：" class="headerlink" title="类变量："></a>类变量：</h3><p>类变量属于类本身，当系统初始化类时，就会为类分别分配空间，并执行初始化。</p>
<h3 id="实例变量："><a href="#实例变量：" class="headerlink" title="实例变量："></a>实例变量：</h3><p>类变量属于对象本身，系统每次创建对象时，都需要为该对象的实例变量分配空间，并执行初始化。</p>
<ul>
<li>严格来说：类变量，应该由类本身进行访问。<pre><code>                实例变量，应该由对象进行访问。
</code></pre>Java的一种不知道有啥用的语法（或许可以出题？）：允许通过对象类访问类变量</li>
</ul>
<p>比如说static int test这种设立类变量的方法，但是我们在实际访问的时候，举个情景例子哈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Computer c1 = <span class="keyword">new</span> Computer();</span><br><span class="line">        </span><br><span class="line">        Computer c2 = <span class="keyword">new</span> Computer();</span><br><span class="line">       </span><br><span class="line">        System.out.println(c1.test);</span><br><span class="line">        System.out.println(c2.test);<span class="comment">// Java允许通过对象类访问类变量</span></span><br><span class="line">        c2.test = <span class="number">20</span>;</span><br><span class="line">        System.out.println(c2.test);</span><br><span class="line">        System.out.println(c1.test);</span><br><span class="line"><span class="comment">//        System.out.println(test);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边看起来c1，c2看起来是很不错，引用的是咱们的test类变量，其实Java中根本就没有这个玩意儿。这玩意儿开辟出来就是在堆内存中占了个位置，然后谁用它，它就变成谁，说实话目前我还没有找到正确使用这个东西的姿势，over。这边看起来用的c1，c2，其实全是Computer类引用的，效果和下面的代码一样！！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Computer c1 = <span class="keyword">new</span> Computer();</span><br><span class="line"></span><br><span class="line">        Computer c2 = <span class="keyword">new</span> Computer();</span><br><span class="line"></span><br><span class="line">        System.out.println(Computer.test);</span><br><span class="line">        System.out.println(Computer.test);<span class="comment">// Java允许通过对象类访问类变量</span></span><br><span class="line">        c2.test = <span class="number">20</span>;</span><br><span class="line">        System.out.println(Computer.test);</span><br><span class="line">        System.out.println(Computer.test);</span><br><span class="line"><span class="comment">//        System.out.println(test);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>所以我建议</strong>：暂时我们就使用类调用类变量、类方法。</p>
<p>如果考试的时候，遇到用对象调用类变量、类方法的情况，第一步先把对象换成类。</p>
<h2 id="局部变量："><a href="#局部变量：" class="headerlink" title="局部变量："></a>局部变量：</h2><p>必须由程序员显式指定初始值，然后才能使用——否则编译报错；</p>
<p>局部变量的作用域很小，只在方法里有效；</p>
<p>离开了方法，局部变量就会失效</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mr8god.cn/2020/04/09/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mr8god">
      <meta itemprop="description" content="Just learning！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr8god's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/09/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">Java速记——数组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-09 15:49:15" itemprop="dateCreated datePublished" datetime="2020-04-09T15:49:15+08:00">2020-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-15 00:04:34" itemprop="dateModified" datetime="2020-04-15T00:04:34+08:00">2020-04-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java——数组"><a href="#Java——数组" class="headerlink" title="Java——数组"></a>Java——数组</h1><p>数组：可以一次定义，就可以得到多个类型相同、功能相似的变量，本质还是变量</p>
<h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>java类型可以分成基本类型、应用类型</p>
<ol>
<li>基本类型：8个<ol>
<li>引用类型：数组、类、接口、枚举</li>
</ol>
</li>
</ol>
<p><strong>数组其实就是一种引用类型。</strong></p>
<p>任何已有的类型，添加一组方括号就可以变成数组类型</p>
<p>int ：属于基本类型</p>
<p>int[]：属于引用类型</p>
<p>int[]（是一个整体，得连在一起写，一定要注意哈！）</p>
<p>long         -&gt; long[]</p>
<p>String       -&gt; String[]</p>
<p>double     -&gt; double[]</p>
<p>int []         -&gt; int $[][]$</p>
<p>数组元素的类型：是数组类型去掉一组方括号</p>
<p> 比如说int[]数组元素的类型，就是int</p>
<h3 id="创建数组对象（数组初始化）"><a href="#创建数组对象（数组初始化）" class="headerlink" title="创建数组对象（数组初始化）"></a>创建数组对象（数组初始化）</h3><ol>
<li><p>静态初始化</p>
<p>new 类型[] {元素1, 元素2,  ……}<br>不指定长度，只指定每个元素。<br><del>静态初始化的简化语法，省略掉in[]，但是这种方法只能在定义数组变量初始值的时候进行使用</del>，只能在定义数组变量，并赋初始值时使用。</p>
</li>
<li><p>动态初始化<br>new 类型[] {元素1, 元素2,  ……}<br>只指定长度，不指定每个元素。<br>系统会自动为每个元素分配初始值，其分配规则是：</p>
<ul>
<li>所有数组元素为数值类型时，数组元素的初始值为0；</li>
<li>所有数组元素为boolean类型时，数组元素的初始值为false</li>
<li>所有数组元素为引用类型时，数组元素的初始值为null</li>
</ul>
</li>
</ol>
<h3 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h3><ol>
<li><p>数组都有一个length属性，该属性返回数组的长度</p>
<p>数组一旦创建，其长度是固定的，他在内存中位置也是固定的。</p>
</li>
<li><p>每个数组元素，就相当于一个变量。数组元素的类型，就是数组类型去掉一组方括号<br>访问数组元素：<br>数组元素[索引] ——索引从0开始。最后一个元素的索引是length-1<br>使用的元素超出数组长度，就会导致ArrayIndexOutOfBoundsException: 4（数组索引越界异常）</p>
</li>
<li><p>遍历数组 - 依次使用每个元素</p>
</li>
<li><p>使用for each循环遍历数组<br>for(元素类型 变量名：数组名){</p>
<p>​        // 可通过变量名访问每个元素、</p>
<p>}<br>数组有几个元素，该循环就执行几次，变量会自动、依次等于每个元素。<br>foreach遍历只能访问数组元素的值，不能修改数组元素的值。<br><strong>建议</strong>：永远不要在foreach循环中修改计数器的值！</p>
</li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="深入理解数组"><a href="#深入理解数组" class="headerlink" title="深入理解数组"></a>深入理解数组</h3><p>数组是一种引用类型，<strong>引用类型和基本类型的区别在哪里？</strong></p>
<p>java程序的内存可以分成两种：</p>
<h4 id="堆-heap-内存："><a href="#堆-heap-内存：" class="headerlink" title="-堆(heap)内存："></a>-堆(heap)内存：</h4><p>java虚拟机启动时分配的一块永久的、很大的内存区。堆内存只有一块。</p>
<p><strong>java程序必须要使用虚拟机才能运行！</strong>。内存区我们是看不到的。java-Xms可以设置初始java堆大小。比如手 java -Xmx256 内存只有245兆。很容易就会爆内存。 </p>
<p>Error occurred during initialization of VM<br>Too small initial heap</p>
<p>上面两行就是爆内存的报错</p>
<h4 id="栈-stack-内存："><a href="#栈-stack-内存：" class="headerlink" title="-栈(stack)内存："></a>-栈(stack)内存：</h4><p>每次方法运行分配一块临时、很小的内存区。</p>
<p>每个方法都有自己相应的栈区，方法结束时，对应的栈区就会被回收。</p>
<p>几个方法就有几个栈区</p>
<h4 id="在方法中定义的、局部变量（不管是什么类型），都会放入相应的方法栈中去。"><a href="#在方法中定义的、局部变量（不管是什么类型），都会放入相应的方法栈中去。" class="headerlink" title="-在方法中定义的、局部变量（不管是什么类型），都会放入相应的方法栈中去。"></a>-在方法中定义的、局部变量（不管是什么类型），都会放入相应的方法栈中去。</h4><h4 id="new出来的东西，都在堆内存"><a href="#new出来的东西，都在堆内存" class="headerlink" title="-new出来的东西，都在堆内存"></a>-new出来的东西，都在堆内存</h4><p>堆内存中的对象，如果没有引用变量指向它，那它就变成了trash，等待vm的垃圾回收机制回收它。</p>
<p>计算机的每个内存单元（Byte、字节)在操作系统中都有一个编号，就像是一栋大楼的每个房间号</p>
<p>【变量赋值的区别：】</p>
<p>-基本类型的赋值：直接将该值存入变量所在内存</p>
<p>-引用类型的赋值：将该对象所在第一个内存单元的编号（内存地址）存入变量。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mr8god.cn/2020/04/09/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mr8god">
      <meta itemprop="description" content="Just learning！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr8god's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/09/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">Java速记——类与对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-09 15:49:15" itemprop="dateCreated datePublished" datetime="2020-04-09T15:49:15+08:00">2020-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 23:52:17" itemprop="dateModified" datetime="2020-04-14T23:52:17+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java速记——类与对象"><a href="#Java速记——类与对象" class="headerlink" title="Java速记——类与对象"></a>Java速记——类与对象</h1><p>面向对象：Java是一门面向对象的语言</p>
<p>类：某一类对象的统称。相当于是一个概念性的（不是具体存在的东西）</p>
<p>对象：现实中所能接触到的各种“东西”。</p>
<p>三句总决：定义类、创建对象、调用方法</p>
<h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>[修饰符] class 类名</p>
<p>{</p>
<p>​        // 成员变量</p>
<p>​        // 方法</p>
<p>​        // 构造器</p>
<p>​        // 内部类</p>
<p>​        // 初始化块</p>
<p>}————类体</p>
<p>类中的五大成员</p>
<ol>
<li>修饰符：public、final|abstract。其他的都不能出现，顺序是无所谓的，但是void返回类型一定要在修饰符后边</li>
<li>类名：语法要求——只要是标识符即可<br>从专业角度来看：多个单词连缀而成。</li>
</ol>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>[修饰符] 类型 变量名 [ = 初始值];</p>
<p>修饰符： private| protected|public、final|abstract、static、（transient：序列化相关）</p>
<p>类型：任意基本类型或引用类型</p>
<p>变量名：驼峰写法，首字母小写，后面每个单词首字母大写。。。 成员变量，用于描述该类或对象的状态，因此通常建议用名词。项目中，只定义项目感兴趣的状态</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>[修饰符] 返回值类型 方法名(形参列表)</p>
<p>{</p>
<p>​        // 代码，之前所有的东西，各种流程控制，定义变量（数组），都是在这个里边写的</p>
<p>如果声明了返回值类型，必须有return语句。</p>
<p>}————-方法体</p>
<ol>
<li><p>修饰符： private| protected|public、final|abstract、static</p>
</li>
<li><p>返回值类型：任意基本类型或引用类型，可使用void</p>
</li>
<li><p>方法名：</p>
<ol>
<li>语法要求：只要是标识符即可</li>
<li>专业角度：驼峰写法，首字母小写，后面每个单词首字母大写。。。 成员变量，</li>
<li>方法：用于描述该类或对象的状态，因此通常建议用<strong>动词</strong>。</li>
<li>项目中，只定义项目感兴趣的状态</li>
</ol>
</li>
<li><p>形参列表：形参类型1 形参名, 形参类型2 形参名2，……</p>
<p>每个形参都满足“形参类型 形参名”的格式；多个形参之间用逗号隔开。<br>代表调用方法时要传入的参数。</p>
</li>
</ol>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>作用：new调用构造器来创建对象</p>
<p>如果你没有为类写构造器，系统会默认为该类提供一个无参数的构造器！！！！只能隐藏构造器，但是每个类都会是有构造器的</p>
<p>[修饰符] 构造器名(形参列表)</p>
<p>{</p>
<p>​        // 代码：定义变量（包括数组）、变量赋值、流程控制、数据语</p>
<p>如果声明了返回值类型，必须有return语句。</p>
<p>}————-构造器体</p>
<ol>
<li>修饰符：private|protected|public</li>
<li>构造器名必须与类名相同</li>
</ol>
<p>判断一个类是不是构造器，要看两点：构造器名是否与类名相同、是否有返回值</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类可以用来干什么呢？</p>
<ol>
<li>定义变量<br>所有类，都是引用类型。所有类，都可用于声明变量</li>
<li>调用static修饰方法或static修饰的变量</li>
<li>创建对象</li>
<li>派生子类 </li>
</ol>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>对象可以用来做什么</p>
<ol>
<li>调用无static修饰的成员变量</li>
<li>调用无static修饰的方法</li>
</ol>
<h4 id="类是引用类型"><a href="#类是引用类型" class="headerlink" title="类是引用类型"></a>类是引用类型</h4><p>数组，也是引用类型</p>
<p>java中的引用类型有很多，只要你定义了一个类，就多了一个引用类型</p>
<p>引用类型变量的赋值，只是将对象的首地址存入变量中</p>
<h3 id="this引用："><a href="#this引用：" class="headerlink" title="this引用："></a>this引用：</h3><p>this可以出现非static的方法、构造器中。作用如下：</p>
<ol>
<li>出现非static方法中，this代表了该方法的调用者。<br>“谁调用该方法，this就代表谁”</li>
<li>出现在构造器中，this就代表该构造器正在初始化的对象。</li>
</ol>
<p>this.     的很重要作用就是：用于区分方法或构造器的局部变量。</p>
<p>尤其是与成员变量同名时——更需要使用this进行区分。</p>
<h2 id="方法详解："><a href="#方法详解：" class="headerlink" title="方法详解："></a>方法详解：</h2><h3 id="方法的所属性："><a href="#方法的所属性：" class="headerlink" title="方法的所属性："></a>方法的所属性：</h3><ol>
<li>方法类似于函数。但与函数不同的是，方法不能存在，方法必须定义在类里面。</li>
<li>定义在类中的方法。从逻辑上来看：<br>如果该方法有static修饰，该方法属于类本身，应该用类调用。<br>如果该方法无static修饰，该方法属于对象本身。</li>
<li>方法不能独立执行。<br>方法一定要有调用者<br>【规则】如果你调用同一个类中方法，可以省略调用者，此时系统会添加默认的调用者。<pre><code>           如果该方法是无static的方法，添加this作为默认的调用者。
</code></pre></li>
</ol>
<h3 id="形参个数可变的方法："><a href="#形参个数可变的方法：" class="headerlink" title="形参个数可变的方法："></a>形参个数可变的方法：</h3><p>类型… 形参名 ：这就是形参个数可变的方法</p>
<ul>
<li>本质就是数组。上面写法等同于：<br>类型[] 形参名</li>
<li>类型…<br>写法的好处是：调用方法时更加方便。即可直接传入多个元素，系统会自动将它们封装成数组。也可用数组。<br>写法的缺点是：类型…  这种写法只能作为形参列表的最后一个形参。<pre><code>                       【暗示】：一个方法最多只能有一个“个数可变”的形参
</code></pre></li>
</ul>
<h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><p>方法里调用本身——递归带来了隐式循环。</p>
<p>递归要避免无限递归。一定要在某些情况下，不再调用方法自身，</p>
<p>这个时候可能就要说了，这些循环用for之类的循环分支语句不都是可以实现的吗？</p>
<p>对对对，你说的都对，但是有一种情况只能用递归哦    </p>
<p>假如我们有：</p>
<p>f(1) = 2;</p>
<p>f(2) = 5;</p>
<p>…</p>
<p>f(n) = f(n+2) - 2 *  f(n+1)</p>
<p>要计算：f(10)是多少//代码在40/Recursive   </p>
<p>【难点】：    要保证递归一定能出现递归结束的条件。</p>
<h3 id="方法重载："><a href="#方法重载：" class="headerlink" title="方法重载："></a>方法重载：</h3><p>在同一个类中有多个同名的方法，但这多个方法的形参列表不同</p>
<p>口诀：两同一不同</p>
<ul>
<li>修饰符不同不算重载；返回值类型不同也不算重载</li>
<li>当你要确定一个方法的时候，仅有方法名是不够的的，必须还要结合参数才能确定。</li>
</ul>
<h3 id="方法的传参机制："><a href="#方法的传参机制：" class="headerlink" title="方法的传参机制："></a>方法的传参机制：</h3><p>如果定义方法时声明了形参，调用方法时必须传入对应的方法</p>
<p><strong>Java的参数传递机制：值传递 ，传入的只是参数的副本，并不是参数本身！！！</strong></p>
<ul>
<li>如果传递的参数是基本参数，方法中对参数所做的修改 ，完全不会影响参数本身！</li>
<li>如果传递的参数是引用类型，参数的副本与参数本身指向同一个对象。<br>因此方法通过参数副本修改对象时，会影响参数本身所指向的对象</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mr8god.cn/2020/04/09/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mr8god">
      <meta itemprop="description" content="Just learning！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr8god's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/09/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" class="post-title-link" itemprop="url">Java速记——类型转换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-09 15:49:15" itemprop="dateCreated datePublished" datetime="2020-04-09T15:49:15+08:00">2020-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-15 00:04:42" itemprop="dateModified" datetime="2020-04-15T00:04:42+08:00">2020-04-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java速记——类型转换"><a href="#Java速记——类型转换" class="headerlink" title="Java速记——类型转换"></a>Java速记——类型转换</h1><p>整形的注意点，</p>
<ol>
<li>直接给出一个整形整数值，该整数值默认为int型，但如果该整数位于byte、short的取值范围内，Java也可以直接把整数值当做byte、short处理，</li>
<li>如果你希望一个整数被当成long处理，必须在整数后添加L或者l。</li>
<li>整数有4种表达形式：<ol>
<li>十进制：常用。</li>
<li>八进制：以0开头，数值不超过7。</li>
<li>16进制：以0x或0X开头，数值不能超过F、a代表10、b代表11……f代表15。</li>
<li>二进制：以0b或0B开头，数值不能超过1。</li>
</ol>
</li>
</ol>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="自动转化：取值范围小的，自动转化为取值范围大的"><a href="#自动转化：取值范围小的，自动转化为取值范围大的" class="headerlink" title="自动转化：取值范围小的，自动转化为取值范围大的"></a>自动转化：取值范围小的，自动转化为取值范围大的</h3><p>byte&gt;short&gt;int &gt; long&gt; float&gt;double</p>
<p>​            char可以转化为int</p>
<p>每个字符都是有一个编号，计算机只存编号</p>
<p>short：-32768~+32768</p>
<p>char:0-65535</p>
<p>声明变量：</p>
<p>​            类型 变量[ = 初始值 ]；</p>
<p>类型 byte，</p>
<p>自动转化几条规则：</p>
<ol>
<li>所有整型都可以自动转成浮点型</li>
<li>所有整型都可以自动转化为long型</li>
<li>所有数值型，都可以自动转成double型</li>
</ol>
<p>记一下常识性的东西</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\r  <span class="number">13</span></span><br><span class="line"></span><br><span class="line">\n  <span class="number">10</span></span><br><span class="line"></span><br><span class="line">\t	<span class="number">9</span></span><br><span class="line"></span><br><span class="line">\<span class="string">'	39</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">\''</span>	<span class="number">34</span></span><br></pre></td></tr></table></figure>
<h3 id="强制转化："><a href="#强制转化：" class="headerlink" title="强制转化："></a>强制转化：</h3><p>上图上反过来转换，就需要强制转换</p>
<ol>
<li>浮点数转整数，砍掉小数部分</li>
<li>强制转换可能发生“溢出”</li>
</ol>
<h3 id="表达式类型的自动提升"><a href="#表达式类型的自动提升" class="headerlink" title="表达式类型的自动提升"></a>表达式类型的自动提升</h3><p>整个表达式的类型，与该表达式中最高等级的操作数的类型相同</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>算术运算符（7个）</p>
<p>+、-、*、/、%</p>
<p>++ ：将单个变量的值+1</p>
<p>​        放在变量之后，表示先用变量的值，再自加</p>
<p>​        放在变量之前，表示先自加，在用变量的值</p>
<p>—：将单个变量的值-1</p>
<p>​        放在变量之后</p>
<p>对于一些复杂运算需要使用math </p>
<h4 id="赋值运算符："><a href="#赋值运算符：" class="headerlink" title="赋值运算符：="></a>赋值运算符：=</h4><p>将=右边的值装入左边的容器（变量）</p>
<p>=左边只能是变量</p>
<p>=右边可以是任何复杂的表达式</p>
<p>大部分时候= 右边往往都是复杂的表达式</p>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>$&gt;$</p>
<p>$&gt;=$</p>
<p>$&lt;$</p>
<p>$&lt;=$</p>
<p>$==$</p>
<p>$~=$</p>
<p>比较运算符，用于比较两个变量或两个值，如果符合预期得到true，否则得到false</p>
<h4 id="逻辑运算符："><a href="#逻辑运算符：" class="headerlink" title="逻辑运算符："></a>逻辑运算符：</h4><p>只能对boolean值进行运算。</p>
<p>&amp;&amp;        与</p>
<p> &amp;</p>
<p>||        或</p>
<p>|</p>
<p>！        非</p>
<p>^            </p>
<p>两个条件相同则为false；不同则为true</p>
<p>富 美</p>
<p>既富，也美 - and</p>
<p>富或美  </p>
<p>短路与和与的区别：如果第一个操作数已经是false，&amp;&amp;运算符不会算第二个操作数，称之为短路。</p>
<p>​                                    如果第一个操作数已经是false，&amp;运算符依然会计算第二个操作数，称之为不短路</p>
<p>||和|的区别：同理如短路与！</p>
<p>一般来说，编程时都用短路与和短路或</p>
<h4 id="位运算符："><a href="#位运算符：" class="headerlink" title="位运算符："></a>位运算符：</h4><p>它只能对整型（byte、short、int、long、char（0~65535））运算</p>
<p>负数的进制码：保存的是它的补码</p>
<p>原码：数，直接算出来叫原码。最高位，又叫做符号位，0代表正数；1代表负数</p>
<p>反码：除符号位之外，其他位都按位取反</p>
<p>补码：反码+1。</p>
<ol>
<li><p>&amp;：按位与。上下两位都是1时，得到的结果才是1。</p>
</li>
<li><p>|：按位或。上下两位有一个1时，得到的结果就是1。</p>
<p>与位运算符相当常用，当表示状态时，会用特定的数代表开关。文本状态：粗体（1）、斜体（2）、下划线（4）、中划线（8）。就可以靠位与运算符进行控制。</p>
<p>所有涉及到开关的设计都会用到位于运算符</p>
</li>
<li><p>~：按位取反，正数变成负的（绝对值+1），负数变为正的（绝对值-1）。可以通过数学定理证明</p>
</li>
<li><p>^：按位异或。上下两位相同时，得到的结果是1.不同的时候，得到的结果为0.</p>
</li>
<li><p>&lt;&lt;：左移。左移N位相当于乘以2的N次方</p>
<p>2乘以8，最快的算法：2&lt;&lt;3</p>
</li>
<li><p>$&gt;&gt;$：右移N位，就是除以2的N次方，会砍掉小数，所以在除不尽的情况下，结果会比实际结果略小</p>
</li>
<li><p>$&gt;&gt;&gt;$：无符号右移。不太常用<br>如果被移的数是正数，那么该运算符与$&gt;&gt;$运算符效果一样<br>如果被移的数是负数，被空出来的数高位高位总是补0——这个数就会变成正数。</p>
</li>
</ol>
<h4 id="扩展的赋值运算符："><a href="#扩展的赋值运算符：" class="headerlink" title="扩展的赋值运算符："></a>扩展的赋值运算符：</h4><p>a  += b;        a = (类型)（a + b),这种更加好用，因为他可以自动强制转换为原先的类型。</p>
<p>所以推崇这种写法。</p>
<p>a -= b             a = (类型)（a - b)</p>
<p>……………………</p>
<p>基本上，前面介绍的所有双目运算符都可以和=结合，形成扩展的赋值运算符</p>
<h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><p>逻辑表达式？ 值1：值2</p>
<p><strong>常用的是三目运算符的嵌套</strong>！！！</p>
<p>嵌套后的三目运算符可能返回3个，甚至于更多值的其中之一</p>
<h4 id="运算符的结合性和优先级"><a href="#运算符的结合性和优先级" class="headerlink" title="运算符的结合性和优先级"></a>运算符的结合性和优先级</h4><p>结合性：控制运算符的运算方向：从左到右？还是从右到左？</p>
<p>大部分运算符都是从左到右。=运算符是从右到左的</p>
<p>推荐，记不清的时候，用括号来保证优先级</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol>
<li>变量定义、复制（简单值、表达式）</li>
<li>8个基本类型：byte、short、int、long、float、double、char、boolean</li>
</ol>
<p>运算符</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ol>
<li>顺序结构：从上到下、逐行执行</li>
<li>分支结构：根据具体情况，做出判断</li>
<li>循环结构：根据条件，让一个或多个步骤<strong>重复</strong>执行很多次</li>
</ol>
<p>目前可能存在的问题：</p>
<ol>
<li>语法掌握其实并不熟练</li>
<li>缺乏正确的程序员思维</li>
</ol>
<h3 id="顺序结构："><a href="#顺序结构：" class="headerlink" title="顺序结构："></a><strong>顺序结构</strong>：</h3><p>不加什么控制，程序代码都是从上到下，依次执行</p>
<h3 id="分支结构："><a href="#分支结构：" class="headerlink" title="分支结构："></a><strong>分支结构</strong>：</h3><p>不加什么控制，程序代码都是从上到下，依次执</p>
<h4 id="if分支："><a href="#if分支：" class="headerlink" title="if分支："></a>if分支：</h4><h5 id="两个注意点："><a href="#两个注意点：" class="headerlink" title="两个注意点："></a>两个注意点：</h5><ol>
<li>如果条件执行体只有一条语句，条件执行体的花括号可以省略。<br>如果省略了花括号，<strong>if条件只控制到紧跟if条件的第一个分号。</strong></li>
<li>else。否则，就是对前面条件取反<br>建议：如果if语句中有多个else if块，一定要先处理范围小的条件</li>
</ol>
<h4 id="switch分支："><a href="#switch分支：" class="headerlink" title="switch分支："></a>switch分支：</h4><p>switch(表达式){</p>
<p>​    case 值1：</p>
<p>​                    执行体</p>
<p>​                    break；</p>
<p>​    case 值2：</p>
<p>​                    执行体</p>
<p>​                    break;</p>
<p>…………………………</p>
<p>​    default:</p>
<p>​                    执行体</p>
<p>​                    brake;</p>
<p>}</p>
<p>程序会计算switch表达式的值，表达式的值等于哪个case块，就执行哪个case块。</p>
<p>如果都不等于，就执行default块</p>
<p>Java的switch不能处理范围！</p>
<h5 id="两个注意点：-1"><a href="#两个注意点：-1" class="headerlink" title="两个注意点："></a>两个注意点：</h5><ol>
<li>switch分支的表达式之鞥是byte、char、short、int、枚举、Strin（从java7开始才可以）这六个类型。</li>
<li>如果不写break，会发生贯穿，<br>贯穿：java会从第一个匹配的case块开始执行，在遇到break之前，直接忽略case值执行每个case块的代码</li>
</ol>
<h3 id="循环分支"><a href="#循环分支" class="headerlink" title="循环分支"></a>循环分支</h3><h4 id="while循环："><a href="#while循环：" class="headerlink" title="while循环："></a>while循环：</h4><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><p>while(条件){</p>
<p>​        // 循环体</p>
<p>}</p>
<p>程序首先判断循环条件，如果循环条件为true，执行循环体；</p>
<p>循环体执行完后，再次判断循环条件，如果循环条件Wietrue，执行循环体；</p>
<p>直到最后一次判断，循环条件为false，结束循环。</p>
<p>循环条件执行次数 == 循环体执行次数 + 1</p>
<p>死循环：无限循环，永远不会停止的循环。</p>
<h5 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h5><ol>
<li><p>如果循环体只有一条语句，那么循环体 的花括号可以省略</p>
<p>如果省略了花括号，while条件只控制到紧跟while条件的第一个分号。</p>
</li>
</ol>
<h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h4><h5 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h5><p>do{</p>
<p>​    // 循环体</p>
<p>}while (条件)</p>
<p>程序先执行一次循环体。</p>
<p>循环体执行完之后，再次判断循环条件，如果循环条件为true，执行循环体；</p>
<p>知道最后一次判断，循环条件为false，结束循环。</p>
<p>循环条件执行次数 == 循环体执行次数</p>
<h5 id="特征：即使循环条件开始就是false，循环体也会执行一次。"><a href="#特征：即使循环条件开始就是false，循环体也会执行一次。" class="headerlink" title="特征：即使循环条件开始就是false，循环体也会执行一次。"></a>特征：即使循环条件开始就是false，循环体也会执行一次。</h5><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><p>语法：</p>
<p>for([初始化语句]; [循环条件] ; [迭代语句]){</p>
<p>​        // 循环体</p>
<p>}</p>
<p>所有循环开始前，先执行初始化语句，只执行一次。</p>
<p>程序判断循环条件，如果循环条件为true，执行循环体；</p>
<p>循环体执行完后，执行迭代语句，然后再次判断循环条件 ，如果循环条件为true，执行循环体</p>
<h5 id="for循环的几个用法："><a href="#for循环的几个用法：" class="headerlink" title="for循环的几个用法："></a>for循环的几个用法：</h5><ol>
<li><p>for循环中，只有两个分号是必须的，其他都是可以省略的。</p>
<p>如果省略循环条件，循环条件永远都是true。</p>
<p>一定要写条件语句，不写的话就是死循环了。</p>
</li>
<li><p>尽量不要在循环体内改变循环计数器的值</p>
</li>
<li><p>初始化语句也可以初始化多个变量，只要它们的数据类型相同即可。<br>迭代语句也可以有多条，多条迭代语句之间用逗号隔开即可。</p>
</li>
</ol>
<h4 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h4><p>循环里再次放置循环，此时里层循环相当于外层循环的一条语句</p>
<h4 id="break终止结束"><a href="#break终止结束" class="headerlink" title="break终止结束"></a>break终止结束</h4><p>结束循环，跳出循环，break可以带标签，用于结束标签所代表的循环</p>
<h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p>忽略本次循环continue后面的语句，重新开始执行下一次循环</p>
<p>所以：不带标签的continue语句，如果是循环体的最后一行，那是没有任何意义的</p>
<p>continue可以带标签，用于忽略标签所代表的循环，重新开始下一次标签所代表的循环</p>
<h4 id="return"><a href="#return" class="headerlink" title="return"></a>return</h4><p>结束方法</p>
<p>循环总是位于方法中的，return既然可以结束方法，无论他在多深的循环里，他可以直接结束</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mr8god.cn/2020/04/09/Java/Java%E6%B7%B1%E8%80%95/Java%E6%B7%B1%E8%80%95%E2%80%94%E2%80%94%E5%88%9D%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mr8god">
      <meta itemprop="description" content="Just learning！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr8god's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/09/Java/Java%E6%B7%B1%E8%80%95/Java%E6%B7%B1%E8%80%95%E2%80%94%E2%80%94%E5%88%9D%E7%AB%A0/" class="post-title-link" itemprop="url">Java深耕——初章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-09 15:49:15" itemprop="dateCreated datePublished" datetime="2020-04-09T15:49:15+08:00">2020-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 23:51:25" itemprop="dateModified" datetime="2020-04-14T23:51:25+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java——初章"><a href="#Java——初章" class="headerlink" title="Java——初章"></a>Java——初章</h1><p>Java是一种面向对象编程(OOP)的语言。<br>掌握Java需要付出的代价就是，思考对象的时候，需要采用 形象思维（一种抽象思维），而不是程序化的思维。<br>特别是在尝试创建可重复使用（可再生） 的对象的时候，我们都会面临着一项痛苦的抉择。<br>事实上，正是由于这样的特性，很难有人能够设计出完美的东西，只有一些Java的编程专家才能编写出可以让大多数人使用的代码，而我江某人学习编程的目的就在于此，成为编程专家。</p>
<p>初章主要是描述了Java的多项设计思想，并从概念上解释面向对象的程序设计。</p>
<h2 id="抽象概念的由来"><a href="#抽象概念的由来" class="headerlink" title="抽象概念的由来"></a>抽象概念的由来</h2><h3 id="抽象方法是怎么出现的呢？"><a href="#抽象方法是怎么出现的呢？" class="headerlink" title="抽象方法是怎么出现的呢？"></a>抽象方法是怎么出现的呢？</h3><p>​        起因是我们在解决实际问题的时候发现每一类问题都有其自己的特征。而我们在C或一切其他语言中学到的都只是根据一类问题设计一套方法来解决它。以至于当超出这个问题的时候，方法就会显得特别笨拙。<br>​        面向对象的程序设计就是在以上基础跨出一大步。我们利用一些概念去描述表达实际问题中的元素。我们利用“<strong>对象</strong>”这个概念建立起实际问题和方法之间的联系。如果一些问题在后期出现了更多的问题，我们就可以相应的在代码中加入其它对象<br>通过添加新的对象类型，程序可以灵活的进行调整。与特定的问题打配合。从而达到解决问题的目的。<br>​        毫无疑问，<strong>面向对象程序设计语言</strong>是一门灵活、强大的语言抽象方法。它允许我们<strong>根据问题来描述问题，而不是单纯地根据方案。</strong></p>
<h4 id="OOP面向对象程序设计的特征"><a href="#OOP面向对象程序设计的特征" class="headerlink" title="OOP面向对象程序设计的特征"></a>OOP面向对象程序设计的特征</h4><p>通过上面讲述的这些特征，我们可以理解“纯粹”的面向对象程序设计方法是什么样子的：<br>(1)    所有东西都是对象。可以将对象想象成一种新型变量；它保存着数据，但可要求它对它自身进行一些操作，比如说增加点方法，增加点变量。理论上来讲，我们可以从问题中找出所有概念性的东西，然后在我们的程序中将其表达为一个对象。</p>
<p>(2)    程序将会是一大堆对象的组合；通过对象与对象之间的消息传递（传参），各个对象都知道自己该干什么，不该干什么。为了向另外一个对象发出请求，就需要向那个对象发送消息。<strong>具体来讲</strong>，我们可以将消息想象为一个调用请求，它调用的是从属于目标对象的一个子例程或函数。</p>
<p>(3)    每个对象都有自己的存储空间，可以容纳其他对象。或者是通过封装现有对象，进而制造出新的对象。所以尽管先前我们讲的对象看起来很简单，其实在每一个程序中，这些概念都能上升到一个任意高的复杂程度。</p>
<p>(4)    每个对象都有一种类型。根据Java的基本语法，每个对象都是某一个“类”的一个“实例”。而不同类与类之间的区别是什么呢？我抽象地讲，是“<strong>能将什么消息发给它？</strong>”</p>
<p>(5)    <strong>同一类的所有对象都能接收相同的消息。</strong>举例子举例子，这边有圆（Circle）、形状（Shape）两个类。由于圆其实也是形状嘛，我可以这样说，圆（Circle）的一个对象也属于类型为形状（Shape）的一个对象，所以一个圆能够完全接收来自形状（Shape）的任意消息。这就意味着我们可以让程序代码统一指挥形状（Shape），令其自动控制所有符合形状（Shape）描述的对象，其中自然包括圆（Circle）类的那个对象。这一特性叫做对象的”可替换性“，是OOP最重要的概念之一。</p>
<h2 id="对象的接口"><a href="#对象的接口" class="headerlink" title="对象的接口"></a>对象的接口</h2><p>上头我已经为大家引入了类与对象的概念，其实很好理解。类就相当于一样东西，比如说程序员就是一类。而对象呢，按照程序员类来说，这边的对象就是具体的一个程序员，比如说我江某人，就是一个程序员类的对象。</p>
<p>​        每一个对象都隶属于一个特定的“类”，那个类具有自己的通用特征与行为。</p>
<p>​        我们该如何让对象完成真正有用的工作呢？比如说让我江某人程序员对象完成一个C++的代码工作。我们可以在类中定义“<strong>接口</strong>”，对象的“类”就规定了它的接口形式。“类”和“接口”的等价或对应关系就是面向对象程序设计的基础。</p>
<p>​        下面来一个图解</p>
<p><img src="https://i.loli.net/2020/04/11/MvF6VlU21SKIfdh.jpg" alt="接口的讲解.jpg"></p>
<p>在上面这个图解中，，类的名字叫做Light，我们可以向Light对象发出的请求包括有打开（on）、关闭（off）、变得更明亮（brighten）、变得更黯淡（dim）。我们可以简单地声明一个名字（lt），我们为Light对象创建了一个“句柄”（就是名字，咱们对象的名字，在这边名字就叫做lt），这里边lt，也就是咱们的句柄，指向了刚刚新建的对象。然后我们用new关键字新建类型为Light的一个对象。再用等号将其赋值给句柄。</p>
<p>​        为了向对象发送一条消息，我们使用下面的格式来将句柄名、句点符号、和消息名称（on、off之类的）连接起来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lt.on();</span><br></pre></td></tr></table></figure>
<h2 id="实现方案的隐藏"><a href="#实现方案的隐藏" class="headerlink" title="实现方案的隐藏"></a>实现方案的隐藏</h2><p>这部分我将谈谈我们为什么要隐藏我们的类成员，类中的方法</p>
<p>​        首先我想就程序员的分类来讲，目前使用面向对象程序设计语言的程序员主要是分为两类的，一类是类的创建者，一类是类的使用者。前者制造出了包含各种使用的类包，后者会用前者的类包，解决各种问题。</p>
<p>​        这个时候，我们就需要考虑一个问题了，类创建者创建的类包里不能所有东西都能被使用者调用呀。如果任何人都能使用一个类的所有成员，那么使用者就可以对那个类做出任何事情。即使是一些不能够给使用者使用的类内包含的一些成员。如若不能进行控制的话，就没有办法组织这一情况的发生。</p>
<h3 id="为啥要控制类中成员的访问权限呢？"><a href="#为啥要控制类中成员的访问权限呢？" class="headerlink" title="为啥要控制类中成员的访问权限呢？"></a>为啥要控制类中成员的访问权限呢？</h3><p>综上，我们有两方面的原因促使我们需要对类中成员的访问权限进行控制。<br>原因一：防止使用者程序员接触他们不该接触的东西——通常是一些内部数据类型的设计思想。若只是为了使用类包解决问题，用户只需要操作接口就行了，不需要明白这些信息。我们向用户提供的实际是一种服务。<br>原因二：允许类包设计人员修改内部结构，不用担心它对使用者程序员造成影响。假如我们（类设计程序员）最开始写了一个简单的类包，以便简化开发。以后又决定进行改写，使其更快地运行。若接口与实现方法早已经隔离开了，并分别受到保护，就可以放心做到这一点。</p>
<h3 id="Java如何实现控制呢？"><a href="#Java如何实现控制呢？" class="headerlink" title="Java如何实现控制呢？"></a>Java如何实现控制呢？</h3><p>Java采用三个显式（明确）关键字以及一个隐式（暗示）关键字来设置类边界：public、private、protected 以及暗示性的friendly。若未明确指定其他关键字，则默认为后者。</p>
<p>解释这些关键字：</p>
<p>public（公共）：意味着后续的定义，任何人均可使用。<br>private（私有）：意味着除您自己、类型的创建者以及那个类型的内部函数成员之外，其他任何人都不能访问后续的定义信息。private在类创建者和类使用者之间竖起了一堵墙。若有人试图调用，便会在编译期报错。<br>friendly（友好的）涉及“包装”或“封装”（Package）的概念——即Java用来构建库的方法。若某样东西是“友好的”，意味着它只能在这个包装的范围内使用（所以这一访问级别有时也叫做“包装访问”）<br>protected（受保护的）：与“private”相似，只是一个继承的类就可以访问咱们的受保护成员，但是依旧不能访问私有成员。</p>
<h2 id="方案的重复使用"><a href="#方案的重复使用" class="headerlink" title="方案的重复使用"></a>方案的重复使用</h2><p>创建并测试好一个类后，这个好不容易创建好的类其实往往有很多缺点。只有较多经验以及洞察力的人才能 设计出一个好的方案。</p>
<p>​        为了重复使用一个类，最简单的方法就是仅直接使用那个类的对象。同时也将那个类的一个对象植入一个新类中。我们把这叫做“创建一个成员对象”。新类可以由任意数量和类型的其他对象构成。这个概念叫做“组织”——在现有类的基础上组织一个新类。有时组织也称为“包含”关系，比如“一辆车包含了一个变速箱”</p>
<p>​        对象的组织具有极大的灵活性。新类的“成员对象”通常设为“私有”，使用这个类的使用者程序员不能访问它们。</p>
<h2 id="继承：重新使用接口"><a href="#继承：重新使用接口" class="headerlink" title="继承：重新使用接口"></a>继承：重新使用接口</h2><p>当我们费尽心思做出一种数据类型之后，加入不得不又新建一种类型，令其实现大致相同的功能，那会是一件很麻烦的事情。但是若能利用已有的数据类型，对其进行“克隆模仿”，再根据实际情况进行添加或修改，那情况就会好多了。“继承”正是针对这个目标而设计的。但是继承并不完全等价于克隆。在继承的过程中，如果父类发生了变化，子类（继承后产生的新类）也会反映出这种变化。</p>
<p>在Java中继承是通过extends关键字实现的。使用继承时，相当于创建了一个新类。这个新类不仅包含了现有类型的所有成员（除了不能被访问的private成员）。其中最最重要的是它还复制了父类的接口。也就是说，能向父类发送的消息，亦可原样发给子类的对象。</p>
<p>由于父类和子类拥有相同的接口了，但是我们的子类不能一模一样呀，那样还跟父类有什么区别？为了做出区分，所以那个接口也必须进行特殊的设计。下面讲一下两种区分父类和子类的方法：</p>
<h3 id="区分父类子类的方法"><a href="#区分父类子类的方法" class="headerlink" title="区分父类子类的方法"></a>区分父类子类的方法</h3><p><strong>方法一</strong>：为子类添加新函数（功能）。这些新函数并非父类接口的一部分。为什么会有这种方法的出现呢？一般是因为我们发现父类原有的功能已经不能满足我们的需求了，于是我们就要添加更多的函数。这是一种最简单最基本的继承用法。</p>
<p><strong>方法二</strong>：近看extends关键字看上去是让我们要为接口“扩展”新功能，但实情并非肯定得照办。为了区分我们的新类，第二个办法就是改变父类，“改善”父类。</p>
<h3 id="改善父类"><a href="#改善父类" class="headerlink" title="改善父类"></a>改善父类</h3><p>为了改善一个父类，我们无非就是改善父类中的函数（或者叫方法），那么我们相应的只需要在子类中的函数中建立一个新的定义就可以了。我们的目标是：”尽管使用的函数接口未变，但他的新版本具有不同的表现“，但是万物没有这么绝对，我们还有另外情况，这边引用两个概念：<strong>等价关系</strong>和<strong>类似关系</strong></p>
<p>等价关系：子类完全照搬父类的所有的东西<br>类似关系：我们在子类中新加入了新的东西，那是原来父类中没有的东西。新的子类依旧拥有旧的父类的接口，但也包含了其他一些新的东西。所以就变成了不是上面所说的那种“等价关系”。</p>
<p>举一个例子：假定我有一个房间，房间连好了用于制冷的各种控制装置，用程序员思维来看，就是说我们已经拥有了必要的“接口”来控制制冷。现在假设我们的制冷机坏掉了，于是我将它换成了一台新型的冷、热两用空调，冬天制热、夏天制冷嘛。冷热空调“<strong>类似</strong>“制冷机，但是能做更多的事情。但是呢，由于我们的房间只安装了控制制冷的设备”<strong>接口</strong>“，所以”<strong>接口</strong>“们只能同新机器的制冷部分打交道。新机器的接口已得到扩展，但现有的系统并不知情，也不能够接触除了原始接口以外的任何东西。</p>
<p>当我们明确了等价和类似两种概念之后，以后在面对情况的时候就可以合理选择了。</p>
<h2 id="多形对象的互换使用"><a href="#多形对象的互换使用" class="headerlink" title="多形对象的互换使用"></a>多形对象的互换使用</h2><p>继承的结果往往会是创造了一系列的类，而这所有的类都是建立在统一的接口基础上的。如图</p>
<p><img src="https://i.loli.net/2020/04/11/DlvLfm5qPKnFzpX.jpg" alt="向上转型的形象描述.jpg"></p>
<p>这边要讲一个很重要的概念了哈，我们一定要把子类的对象当做父类的对象来对待。这一点是非常重要的。这就意味着我们只需编写代码就行了，不需要注意类的特定细节，只与父类打交道。</p>
<p>根据图例我们可以看到通过集成，这边有三个子类。那么我们为三个子类新编写的代码也会像在父类中那样良好工作。所以说程序具备了“扩展能力”，具有扩展性。</p>
<p>假设我们新加了一个函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doStuff</span><span class="params">(Shape s)</span>&#125;</span>&#123;</span><br><span class="line">	s.erase();</span><br><span class="line">	<span class="comment">// 等等等等等</span></span><br><span class="line">	s.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一个函数可以用途任何“几何形状”（Shape）通信，例如我这边又安排了一个代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Circle c = <span class="keyword">new</span> Circle();</span><br><span class="line">Triangle t = <span class="keyword">new</span> Triangle();</span><br><span class="line">Line l = <span class="keyword">new</span> Line();</span><br><span class="line">doStuff(c);</span><br><span class="line">doStuff(t);</span><br><span class="line">doStuff(l);</span><br></pre></td></tr></table></figure>
<p>这边我就分析一下doStuff(c)这串代码的意思（事实就是：我确实后边安排了这个代码）<br>此时，一个Circle句柄传递给了一个本来期待Shape句柄的函数。但是由于咱们的圆也是一种几何形状，所以doStuff()能够正确地进行处理。也就是说，凡是doStuff()能发给一个Shape的消息，Circle也能接收。所以这样子写是正确的，不会有报错。</p>
<p>我们把这种生成子类的方法叫做向上转型。向上是因为继承的方向是从“上面”来的——即父类位于顶部，子类在下方展开。</p>
<p>注意了哦，doStuff()里面的代码，它并非是这样表达的：”如果你是一个Circle，就这样作；如果你是一个Square，就按照那样做；等等诸如此类“。若那样子写代码的话，得累死你，就需要检查Shape所有可能的类型，如圆、矩形、四边形等等等等。这显然是非常麻烦的，而且每次添加了一种新的Shape类型后，都要相应地进行修改，在这里，我们只需要这样做：”你是一种几何形状，我知道你能将自己删掉（即代码里面的erase()），请自己放手去干吧，并且自己去控制所有的细节吧。“</p>
<p>这边我写了三个代码有助于我们理解：</p>
<p>代码一（Shape父类）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.shape;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/1120:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        out.println(<span class="string">"我是父类中的draw()方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        out.println(<span class="string">"我是父类中的erase()方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        out.println(<span class="string">"我是父类中的move()方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        out.println(<span class="string">"我是父类中的getColor()方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        out.println(<span class="string">"我是父类中的setColor()方法"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码二（Circle继承类）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.shape;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr8god</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/822:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doStuff</span><span class="params">(Shape s)</span></span>&#123;</span><br><span class="line">        s.erase();</span><br><span class="line">        out.println(<span class="string">"我是来自子类Circle里边的doStuff方法。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码三（ShapeTest类）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.mr8god.shape;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ Mr8god</span></span><br><span class="line"><span class="comment"> * @ 2020/4/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShapeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shape sh = <span class="keyword">new</span> Shape();</span><br><span class="line"></span><br><span class="line">        sh.draw();</span><br><span class="line">        sh.erase();</span><br><span class="line">        sh.move();</span><br><span class="line">        sh.getColor();</span><br><span class="line">        sh.setColor();</span><br><span class="line"></span><br><span class="line">        Circle ci = <span class="keyword">new</span> Circle();</span><br><span class="line">        ci.draw();</span><br><span class="line">        ci.erase();</span><br><span class="line">        ci.move();</span><br><span class="line">        ci.getColor();</span><br><span class="line">        ci.setColor();</span><br><span class="line">        ci.doStuff(ci);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自此输出：</p>
<p><img src="https://i.loli.net/2020/04/11/C8uPNOlLZbco4G7.jpg" alt="向上转型代码的输出.jpg"></p>
<h2 id="如何实现控制访问"><a href="#如何实现控制访问" class="headerlink" title="如何实现控制访问"></a>如何实现控制访问</h2><p>Java用三个关键字在类的内部设定边界：public、private、protected。这些访问指定词决定了紧跟其后被定义的东西可以被谁使用。</p>
<p>public：表示紧随其后的元素对任何人都是可用的</p>
<p>private：这个关键字表示除类型创建者和类型的内部方法之外的其他任何人都不能访问的元素。private就像你与使用类的程序员之间的一堵墙，如果有人试图访问private成员，就会在编译期间得到错误信息。</p>
<p>protected：这个关键字与private作用相当，差别仅在于继承的类可以访问protected成员，但是不能访问private成员。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mr8god.cn/2020/04/08/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94final%E5%8F%98%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mr8god">
      <meta itemprop="description" content="Just learning！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr8god's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/08/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94final%E5%8F%98%E9%87%8F/" class="post-title-link" itemprop="url">Java速记——final变量</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-08 15:49:15" itemprop="dateCreated datePublished" datetime="2020-04-08T15:49:15+08:00">2020-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 23:53:15" itemprop="dateModified" datetime="2020-04-14T23:53:15+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java速记——final变量"><a href="#Java速记——final变量" class="headerlink" title="Java速记——final变量"></a>Java速记——final变量</h1><p>可以修饰变量（各种变量）、方法、类。</p>
<p>final和abstract是互斥的：永远都不能够同时出现！</p>
<h2 id="final修饰变量"><a href="#final修饰变量" class="headerlink" title="final修饰变量"></a>final修饰变量</h2><p>作用：该变量被赋初始值之后，不能被重新赋值！<br>            final修饰的变量<strong>必须</strong>被赋值，且只能被赋值<strong>一次</strong></p>
<h2 id="final修饰成员变量"><a href="#final修饰成员变量" class="headerlink" title="final修饰成员变量"></a>final修饰成员变量</h2><p>普通成员变量（非final的成员变量），程序员可以不显式指定初始值，系统会为之分配默认初始值，初始值分配规则与数组元素的初始值分配规则完全相同！</p>
<p>final 成员变量，程序员必须显式指定初始值</p>
<ul>
<li><p>final实例变量，必须显式指定初始值，<strong>只能指定一次</strong>。<strong>只能在以下三个位置的其中之一指定：</strong></p>
<ul>
<li>定义时指定为初始值。</li>
<li>实例初始化块</li>
<li>每个构造器都需要显示指定一次初始值</li>
</ul>
<p>上面3个位置的本质其实只有一个，就是构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Final</span>实例变量 </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        age = 24;// 这边错误，被final修饰的成员变量不能被赋值两次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我们这样写就没有问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Final</span>实例变量 </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line">    &#123;</span><br><span class="line">        age = <span class="number">24</span>;<span class="comment">// 这边错误，被final修饰的成员变量不能被赋值两次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再一个正确示范</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Final</span>实例变量 </span>&#123;</span><br><span class="line">    <span class="comment">// final实例变量必须显式指定初始值，而且只能在3个位置中指定</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> lg;</span><br><span class="line">    <span class="keyword">public</span> Final实例变量()</span><br><span class="line">    &#123;</span><br><span class="line">        lg = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>final类变量，必须显示指定初始值。只能在以下2个位置的其中之一指定：</p>
<ul>
<li>定义时指定初始值</li>
<li></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mr8god.cn/2020/04/08/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mr8god">
      <meta itemprop="description" content="Just learning！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr8god's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/08/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/" class="post-title-link" itemprop="url">Java速记——抽象类和接口</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-08 15:49:15" itemprop="dateCreated datePublished" datetime="2020-04-08T15:49:15+08:00">2020-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 23:53:30" itemprop="dateModified" datetime="2020-04-14T23:53:30+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java速记——抽象类和接口"><a href="#Java速记——抽象类和接口" class="headerlink" title="Java速记——抽象类和接口"></a>Java速记——抽象类和接口</h1><ul>
<li>abstract关键字</li>
<li>抽象类</li>
<li>接口</li>
<li>JDK1.8/1.9接口的新特性</li>
<li>抽象类和接口的比较</li>
<li>面向对象的七个原则</li>
</ul>
<h2 id="abstract关键字"><a href="#abstract关键字" class="headerlink" title="abstract关键字"></a>abstract关键字</h2><p>主要修饰类和方法<br>一个方法没有方法体，就是抽象方法了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAbstract</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个类包含了抽象方法，那么这个类必须就是抽象类</p>
<p>务必要记得，有花括号就是方法体。是一个方法声明占位，具体实现留待子类覆盖/重写</p>
<p>如果类里边没有抽象方法，类也可以是抽象类——抽象类可以没有抽象方法</p>
<p>抽象类不能够使用new初始化对象；如果我不想让别人实例化我的类，就可以采用抽象类的方法。</p>
<p>举个例子：目前我们所学的Calendar类就是一个典型的抽象类，她只有一个静态方法——getInstance()——作用：根据当前的Date获得日历对象。</p>
<p>全局变量是强耦合为什么不好的一个典型的例子，比如你修改了全局变量的类型，则所有使用该变量的代码会受到影响，因此必须检查、修改和重新测试所有这些代码。不仅如此，所有使用该变量的方法都将通过该变量而彼此耦合</p>
<p>我们要<strong>适度耦合</strong></p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Java中，接口有两种意思：</p>
<ol>
<li>是指概念性的接口，即指系统对外提供的所有服务，类的所有能够被外部使用者访问的方法构成了类的接口</li>
<li>是指用interface关键字定义的实实在在的接口哦，也称为接口类型</li>
</ol>
<p>interface：不怎么提属性，操作，只提这个对象对外提供的功能<br>举例：电视机（按钮接口、红外接口：遥控器）、洗衣机（控制面板、洗衣）</p>
<p>对于接口来说，只有public、static、final常量，没有实例变量</p>
<p>JDK1.8之前，一定是抽象方法，不需要使用abstract关键字修饰，接口中的内容可见性默认是public，无论是否用public</p>
<p>类和接口之间要使用implements关键字（UML：实现realization），意味着类实现了某个接口，类就有这个接口的功能了</p>
<h3 id="接口的作用"><a href="#接口的作用" class="headerlink" title="接口的作用"></a>接口的作用</h3><ul>
<li>声明期望实现一个或更多的类的方法</li>
<li>确定对象的编程接口而无需显示类的实际主体</li>
<li>捕捉非相关类之间的相似性而无需强制类的关系</li>
<li>通过声明实现几个接口的类来模拟多重继承</li>
</ul>
<h2 id="JDK8的新特性"><a href="#JDK8的新特性" class="headerlink" title="JDK8的新特性"></a>JDK8的新特性</h2><p>增加了默认方法</p>
<p>如果我们要改接口的话，那么我们使用了接口的所有类都需要更改；</p>
<p>方法冲突<br>一个类可以实现多个接口，也就是说有可能会发生默认方法冲突</p>
<ul>
<li>类中的方法优先级最高</li>
<li>如果无法根据第一条进行判断，那么子接口的优先级更高；函数签名相同时，优先选择拥有最具体实现的默认方法的接口，即如果B继承了A，那么B就比A更加具体</li>
<li>最后如果还是无法判断，实现多个接口的类必须<ul>
<li>创建自己的默认方法，来覆盖重写接口的默认方法</li>
<li>使用super调用指定接口的默认方法</li>
</ul>
</li>
</ul>
<h2 id="JDK1-9的新特性"><a href="#JDK1-9的新特性" class="headerlink" title="JDK1.9的新特性"></a>JDK1.9的新特性</h2><p>Java9不仅像Java8一样支持接口默认方法，同时还支持私有方法。<br>在Java9中，一个接口中能定义如下集中变量/方法</p>
<ul>
<li>常量</li>
<li>抽象方法</li>
<li>默认方法</li>
<li>静态方法</li>
<li>私有方法：private</li>
<li>私有静态方法：private static</li>
</ul>
<h2 id="关于抽象类，我再补补课"><a href="#关于抽象类，我再补补课" class="headerlink" title="关于抽象类，我再补补课"></a>关于抽象类，我再补补课</h2><p>abstract（抽象），它只能修饰两个东西：</p>
<ul>
<li>方法（抽象方法）</li>
<li>类（抽象类）</li>
</ul>
<p>emmmmm，这边加一个<strong>惨痛经验</strong>，<strong>抽象类的抽象方法，务必不能有方法体</strong><br>这很好理解：我们的抽象类是要给别人去重写的，如果我们给了，那还让人家咋重写，emmmmm，我暂时就这么记了！</p>
<p>abstract与final是<strong>互斥</strong>的！</p>
<p> 抽象类的特征：有得有失。<br>抽象类与普通类的区别只有4个字：有得有失。</p>
<ul>
<li><p>有得：得到一个新功能：抽象类可以拥有这个抽象方法。</p>
</li>
<li><p>有失：抽象类失去了一个功能：创建对象</p>
</li>
</ul>
<h3 id="抽象类必须有构造器"><a href="#抽象类必须有构造器" class="headerlink" title="抽象类必须有构造器"></a>抽象类必须有构造器</h3><p>因为抽象类的主要功能是：派生子类；因为子类的构造器一定会调用父类的构造器一次，因此抽象类必须有构造器。<br>而咱们的final是不能有子类，这就是与abstract互斥的原因啦</p>
<h4 id="抽象类里边可以没有抽象方法吗？"><a href="#抽象类里边可以没有抽象方法吗？" class="headerlink" title="抽象类里边可以没有抽象方法吗？"></a>抽象类里边可以没有抽象方法吗？</h4><p>可以的！</p>
<h4 id="抽象类里边能不能没有构造器呀？"><a href="#抽象类里边能不能没有构造器呀？" class="headerlink" title="抽象类里边能不能没有构造器呀？"></a>抽象类里边能不能没有构造器呀？</h4><p>可以的！</p>
<h4 id="抽象类里边能不能没有初始化块呀？"><a href="#抽象类里边能不能没有初始化块呀？" class="headerlink" title="抽象类里边能不能没有初始化块呀？"></a>抽象类里边能不能没有初始化块呀？</h4><p>可以的！</p>
<h4 id="抽象类里边能不能有成员变量呀？"><a href="#抽象类里边能不能有成员变量呀？" class="headerlink" title="抽象类里边能不能有成员变量呀？"></a>抽象类里边能不能有成员变量呀？</h4><p>可以的！</p>
<h4 id="抽象类里边能不能有类变量呀？"><a href="#抽象类里边能不能有类变量呀？" class="headerlink" title="抽象类里边能不能有类变量呀？"></a>抽象类里边能不能有类变量呀？</h4><p>可以的！</p>
<h4 id="上面开个玩笑哈，只要记住普通类有的，抽象类全都有，只是不能创建对象而已"><a href="#上面开个玩笑哈，只要记住普通类有的，抽象类全都有，只是不能创建对象而已" class="headerlink" title="上面开个玩笑哈，只要记住普通类有的，抽象类全都有，只是不能创建对象而已"></a>上面开个玩笑哈，只要记住普通类有的，抽象类全都有，只是不能创建对象而已</h4><h3 id="抽象方法：只有方法签名，没有方法体的方法"><a href="#抽象方法：只有方法签名，没有方法体的方法" class="headerlink" title="抽象方法：只有方法签名，没有方法体的方法"></a>抽象方法：只有方法签名，没有方法体的方法</h3><p>只有抽象类才能拥有抽象方法，普通类不能有抽象方法</p>
<p>由于咱们的抽象方法没有方法体，那么很明显这就意味着，抽象方法一定要被子类去重写<br>与此相反的是咱们的final：final的意思是——你可不能重写我的方法哦！ </p>
<p>抽象方法，一定要交给子类去实现（比如说重写），否则不能调用！</p>
<h4 id="抽象类的作用"><a href="#抽象类的作用" class="headerlink" title="抽象类的作用"></a>抽象类的作用</h4><ol>
<li>定义变量。我们的抽象类不能创建实例对象，那么我们的抽象类定义之后要赋值的时候，只能用它的子类的实例。（用子类的实例对父类赋值，这叫做<strong>向上转型</strong>在多态时有学习到这个东西）</li>
<li>调用类方法和类变量</li>
<li>派生子类——主要目的</li>
</ol>
<h4 id="抽象类派生子类："><a href="#抽象类派生子类：" class="headerlink" title="抽象类派生子类："></a>抽象类派生子类：</h4><p>【得出推论规则】：子类要么重写父类中所有的抽象方法，要么子类也只能是抽象的。</p>
<h2 id="关于接口，我再补补课"><a href="#关于接口，我再补补课" class="headerlink" title="关于接口，我再补补课"></a>关于接口，我再补补课</h2><h3 id="关于接口的基本知识"><a href="#关于接口的基本知识" class="headerlink" title="关于接口的基本知识"></a>关于接口的基本知识</h3><p>接口相当于一种彻底抽象的类，（其实枚举也类似于一个类）<br>接口体现的是一种规范——要暴露出来供大家遵守的规范。<br>所以接口里的所有东西都用public修饰，不管你写还是不写，始终有public修饰。既然默认都有的话，我们其实可以不用写public修饰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] interface 接口名 extends 父接口1，父接口2，……</span><br><span class="line">&#123;</span><br><span class="line">		&#x2F;&#x2F; 没有成员变量，只有常量。默认总是会添加public、static、final修饰。		&#x2F;&#x2F; 既然默认都有，我们可以不写</span><br><span class="line">		&#x2F;&#x2F; 抽象方法。Java8之后，类方法、默认方法（抽象添加方法体）</span><br><span class="line">		&#x2F;&#x2F; 内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口是一种彻底抽象的类，抽象的类的话，那么抽象方法只能存在于抽象类。<br>接口里边只能有抽象方法，现在从Java8之后，接口开始有了类方法、方法体（可以说接口好像是被“污染了”，和以前的语法冲突了），但是呢，为了更大程度的和以前的方法体分开来，于是接口添加了<strong>默认方法</strong>这一概念。其实就是原来的<strong>抽象方法+方法体</strong></p>
<h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>默认方法就是实例方法，与原来抽象方法的规则完全一样，只不过抽象方法不能加方法体，于是默认方法加上default就可以加方法体了</p>
<p>接口里不能有初始化块，也不能有构造器</p>
<p>总结：接口里只有三大成员（常量、抽象方法、内部类）</p>
<p>接口的修饰符：public、<br>接口是彻底抽象，<strong>不能有final</strong>（final和抽象互斥）<br>抽象已经足够抽象了，因此不需要abstract更抽象了</p>
<p>【随处哔哔】private只能在类里边的类进行修饰，如果在外边那必是没有意义的呀</p>
<p>接口名：命名规范基本等同于类名。<br>                接口一般推荐使用形容词。<br>                （看看就好看看就好，我暂时还是看《阿里巴巴开发手册》）</p>
<h3 id="接口里的成员默认会添加public、static、final修饰"><a href="#接口里的成员默认会添加public、static、final修饰" class="headerlink" title="接口里的成员默认会添加public、static、final修饰"></a>接口里的成员默认会添加public、static、final修饰</h3><h4 id="final的变量初始化"><a href="#final的变量初始化" class="headerlink" title="final的变量初始化"></a>final的变量初始化</h4><p>final修饰的类变量必须在两个地方：定义的时候指定初始值、类初始化块指定初始值</p>
<p>但是接口里没有类初始化块，所以final修饰的变量（其实也是指定的啦，因为final默认在接口中的常量前面进行修饰的），那么很明显，我们默认用final修饰的变量一定且只能在指定初始值的时候进行指定（=）且进行赋初始值</p>
<h4 id="final的方法"><a href="#final的方法" class="headerlink" title="final的方法"></a>final的方法</h4><p>因为抽象类中的方法默认都是抽象方法，前头都戴着一定隐形的帽子（“abstract”），所以不用写abstract进行修饰</p>
<h3 id="接口的前世今生"><a href="#接口的前世今生" class="headerlink" title="接口的前世今生"></a>接口的前世今生</h3><h4 id="Java8以前的接口"><a href="#Java8以前的接口" class="headerlink" title="Java8以前的接口"></a>Java8以前的接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 所有成员变量前默认有public static final</span></span><br><span class="line">    <span class="keyword">int</span> MAX_PRESERVE = <span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 默认有public abstract ，也就是默认是public abstract void test();</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Java8之后的接口（有了main方法之后）"><a href="#Java8之后的接口（有了main方法之后）" class="headerlink" title="Java8之后的接口（有了main方法之后）"></a>Java8之后的接口（有了main方法之后）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前头默认public修饰</span></span><br><span class="line">    <span class="keyword">int</span> MAX_PRESERVE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认有public abstract</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Java8之后可以有static方法，所以就能定义main方法</span></span><br><span class="line">    <span class="comment">// 因此接口也可以直接运行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我再加点东西哈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前头默认public修饰</span></span><br><span class="line">    <span class="keyword">int</span> MAX_PRESERVE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面的public可以不写，但是static一定要写，因为不写就成了实例方法了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是类方法，因为我有static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【再随处哔哔】方法重载的规则是：两同一不同</p>
<ul>
<li>形参列表不同</li>
<li>方法名相同</li>
<li>修饰符不同</li>
</ul>
<h3 id="接口有什么用呢？"><a href="#接口有什么用呢？" class="headerlink" title="接口有什么用呢？"></a>接口有什么用呢？</h3><ul>
<li>定义变量，只能用实现类的实例来赋值（向上转型）</li>
<li>调用类方法或类变量</li>
<li>派生实现类</li>
</ul>
<h3 id="实现接口的语法是？"><a href="#实现接口的语法是？" class="headerlink" title="实现接口的语法是？"></a>实现接口的语法是？</h3><p>首先我们看一下完整的类的语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 父接口1，父接口2，………</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">		<span class="comment">// 五大成员		</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，上面的也是实现接口的语法了！嘿嘿嘿</p>
<p>重写接口中的方法只能用public修饰！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mr8god.cn/2020/04/07/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E5%8C%85%E8%A3%85%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mr8god">
      <meta itemprop="description" content="Just learning！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr8god's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/07/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E5%8C%85%E8%A3%85%E7%B1%BB/" class="post-title-link" itemprop="url">Java速记——包装类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-07 15:49:15" itemprop="dateCreated datePublished" datetime="2020-04-07T15:49:15+08:00">2020-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 23:54:26" itemprop="dateModified" datetime="2020-04-14T23:54:26+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java速记——包装类"><a href="#Java速记——包装类" class="headerlink" title="Java速记——包装类"></a>Java速记——包装类</h1><p>Java有8大基本类型：int、float、double、long、boolean、byte、char、short</p>
<p>这8个基本类型都不能当成对象使用，不是引用类型，而且也不能接受null值。null值只能赋值给引用类型。</p>
<p>为了解决上面的问题，Java为8个基本类型提供了对应的包装类——可将它们包装成对象。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>对应的包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>Int</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Char</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
</tbody>
</table>
</div>
<p><strong>自动装箱</strong>：基本类型的值可以自动当成包装类<br><strong>自动拆箱</strong>：包装类的实例可以自动当成基本类型的值使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关于自动装箱和自动拆箱的代码实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 包装类 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int i = null; // 基本类型不接受null值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2可以自动装箱成Integer</span></span><br><span class="line">        Integer in = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.3自动装箱Double，Double向上转型为</span></span><br><span class="line">        Object ob = <span class="number">2.3</span>;</span><br><span class="line"></span><br><span class="line">        Boolean b = <span class="keyword">true</span>;<span class="comment">// 自动装箱</span></span><br><span class="line"></span><br><span class="line">        Long lg = <span class="number">3L</span>;</span><br><span class="line"></span><br><span class="line">        Long result =  lg * in;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【建议】：做项目的时候，通常来说使用包装类来声明变量。<br>                    好处是：反正基本类型能做的，它都可以做；它还可以当成对象使用。还可以接受null</p>
<p>包装类的方法：<br>                方法可将字符串转成对应的基本类型值。</p>
<p>NumberFormatException：要转的字符串不符合数值格式，将会引发该异常。</p>
<p>当程序对Integer使用自动装箱时，它有一个缓存机制，它会缓存在-128 ~ 127之间的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">heiheihei</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i = <span class="number">20</span>; <span class="comment">// 在-128 ~ 127之间，缓存</span></span><br><span class="line">        Integer j = <span class="number">20</span>; <span class="comment">// 直接用缓存中对象。</span></span><br><span class="line">        System.out.println(i == j);</span><br><span class="line"></span><br><span class="line">        Integer c = <span class="number">204</span>; <span class="comment">// 不在-128 ~ 127之间，不缓存，因为这里边的204超过范围 了</span></span><br><span class="line">        Integer d = <span class="number">204</span>; <span class="comment">// 重新创建</span></span><br><span class="line">        System.out.println(c == d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<h2 id="两个要被重写的方法："><a href="#两个要被重写的方法：" class="headerlink" title="两个要被重写的方法："></a>两个要被重写的方法：</h2><h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>程序打印对象，或把对象自动转字符串的时候，实际上用的都是该对象的toString()方法的返回值。</p>
<p>【默认的toString】Object提供的toString返回的是类名@hashCode 方法返回值<br>重写toString：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// toString方法重写实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple123</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参数的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple123</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化全部成员变量的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple123</span><span class="params">(String color, <span class="keyword">double</span> weight)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.color;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">double</span> weight)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWeight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Apple[color="</span> + color</span><br><span class="line">                + <span class="string">", weight="</span> + weight</span><br><span class="line">                + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleTest1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple123 ap = <span class="keyword">new</span> Apple123(<span class="string">"红色"</span> , <span class="number">2.3</span>);</span><br><span class="line">        <span class="comment">// 程序打印对象，或把对象自动转字符串的时候，实际上用的都是该对象的toString()方法的返回值。</span></span><br><span class="line">        <span class="comment">// 下面两行代码是完全相同的</span></span><br><span class="line">        System.out.println(ap);</span><br><span class="line">        System.out.println(ap.toString());</span><br><span class="line"></span><br><span class="line">        Apple123 ap2 = <span class="keyword">new</span> Apple123(<span class="string">"蔡徐坤"</span> , <span class="number">188</span>);</span><br><span class="line">        System.out.println(ap2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任何对象 + ""，就会变成字符串</span></span><br><span class="line">        String str = ap2 + <span class="string">""</span>;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><p>== 如果判断两个引用变量，要求两个引用变量指向同一个对象时，才会返回true。</p>
<p>但是如果我们直接在main里用equals，还是false，原因是：<br>【默认的equals】Object提供的equals方法，判断两个对象相等的标准与 == 是完全一样的。<br>因此我们要重写equals：根据业务规则来提供两个对象相等的标准。<br>实际项目中，用来作为equals比较的关键成员变量，通常并不需要使用全部的成员变量<br>——只要用它们关键的成员变量即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equals方法重写实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参数的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化全部成员变量的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goat</span><span class="params">(String color, <span class="keyword">double</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// color的setter和getter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// weight</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// this和obj指向同一个对象</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要求obj不为null，且obj必须是Goat</span></span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp; obj.getClass() == Goat<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        </span>&#123;</span><br><span class="line">            Goat target = (Goat)obj;</span><br><span class="line">            <span class="comment">// 业务要求有几个关键属性，此处就比较几个关键属性，比如说这边只有一个color需要比较</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.color.equals(target.color)</span><br><span class="line">                    &amp;&amp; <span class="keyword">this</span>.weight == target.weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Goat goat1 = <span class="keyword">new</span> Goat(<span class="string">"黑色"</span> , <span class="number">78.2</span>);</span><br><span class="line">        Goat goat2 = <span class="keyword">new</span> Goat(<span class="string">"黑色"</span> , <span class="number">78.2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// goat1与goat2分别指向两个不同的对象，因此==判断返回false。</span></span><br><span class="line">        System.out.println(goat1 == goat2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写equals方法，根据业务规则来判断两个对象是否相等。</span></span><br><span class="line">        System.out.println(goat1.equals(goat2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h4 id="static并不是静态的意思。"><a href="#static并不是静态的意思。" class="headerlink" title="static并不是静态的意思。"></a>static并不是静态的意思。</h4><p>static是类的意思， 有static的成员属于类成员，没有static的成员属于势力成员</p>
<p>static是否可以修饰局部变量？——局部变量不属于成员，因此不能用static修饰。</p>
<p>static能否修饰外部类？ —— 外部类不属于成员，因此不能用static修饰。</p>
<h4 id="static修饰的成员：成员变量、方法、初始化块、内部类"><a href="#static修饰的成员：成员变量、方法、初始化块、内部类" class="headerlink" title="static修饰的成员：成员变量、方法、初始化块、内部类"></a>static修饰的成员：成员变量、方法、初始化块、内部类</h4><p>所有类成员，都只能用类名调用！</p>
<p>Java语法是不好，允许通过对象来调用类成员，是没有意义的 from 李刚老师</p>
<p>面试的笔试题中，如果遇到使用对象来调用类成员的情形，先把对象改成类——题目马上一目了然。</p>
<h4 id="static考点（笔试中非常常见）"><a href="#static考点（笔试中非常常见）" class="headerlink" title="static考点（笔试中非常常见）"></a>static考点（笔试中非常常见）</h4><p>static成员不能访问非static成员。<br>非static成员可以访问static成员！</p>
<p>static成员（4种）不能访问非static成员（5种：方法、变量、构造器、内部类、初始化块）；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 方法 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"info"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        info();//Error:(8, 9) java: 无法从静态上下文中引用非静态 方法 info()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 变量  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(age);//Error:(5, 28) java: 无法从静态上下文中引用非静态 变量 age</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 内部类 </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 静态访问，使用了非静态内部类</span></span><br><span class="line"><span class="comment">//        A a = new A();//Error:(9, 15) java: 无法从静态上下文中引用非静态 变量 this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 初始化块 </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;<span class="comment">// 静态成员</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        age = <span class="number">20</span>;<span class="comment">// 非静态成员</span></span><br><span class="line">        <span class="comment">//无法从静态上下文中引用非静态 变量 age</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 初始化块2 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"info 方法"</span>);<span class="comment">// 非静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        info();<span class="comment">// 静态成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 初始块3 </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>最早来自于建筑行业，早期优秀建筑设计师针对建筑给了很多优秀的建筑建议。比如房子有大窗户会更好一点，诸如此类的建筑建议</p>
<p>对于一批经常出现的设计场景，前人总结出来的比较成功的设计——这就是设计模式。<br>后面的人就应该学习、并模仿他们，从而提高我们的代码质量。</p>
<p>其中<strong>单例模式</strong>就是设计模式的一种：在某些场景下，某些类只需要（只能）创建一个实例。<br>比如系统的窗口管理器。只能有一个。<br>数据库引擎访问点，整个数据库，Java程序所在JRE环境……都只需要产生一个实例。<br>此时就应该采用单例模式</p>
<h3 id="如何设计单例模式？"><a href="#如何设计单例模式？" class="headerlink" title="如何设计单例模式？"></a>如何设计单例模式？</h3><ol>
<li>隐藏构造器——避免被创建实例</li>
<li>暴露一个static的方法，该方法用于创建实例<br>该方法还需要保证该类只会产生一个实例 </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line">    <span class="comment">// 构造器隐藏</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴露一个static方法，用于创建实例变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         Singleton s1 = Singleton.instance();</span><br><span class="line">         Singleton s2 = Singleton.instance();</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mr8god.cn/2020/04/07/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mr8god">
      <meta itemprop="description" content="Just learning！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr8god's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/07/Java/Java%E9%80%9F%E8%AE%B0%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE/" class="post-title-link" itemprop="url">Java速记——面向对象快速回顾</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-07 15:49:15" itemprop="dateCreated datePublished" datetime="2020-04-07T15:49:15+08:00">2020-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 23:54:59" itemprop="dateModified" datetime="2020-04-14T23:54:59+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="面向对象快速回顾"><a href="#面向对象快速回顾" class="headerlink" title="面向对象快速回顾"></a>面向对象快速回顾</h1><p>345</p>
<p>3种类型：类、接口、枚举</p>
<p>4个修饰符：private|protected|public、final、static、abstract</p>
<p>5个成员</p>
<h2 id="定义类的语法"><a href="#定义类的语法" class="headerlink" title="定义类的语法"></a>定义类的语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 类名 extends 父类</span><br><span class="line">&#123;</span><br><span class="line">		&#x2F;&#x2F; 5大成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义成员变量"><a href="#定义成员变量" class="headerlink" title="定义成员变量"></a>定义成员变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 类型 变量名[ &#x3D; 初始值];</span><br></pre></td></tr></table></figure>
<h2 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 返回值类型 方法名（形参列表）</span><br><span class="line">&#123;</span><br><span class="line">		语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义构造器"><a href="#定义构造器" class="headerlink" title="定义构造器"></a>定义构造器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 构造器名（形参列表）</span><br><span class="line">&#123;</span><br><span class="line">			语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义初始化块"><a href="#定义初始化块" class="headerlink" title="定义初始化块"></a>定义初始化块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[static] &#123;</span><br><span class="line">	语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类用于干甚？"><a href="#类用于干甚？" class="headerlink" title="类用于干甚？"></a>类用于干甚？</h2><ul>
<li>定义变量</li>
<li>创建对象</li>
<li>调用类、方法或者是访问类变量</li>
<li>派生子类</li>
</ul>
<h2 id="对象用于干甚？"><a href="#对象用于干甚？" class="headerlink" title="对象用于干甚？"></a>对象用于干甚？</h2><ul>
<li>调用实例方法或访问实例变量</li>
</ul>
<h2 id="方法（传参机制、递归方法、形参个数可变的方法、方法重载）"><a href="#方法（传参机制、递归方法、形参个数可变的方法、方法重载）" class="headerlink" title="方法（传参机制、递归方法、形参个数可变的方法、方法重载）"></a>方法（传参机制、递归方法、形参个数可变的方法、方法重载）</h2><h2 id="变量（判断变量：先看位置，再看static；成员变量和局部变量）"><a href="#变量（判断变量：先看位置，再看static；成员变量和局部变量）" class="headerlink" title="变量（判断变量：先看位置，再看static；成员变量和局部变量）"></a>变量（判断变量：先看位置，再看static；成员变量和局部变量）</h2><h2 id="构造器（构造器重载、this调用）"><a href="#构造器（构造器重载、this调用）" class="headerlink" title="构造器（构造器重载、this调用）"></a>构造器（构造器重载、this调用）</h2><p>this调用——出现在构造器的第一行，表明调用同一个类中重载的构造器</p>
<h2 id="初始化块（实例初始化块、类初始化块）"><a href="#初始化块（实例初始化块、类初始化块）" class="headerlink" title="初始化块（实例初始化块、类初始化块）"></a>初始化块（实例初始化块、类初始化块）</h2><p>实力初始化块：本质是构造器所有代码之前的代码；</p>
<p>类初始化块：本质是该类第一次被主动执行时，只运行一次。</p>
<h2 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h2><p>private —&gt; 不写 —&gt; protected —&gt; public</p>
<h2 id="继承、多态"><a href="#继承、多态" class="headerlink" title="继承、多态"></a>继承、多态</h2><p>Java是单继承的。</p>
<p>方法重写：两同两小一大。</p>
<p>子类构造器一定会调用父类构造器一次：创建任何对象，都是从Object的构造器开始执行的。</p>
<p>多态中：</p>
<p>​    方法执行：总是动态绑定实际类型的方法。<br>​                        强制转换、instanceof - 必须在有继承关系的两个类型之间进行处理，否则会编译报错。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mr8god.cn/2020/04/06/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mr8god">
      <meta itemprop="description" content="Just learning！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mr8god's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/06/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/" class="post-title-link" itemprop="url">Java速记——面向对象基础回顾</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-06 15:49:15" itemprop="dateCreated datePublished" datetime="2020-04-06T15:49:15+08:00">2020-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 23:55:32" itemprop="dateModified" datetime="2020-04-14T23:55:32+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java面向对象基础回顾"><a href="#Java面向对象基础回顾" class="headerlink" title="Java面向对象基础回顾"></a>Java面向对象基础回顾</h1><p>定义类、创建对象、调用方法</p>
<h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><pre><code>[修饰符] class 类名

{
    //成员变量

    //方法

    //构造器

    //初始化块

    //内部类
}
</code></pre><h2 id="定义成员变量"><a href="#定义成员变量" class="headerlink" title="定义成员变量"></a>定义成员变量</h2><p>[修饰符]    类型    变量名[ = 初始值]；</p>
<h2 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h2><pre><code>[修饰符]    返回值类型    方法名（形参列表）

{
    // 各种代码。定义变量、赋值语句、流程控制、输出语句
}
</code></pre><h2 id="定义构造器"><a href="#定义构造器" class="headerlink" title="定义构造器"></a>定义构造器</h2><pre><code>[修饰符]    构造器名（形参列表）

{
    // 各种代码。定义变量、赋值语句、流程控制、输出语句
}
</code></pre><p>构造器，很像一个特殊的方法</p>
<p>跟方法的两点区别：</p>
<ol>
<li>没有返回值类型声明，</li>
<li>构造器名必须类名相同。</li>
</ol>
<p>构造器作用：用于初始化对象——构造器永远属于实例。它不可能用static修饰。</p>
<h2 id="类可以用来干什么？"><a href="#类可以用来干什么？" class="headerlink" title="类可以用来干什么？"></a>类可以用来干什么？</h2><ol>
<li>定义变量。所有类都是引用类型。</li>
<li>调用类变量或类方法。</li>
<li>创建对象。</li>
<li>派生子类。</li>
</ol>
<h2 id="对象可以用来干什么？"><a href="#对象可以用来干什么？" class="headerlink" title="对象可以用来干什么？"></a>对象可以用来干什么？</h2><ol>
<li>调用实例变量</li>
<li>调用实例方法</li>
</ol>
<p>调用方法或变量：</p>
<pre><code>    调用者.方法([参数]);

    调用者.实例变量;
</code></pre><h2 id="方法详解"><a href="#方法详解" class="headerlink" title="方法详解"></a>方法详解</h2><ul>
<li>方法所属性。<ul>
<li>从定义的角度来看，方法不能独立定义，方法必须定义在类里面。</li>
<li>从调入的角度来看，方法不能独立执行，方法必须有调入者才能执行。<ul>
<li>类方法：也称静态方法，在方法前加static关键字，就代表这个方法属于这个类本身，不属于它的任何实例。换句话说，这个方法不通过实例进行调用，并且所有实例都共享这一个方法，对方法的调用各个实例相互可见。</li>
<li>实例方法：一个方法如果不加上static关键字，那么这个方法就是实例方法。意思是它属于类的某个实例，通过这个实例调用它，对类的其他实例不产生影响。</li>
<li>无论如何，方法都需要调用者，区别在于你在写的时候，要根据方法的类型，是类方法就用类名，是实例方法就用对象去调用它。有些情况下，</li>
<li>在同一个类里面的一个方法调用另一个方法，这个时候可以省略前面的调用者。省略也分两种情况，<ul>
<li>如果被调用的是实例方法，那么省略的就是；</li>
<li>如果被调用的是类方法，那么省略的就是类名（不是对象哦！）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>我再补充几句哈，免得有人看不懂，上面其实说得就是这么个意思，如果你用的是静态方法（前头加static的那个），那么这边建议你用类名调用，不建议了，强制比较好一点。然后呢，这边又提出了个省略型，静态方法的调用呢，我们甚至可以省略掉类名，直接上咱们的方法。</p>
<p>如果你使用的是非静态方法（不加static，亦或者叫做实例方法），那么你就必须得创建一个对象，然后用对象来调用方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fn1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fn1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fn2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fn2"</span>);</span><br><span class="line">        Test.fn1();<span class="comment">// 这边也可以直接省略掉Test.，比如说向下边这么写</span></span><br><span class="line">        <span class="comment">//fn1();  // 这就是上面说的，直接省略掉类名，上咱们的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">        t.fn2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>形参个数可变的方法</li>
<li>递归方法：</li>
<li>方法重载：2同1不同</li>
<li>方法的传参机制：值传递，传递的是参数的副本，并不是参数本身</li>
</ul>
<h2 id="变量的详解"><a href="#变量的详解" class="headerlink" title="变量的详解"></a>变量的详解</h2><p>成员变量（类里面定义）</p>
<ul>
<li>类变量。有static。静态变量</li>
<li>实例变量。无static。非静态变量</li>
</ul>
<p>成员变量，无需由程序员显式指定初始值，系统会为之分配默认初始值；</p>
<p>初始值规则：与数组元素的初始值规则完全相同</p>
<ul>
<li><p>类变量：是在第一次用该类的时候，系统会为该类变量分配空间，并初始化。</p>
<p>每个类的类变量都只有一个</p>
</li>
<li><p>实例变量：每次创建对象，系统都会为该对象的实例变量分配空间，并初始化。</p>
<pre><code>  程序中有几个对象，系统就会为这些对象的实例变量分配对应的空间。
</code></pre></li>
</ul>
<p>局部变量（方法里定义）</p>
<ul>
<li>形参</li>
<li>方法里局部变量</li>
<li>代码块的局部变量</li>
</ul>
<p>局部变量</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装、继承、多态——面向对象的3大特征。</p>
<p>封装包含了两方面的内容</p>
<ul>
<li>隐藏：隐藏的内部实现细节。</li>
<li>暴露：将一些操作界面暴露出来。<br>如果通过暴露的界面来操作对象，该对象的内部状态不会被破坏。</li>
</ul>
<p>简而言之：封装要求合理隐藏、合理暴露、</p>
<ul>
<li>通过访问控制器实现：</li>
</ul>
<p>private -&gt;         不写        -&gt;        protected        -&gt;        public</p>
<p>private（类访问权限）：该修饰符修饰的成员，只能在该类中被访问。</p>
<p>不写（包访问权限）：该修饰符修饰的成员，只能在该类及其该类所在包中被访问。</p>
<p>protected（子类访问权限）：该修饰符修饰的成员，只能在该类、及其该类所在包、该类的子类中被访问。</p>
<p>public（公共）：该修饰符修饰的成员可以在任意地方被访问。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>private</th>
<th>不写</th>
<th>protected</th>
<th>public</th>
</tr>
</thead>
<tbody>
<tr>
<td>当前类</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>同一个包</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>子类</td>
<td>×</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>任意</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td></td>
<td>彻底隐藏</td>
<td>部分隐藏</td>
<td>部分暴露</td>
<td>彻底暴露</td>
</tr>
</tbody>
</table>
</div>
<p>指导原则：</p>
<ol>
<li>成员变量（实例变量），通常用private修饰，为了隐藏实现细节</li>
<li>为每个成员变量提供getter、setter方法，用于控制该成员变量</li>
<li>需要暴露的方法，通常用public修饰</li>
<li>如果希望一个方法主要用于被子类重写，用protected修饰。</li>
</ol>
<ul>
<li><p>包<br>不同公司完全可以定义同名的类，为解决类名冲突的问题，不同公司不同项目的类名重复的问题。<br>Java就引入了“包”的机制。</p>
<p>举例理解：同一个班的两个同名的同学，为了区别他们，我们通常 会加一些修饰语，比如说“大江”“小江”<br>这边就是在类名前面添加一个前缀。<br>Java如何为类定义包？</p>
<ul>
<li>在源代码中用package包名；</li>
<li>将生成class文件要放在对应的文件结构下。</li>
</ul>
<p>包名的命名规范：语法要求，只要标识符即可</p>
<pre><code>          专业要求，推荐用公司域名倒写：比如org.fkjava.项目名;就挺好。
</code></pre><p>【备注】一旦你为类指定了包名之后，使用该类时应该用完整类名：包名+类名</p>
</li>
<li><p>导入包<br>impo的作用：为了省略写包名。</p>
<pre><code>                    如果不用import，每次用类时都需要使用包名+类名的形式。
</code></pre><ul>
<li>import 包名.类名；——每次导入一个类</li>
<li>import 包名.* ——导入指定的所有类</li>
<li>Java程序默认已导入java.lang包下所有包</li>
</ul>
</li>
<li>静态导入 import static<ul>
<li>import的作用：为了省略写包名。</li>
<li>import static的作用：可以省略写类名。<pre><code>                                  用于导入指定类的所有静态成员，导入之后，即可省略写类名。
</code></pre></li>
<li>import static 包名.类名.静态成员名; ——每次只导入一个静态成员。</li>
<li>import static 包名.类名.*;  ——导入指定类的所有静态成员。</li>
</ul>
</li>
<li>Java源程序的结构：<br>一条package语句<br>N条import语句<br>N个class定义</li>
</ul>
<h2 id="构造器详解"><a href="#构造器详解" class="headerlink" title="构造器详解"></a>构造器详解</h2><h3 id="构造器规则"><a href="#构造器规则" class="headerlink" title="构造器规则"></a>构造器规则</h3><ol>
<li>构造器用于初始化对象。</li>
<li>构造器如何调用？必须用new来调用啦。这样就可以返回一个初始化完成的对象。</li>
<li>如果你不为一个类提供构造器，那么系统会自动为该类提供一个无参数的构造器</li>
</ol>
<h2 id="构造器重载"><a href="#构造器重载" class="headerlink" title="构造器重载"></a>构造器重载</h2><p>一个类中可以定义多个构造器（因此构造器名必然相同），必须要求形参列表不同——这就是构造器的重载</p>
<p>this调用与this引用</p>
<p>this引用：this紧跟一个。<br>                    this.name;<br>                    this.walk();</p>
<p>this调用：this紧跟圆括号。<br>                 this（参数）<br>                    this调用代表调用同一个类中重载的构造器——this调用只能出现在【构造器】的【第一行】</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>封装、继承、多态——面向对象三大特征</p>
<h3 id="理解继承"><a href="#理解继承" class="headerlink" title="理解继承"></a>理解继承</h3><p>苹果类继承了水果类</p>
<p>老虎继承了动物类</p>
<p>东北虎继承了老虎类</p>
<p>Java的继承：是一种类与类之间关系<br>                        是一种由一般到特殊的关系，子类是一种特殊的父类<br>                        子类实例，完全可以当做父类实例来使用！</p>
<p>父类（超类、基类、大类，一些别称）；</p>
<p>子类（派生类、小类：一些别称）。</p>
<h3 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 类名 extends 父类</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​		</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明</p>
<ul>
<li>Java是单继承，只能有一个直接父类。</li>
<li>如果你不显式继承父类，Java默认是继承Object类（JDK系统提供的类）</li>
</ul>
<p>子类继承父类，可以得到父类的：</p>
<ul>
<li>成员变量</li>
<li>方法</li>
</ul>
<p>继承的好处：【代码复用】     </p>
<h2 id="方法重写（override）"><a href="#方法重写（override）" class="headerlink" title="方法重写（override）"></a>方法重写（override）</h2><p>当子类发现父类不适合自己时，就要重写父类的方法。</p>
<p>方法重写口诀</p>
<ol>
<li><p>方法名相同、形参列表相同。</p>
</li>
<li><p>返回值类型相同或更小， 声明跑出的异常相同或更小</p>
</li>
<li><p>访问权限相同或更大（如果父类访问权限是public的话，那么我们重写只能是public，因为public的权限是最大的了）</p>
<p>@Override：作用是报错。</p>
<pre><code>                    要求被修饰的方法必须重写父类方法，否则就报错。
                比如说如果我们重写的类名写错了，用这个方法可以帮我们发现这个错误，比如我们                    需要重写的类名是fly()，而我们写成了f1y()。
</code></pre></li>
</ol>
<p>Java找变量先就近，</p>
<h2 id="super限定"><a href="#super限定" class="headerlink" title="super限定"></a>super限定</h2><p>与前面this引用非常相似，super用于限定访问父类定义的实例变量或实例方法</p>
<p>super.父类定义的实例变量</p>
<p>super.父类定义的实例方法(参数)</p>
<h2 id="子类构造器调用父类的构造器"><a href="#子类构造器调用父类的构造器" class="headerlink" title="子类构造器调用父类的构造器"></a>子类构造器调用父类的构造器</h2><p><strong>子类构造器【一定调用】父类构造器【一次】——有且仅有一次。</strong></p>
<ol>
<li><p>如果子类构造器没有显式调用父类构造器，那么系统会自动在子类构造器的第一行先调用父类无参数的构造器</p>
</li>
<li><p>子类构造器的第一行显式使用super来调用父类构造器<br>super调用一定是调用的父类的构造器。只能出现在构造器的第一行。<br>this调用是调用当前类的构造器。只能出现在构造器的第一行<br>【很明显，super调用和this调用不可能同时出现。】</p>
<p>super限定：super紧跟一个   <strong>.</strong></p>
<pre><code>                  super.name;
                  super.walk();
</code></pre><p>super调用：super后边紧跟括号。</p>
<pre><code>                  super(参数);
</code></pre></li>
</ol>
<p>【备注】：如果父类没有无参数的构造器，子类的构造器必须显式调用父类指定的构造器。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>我再回顾一下345</p>
<p>3种类型：类、接口、枚举。<br>4个修饰符：private|protected|public、final、static、abstract<br>5大成员：成员变量、方法、构造器、初始化块、内部类</p>
<p>多态的意义：<br>我们先吹一吹<strong>变态</strong>的概念：from 百度百科</p>
<ul>
<li>心理、行为上异于常人而且呈现病态。</li>
<li>经常做出正常人无法理解事情或违背常理行为的人。</li>
<li>能做出令人厌恶、反常的举动。</li>
<li>精神病或者神经不正常。</li>
</ul>
<p>很明显，这个的意思是，在寻常的正常的一群人或者正常的成长路线中，个别人（对象）呈现出变异的行为特征——这个就是变态的定义</p>
<p>再说一说<strong>拟态</strong>：动物为了生存下来，变成令人害怕的样子，吓唬别人</p>
<p><strong>多态</strong>：同一个类型的多个实例、在执行同一个方法，呈现出多种的行为特征——这就叫做“多态”</p>
<p>举个栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 多态 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bird b1 = <span class="keyword">new</span> Sparrow();<span class="comment">// 这边需要注意的是，我的Sparrow类里边是没有fly方法的</span></span><br><span class="line"></span><br><span class="line">        Bird b2 = <span class="keyword">new</span> Ostrich();<span class="comment">// 这边需要注意的是，我的Ostrich类里边是有fly方法的</span></span><br><span class="line"></span><br><span class="line">        b1.fly();<span class="comment">// 当我的b1动态绑定类的fly方法的时候，发现我的Sparrow类里边没有fly方法，于是我的b1就开始寻找父类了，父类Bird里边果然有，所以我输出了“鸟在天上飞”</span></span><br><span class="line"></span><br><span class="line">        b2.fly();<span class="comment">// 当我的b2动态绑定类的fly方法的时候，发现我的Ostrich类里边是有fly方法的，于是我就输出了“鸵鸟当然只能跑啦！”这句话</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我相信上面的例子肯定能够助大家理解什么是多态</span></span><br><span class="line">        <span class="comment">// 相同类型的实例，在执行同一个方法的时候，呈现出多个行为特征。这就叫多态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Bird类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name = <span class="string">"鸟"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鸟在天上飞"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Sparrow类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ostrich类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ostrich</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鸵鸟当然只能跑啦！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="向上转型：子类对象可以直接赋值给父类变量。"><a href="#向上转型：子类对象可以直接赋值给父类变量。" class="headerlink" title="向上转型：子类对象可以直接赋值给父类变量。"></a>向上转型：子类对象可以直接赋值给父类变量。</h3><h3 id="向下转型：父类变量赋值给子类变量。"><a href="#向下转型：父类变量赋值给子类变量。" class="headerlink" title="向下转型：父类变量赋值给子类变量。"></a>向下转型：父类变量赋值给子类变量。</h3><p>强制转换。<br>（类型）变量名。</p>
<h3 id="为什么会有多态呢？"><a href="#为什么会有多态呢？" class="headerlink" title="为什么会有多态呢？"></a>为什么会有多态呢？</h3><p>当我们的Java执行方法时，方法的执行是 动态绑定的。方法总是执行该变量实际所指向对象的方法。</p>
<h3 id="变量的类型（这边再讲一个概念）"><a href="#变量的类型（这边再讲一个概念）" class="headerlink" title="变量的类型（这边再讲一个概念）"></a>变量的类型（这边再讲一个概念）</h3><p>编译时的类型：声明该变量时指定的类型。<br>                           在Java程序的编译阶段，Java编译器只认编译时的类型。</p>
<p>运行时的类型（实际类型）：该变量实际所引用的对象的类型。</p>
<h3 id="强制转换运算符的注意点："><a href="#强制转换运算符的注意点：" class="headerlink" title="强制转换运算符的注意点："></a>强制转换运算符的注意点：</h3><ol>
<li><p>强制转换运算符只能在具有编译类型具有父子关系的变量之间进行转换。否则编译错误</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"在平面上绘制图形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> <span class="keyword">extends</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是一个矩形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">round</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"绕着圆形走一圈"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 多态2 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// s1编译类型是Shape，实际类型是Rect</span></span><br><span class="line">        Shape s1 = <span class="keyword">new</span> Rect();</span><br><span class="line">        s1.draw();</span><br><span class="line"><span class="comment">//        s1.info();// 无法调用，找不到info方法，因为，Java在编译的时候，只认编译类型。对于Java编译器来说，s1是Shape类型</span></span><br><span class="line">        <span class="comment">// 实际上是可以允许的，s1是有这个方法的，是可以运行的，只是编译不能通过</span></span><br><span class="line">        Shape s2 = <span class="keyword">new</span> Circle();</span><br><span class="line">        <span class="comment">// 对于编译器而言，s2是Shape类型，Shape没有round方法</span></span><br><span class="line"><span class="comment">//        s2.round();// 无法运行，同上理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// s2编译类型是Shape，c要求是Circle，Shape无法转换为Circle。，这个时候要用强制转换</span></span><br><span class="line"><span class="comment">//        Circle c = s2;</span></span><br><span class="line">        <span class="comment">// 解决上面的方法是强制转换。</span></span><br><span class="line">        Circle c = (Circle)s2;</span><br><span class="line">        c.round();</span><br><span class="line"></span><br><span class="line">        Circle c2 = (Circle)s1;<span class="comment">// 类型转换异常，s1指向的是Rect，强制转换只能是本来指向要转换的类才能进行转换</span></span><br><span class="line">        <span class="comment">// 比如这边的s2本来就是指向Circle的，于是可以转换</span></span><br><span class="line">        <span class="comment">// 这边的s1本来是指向Rect，所以不能转换</span></span><br><span class="line">        c2.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个例子加以说明</p>
</li>
<li><p>如果在编译类型具有继承关系的变量之间转换，如果被转变量的实际类型，不是要转的目标类型，那么程序就会引发ClassCastException（类型转换异常）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 强转2 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object str1 = <span class="string">"Mr8god"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 强转</span></span><br><span class="line"></span><br><span class="line">        String str = <span class="string">"Mr8god"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Integer it = (Integer) str;// 会报不兼容的错误，因为String跟Integer没有继承关系，所以编译就会报错，报不兼容的类型</span></span><br><span class="line">        Integer it = (Integer) str1;<span class="comment">// 这边Object与Integer之间有继承关系，所以编译能通过，但是运行会出现异常。</span></span><br><span class="line">        <span class="comment">// 编译器要求：必须在编译类型具有继承关系才能强转</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上头还是我写的一个小栗子；</p>
</li>
</ol>
<h3 id="instanceof运算符（为了避免ClassCastException异常）："><a href="#instanceof运算符（为了避免ClassCastException异常）：" class="headerlink" title="instanceof运算符（为了避免ClassCastException异常）："></a>instanceof运算符（为了避免ClassCastException异常）：</h3><p>为了避免ClassCastException异常，Java就增加了这个运算符。</p>
<p>变量名 instanceof 类型 —— 当前面的变量所引用对象是后面类或者子类的实例时，该运算符返回true。</p>
<p>instanceof 只能在编译类型具有继承关系之间进行判断，否则编译报错：不兼容的类型。</p>
<p>所以我们以后在强制转换之前，都要做到先判断再转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 强转2 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object str1 = <span class="string">"Mr8god"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 强转</span></span><br><span class="line"></span><br><span class="line">        String str = <span class="string">"Mr8god"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Integer it = (Integer) str;// 会报不兼容的错误，因为String跟Integer没有继承关系，所以编译就会报错，报不兼容的类型</span></span><br><span class="line"><span class="comment">//        Integer it = (Integer) str1;// 这边Object与Integer之间有继承关系，所以编译能通过，但是运行会出现异常。</span></span><br><span class="line">        <span class="comment">// 编译器要求：必须在编译类型具有继承关系才能强转</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (str1 <span class="keyword">instanceof</span> Integer)</span><br><span class="line">        &#123;</span><br><span class="line">            Integer it = (Integer)str1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有在编译类型具有继承关系才能进行判断，否则编译报错，下面的例子又是一个不兼容的问题，String无法转换为Integer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 强转2 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String s = <span class="string">"Mr8god"</span>;</span><br><span class="line"><span class="comment">//        System.out.println(s instanceof Integer);//是不能运行的，因为String无法转换为Integer。。。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h2><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[修饰符]&#123;</span><br><span class="line"></span><br><span class="line">​			各种语句</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化块是没有名字的，<br>修饰符只能出现一个：static。</p>
<ul>
<li>有static的叫做类初始化块（静态初始化块）；</li>
<li>无static的叫做实例初始化块（非静态初始化块）；</li>
</ul>
<p>初始化块代码小栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">happy1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">2</span>;<span class="comment">// 成员变量-&gt; 实例变量</span></span><br><span class="line"><span class="comment">//    String name;</span></span><br><span class="line"><span class="comment">//    name = "Mr8god";</span></span><br><span class="line">    <span class="comment">//赋值语句不能放在类里边，赋值语句放在方法中</span></span><br><span class="line">    </span><br><span class="line">    String name ;</span><br><span class="line">    &#123;name = <span class="string">"Mr8god"</span>;&#125;<span class="comment">// 这样就变成初始化块了，就可以写了。这个东西叫做代码块中的初始化块（一种特例）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化块分成两种："><a href="#初始化块分成两种：" class="headerlink" title="初始化块分成两种："></a>初始化块分成两种：</h3><h4 id="实例初始化块（无static）"><a href="#实例初始化块（无static）" class="headerlink" title="实例初始化块（无static）"></a>实例初始化块（无static）</h4><p>实例初始化块其实是一种“假象”，一个类在编译之后，实例初始化块就会消失。</p>
<p>实力初始化块的所有代码会被还原到每个构造器的开始部分。<br>举个代码小栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitTest</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Mr8god"</span>);<span class="comment">// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面有两个构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InitTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一个无参构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InitTest</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"带String参数的构造器， 参数为："</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译之后，上面所以代码会变成下面的样子，下面的代码就是上面的本质。</span></span><br><span class="line"><span class="comment">//    public InitTest()</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("Mr8god");// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println("这是一个无参构造器");</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    public InitTest(String name)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("Mr8god");// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println("带String参数的构造器， 参数为：" + name);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边介绍一个命令javap -c 用于分析Java 的class文件<br><img src="https://i.loli.net/2020/04/07/mH9yhbtZ7dSeiwJ.jpg" alt="javap之后的真相.jpg"></p>
<p>经过反编译，得到具体代码运行过程后，我们发现事实确实是这样的哈。</p>
<p>这边再附上一个代码调用上面的类，以方便以后复现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Init in = <span class="keyword">new</span> Init();</span><br><span class="line"></span><br><span class="line">        Init in2 = <span class="keyword">new</span> Init(<span class="string">"江某人来了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="实例初始化块的作用："><a href="#实例初始化块的作用：" class="headerlink" title="实例初始化块的作用："></a>实例初始化块的作用：</h5><ol>
<li>类似于C++中的全局变量，只需要维护一个地方就够了，不需要到每个构造器里操作。</li>
<li>将多个构造器前面部分相同的代码可以提取到实例初始化块中！</li>
</ol>
<h5 id="实例初始化块何时执行呢？"><a href="#实例初始化块何时执行呢？" class="headerlink" title="实例初始化块何时执行呢？"></a>实例初始化块何时执行呢？</h5><p>只要程序调用构造器创建对象，程序总会先执行实例初始化块——因为实例初始化块被还原到每个构造器的所有代码之前。</p>
<h5 id="定义实例变量"><a href="#定义实例变量" class="headerlink" title="定义实例变量"></a>定义实例变量</h5><p>当我的init类是这个时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Init</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Mr8god"</span>);<span class="comment">// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 下面有两个构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是一个无参构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Init</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"带String参数的构造器， 参数为："</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>initTest是这个时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Init in = <span class="keyword">new</span> Init();</span><br><span class="line"></span><br><span class="line">        Init in2 = <span class="keyword">new</span> Init(<span class="string">"江某人来了"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(in2.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果并不是如我刚开始想象的那样是20，因为我以为初始化的20 ，是分散到两个方法里去了，那么引用的话，应该是20呀。结果却是2。</p>
<p><strong>定义实例变量时指定的初始值，也是“假象” 。</strong></p>
<p><strong>——指定初始值，编译之后就变成构造器所有代码之前一条赋值语句！</strong></p>
<p>这里边的int age = 2，本质上是int age ;我们可以通过反编译工具看到</p>
<p><img src="https://i.loli.net/2020/04/07/5jsBlRHOqDAVC2Z.jpg" alt="age没有赋值.jpg"></p>
<p>所以我上面的Init类现在实际上已经变成了这个样子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Init</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 下面有两个构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mr8god"</span>);<span class="comment">// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">        age = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">"这是一个无参构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Init</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mr8god"</span>);<span class="comment">// 实例初始化块，这行代码一编译之后就会没有了，但是这行代码会被提取到下面两个构造器方法的里边的最前头</span></span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">        age = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">"带String参数的构造器， 参数为："</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么很明显，最近一次的赋值age是2。所以会出现问题，不是我想象中的20，也是理所应当了</p>
<p>这里边大费周章又是比较代码又是反编译的，其实主要是为了说明一点</p>
<p>即使我们的赋值语句不在代码块中，编译之后，也是会一起到构造语句中的。over</p>
<p>也就是说，如果我把int age = 2;放在类中的首行，也就是public Init()的上一行，我们得出的结果就会是20了，只是一个age赋值先后顺序的关系。</p>
<h5 id="总结总结总结"><a href="#总结总结总结" class="headerlink" title="总结总结总结"></a>总结总结总结</h5><p>实例初始化块的语句要还原到构造器的所有代码之前；定义变量指定的初始值，也要还原到构造器的所有代码之前；那么这两者的先后顺序呢？按照它们在源代码中的顺序。</p>
<h4 id="类初始化块（有static）"><a href="#类初始化块（有static）" class="headerlink" title="类初始化块（有static）"></a>类初始化块（有static）</h4><p>类初始化块——负责对类执行初始化。<br>                            当程序<strong>第一次主动</strong>使用该类时，系统会为该类分配内存空间、并执行初始化（调用类初始化块）</p>
<h5 id="对-第一次主动-概念做解释："><a href="#对-第一次主动-概念做解释：" class="headerlink" title="对 第一次主动 概念做解释："></a>对 <strong>第一次主动</strong> 概念做解释：</h5><p>除了用类去声明变量，其他只要你使用该类，都算是第一次主动使用该类。可以从Java编译器的角度去理解</p>
<h5 id="类初始化块何时执行"><a href="#类初始化块何时执行" class="headerlink" title="类初始化块何时执行"></a>类初始化块何时执行</h5><p>程序第一次【主动】使用该类时，会执行该类的类初始化块。<br>程序运行时，该类初始化块只会执行一次！</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>执行次数</th>
<th>执行先后</th>
<th>何时执行</th>
</tr>
</thead>
<tbody>
<tr>
<td>类初始化块</td>
<td>1次·</td>
<td>先</td>
<td>第一次主动用该类</td>
</tr>
<tr>
<td>实例初始化块</td>
<td>N次</td>
<td>后</td>
<td>每次调用构造器</td>
</tr>
</tbody>
</table>
</div>
<p><strong>定义实例变量时指定的初始值，也是“假象” 。</strong></p>
<p><strong>——指定初始值，编译之后就变成类初始化中的一条赋值语句！但到底是在类初始化块的代码之前，还是代码之后呢，取决于它在源代码中的顺序。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInit</span> </span>&#123;</span><br><span class="line"><span class="comment">//    static int age = 30;</span></span><br><span class="line"><span class="comment">//    // 类初始化块</span></span><br><span class="line"><span class="comment">//    static &#123;</span></span><br><span class="line"><span class="comment">//        age = 300;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上面代码的本质，如下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 类初始化块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        age = <span class="number">30</span>;</span><br><span class="line">        age = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="大一统"><a href="#大一统" class="headerlink" title="大一统"></a>大一统</h4><p>先上代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base11</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Base11 的类初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Base11 的实例始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base11</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Base11 无参数构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base11</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Base11 的（String）参数构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mid</span> <span class="keyword">extends</span> <span class="title">Base11</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Mid 的类初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Mid 的实例初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">(<span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        System.out.println(<span class="string">"Mid 的(int)构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"Mr8god"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Mid 的无参数构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub1</span> <span class="keyword">extends</span> <span class="title">Mid</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Sub 的类初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Sub 的实例初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sub1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Sub 的无参数构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sub1</span><span class="params">(<span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        System.out.println(<span class="string">"Sub 的（double）构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Sub1(<span class="number">3.4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【结论】：初始化任何类之前，一定先从Object开始初始化，依次初始化它所有祖先类，最后才到它自己；创建任何对象的时候，一定是从Object构造器开始执行，执行它所有祖先类的构造器，最后才执行它自己的构造器！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Mr8god</p>
  <div class="site-description" itemprop="description">Just learning！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">苏 ICP 备 20015778 号 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr8god</span>
</div>
  <!-- <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>
  -->

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共77.9k字</span>
</div>
        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




  















  

  

  

</body>
</html>
